<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1" />
    <meta name="description" content="Презентация по TailwindCSS" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="color-scheme" content="light dark" />

    <title>Семь раз отмерь, один раз оптимизируй</title>

    <style>
      .shower {
        --slide-ratio: calc(16 / 9);
      }
    </style>

    <link rel="icon" href="./themes/tw/images/logo.png" type="image/svg+xml" />

    <!-- prettier-ignore -->
    <link rel="stylesheet" href="node_modules/@shower/ribbon/styles/styles.css">

    <link rel="stylesheet" href="./themes/tw/libs/highlight/hybrid.min.css" />
    <link rel="stylesheet" href="./bundled/main.css" />
  </head>
  <body class="shower list custom-scrollbar all-clear-numbers">
    <header class="caption">
      <h1 class="text-white">«Семь раз отмерь, один раз оптимизируй»</h1>
      <p class="mt-2">
        <i>Денис Русаков</i>
      </p>
    </header>

    <section class="slide p-0">
      <div class="flex h-full flex-col items-center justify-end">
        <img class="!my-10" src="./themes/tw/images/logo.png" width="250" height="250" alt="Перо" />
        <div class="text-center">
          <h2 class="!my-[20px] text-5xl">«Семь раз отмерь, один раз оптимизируй»</h2>
          <p class="text-md italic leading-6">
            <i class="text-gray">Денис Русаков</i>
          </p>
        </div>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">O&rsquo;Reilly</h2>
      <div class="mt-[70px] flex flex-col items-center justify-center opacity-90">
        <div class="-mx-8 flex items-start justify-center gap-8">
          <img src="./themes/tw/images/preview/o-reilly/1.jpg" width="200" height="200" alt="Книга 1" />
          <img src="./themes/tw/images/preview/o-reilly/2.jpg" width="200" height="200" alt="Книга 2" />
          <img src="./themes/tw/images/preview/o-reilly/3.jpg" width="200" height="200" alt="Книга 3" />
        </div>
        <img
          class="mt-8"
          src="./themes/tw/images/preview/o-reilly/logo.svg"
          width="400"
          height="200"
          alt="Логотип O'Reilly"
        />
        <a target="_blank" rel="noopener noreferrer" class="copyright" href="https://www.oreilly.com/"
          >O&rsquo;Reilly</a
        >
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Птица</h2>
      <img class="cover" src="./themes/tw/images/preview/bird.jpg" width="536" height="490" alt="Птица" />
    </section>

    <section class="slide relative">
      <h2 class="shout">Цель доклада</h2>
      <img
        class="next list-hidden absolute bottom-0 right-0"
        src="./themes/tw/pictures/memes/pizza.jpg"
        alt="pizza"
        width="226"
        height="223"
      />
    </section>

    <section class="slide">
      <h2 class="shout">Семплирование данных</h2>
    </section>

    <section class="slide">
      <h2 class="shout">
        Есть ли сейчас проблема?
        <span class="next text-gray">ведь таски закрываются</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">Тестируйте много раз и в разных браузерах</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Сумеречная зона 1</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/the-twilight-zone/1.jpg"
        width="782"
        height="722"
        alt="The twilight zone 1"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Сумеречная зона 2</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/the-twilight-zone/2.jpg"
        width="880"
        height="720"
        alt="The twilight zone 2"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Сумеречная зона 3</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/the-twilight-zone/3.jpg"
        width="700"
        height="628"
        alt="The twilight zone 3"
      />
    </section>

    <section class="slide">
      <h2>Цель оптимизаций</h2>
      <ul>
        <li class="next">Избежать загрузки <mark>лишних</mark> ресурсов</li>
        <li class="next">Уменьшить размер ресурсов</li>
        <li class="next">Уменьшить время получения ресурсов</li>
        <li class="next">Отложить загрузку второстепенных ресурсов</li>
        <li class="next">Избегать <mark>блокировки</mark> основного потока</li>
      </ul>
    </section>

    <section class="slide group">
      <h2>Какой план?</h2>
      <img
        class="next list-hidden float-right translate-x-[70px] translate-y-[200px] group-has-[&.visited]:hidden"
        src="./themes/tw/pictures/memes/plan.jpg"
        width="300"
        height="183"
        alt="План"
        aria-hidden="true"
      />
      <ul class="toc">
        <li class="toc__list-item next" id="first-item">
          <div class="toc__name">Основы</div>
          <div class="page">11</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Возможности</div>
          <div class="page">0</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Набор приемов/советов</div>
          <div class="page">0</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Кейсы</div>
          <div class="page">0</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Выводы</div>
          <div class="page">0</div>
        </li>
      </ul>
    </section>

    <section class="slide" id="act-1">
      <h2 class="cover left-0 mt-[24px] -translate-y-[50%] pl-[120px] text-left group-has-[&.visited]:hidden">
        <span class="text-gray">Акт 1</span>
        <br />
        <span class="motion-duration-2000">Основы</span>
      </h2>
    </section>

    <section class="slide test">
      <div class="place">
        <h2 class="text-left">
          Что такое
          <br />
          <span class="text-[82px]">производительность?</span>
        </h2>
      </div>
      <a class="copyright" rel="noopener noreferrer" target="_blank" href="https://doka.guide/js/performance/"
        >Производительность</a
      >
      <footer>
        <p>
          Ощущаемая пользователем &laquo;производительность&raquo;&nbsp;&mdash; это единственная производительность,
          которая имеет значение. Пользователи взаимодействуют с&nbsp;системой с&nbsp;помощью ввода каких-то данных:
          прикосновений, движения и&nbsp;речи. В ответ, они получают реакцию, основанную на&nbsp;зрительном, тактильном
          или слуховом аппаратах. Производительность - это качество того, как система реагирует на&nbsp;действия
          пользователя.
        </p>
        <p>
          При прочих равных, код, оптимизированный для каких-то иных целей, кроме ощущаемой пользователем
          производительности (здесь и&nbsp;дальше UPP, user-perceived performance) всегда проигрывает коду, который
          оптимизирован для UPP. Упрощённо говоря, пользователи предпочитают отзывчивое и&nbsp;плавное приложение,
          которое обрабатывает 1,000 транзакций к&nbsp;базе данных в&nbsp;секунду грубому неотзывчивому приложению,
          которое обрабатывает 100,000,000 запросов в&nbsp;секунду. Конечно, это не&nbsp;означает, что другие метрики
          становятся ненужным, но&nbsp;первой вашей целью должна быть UPP.
        </p>
        <p>Следующие разделы укажут и&nbsp;объяснят некоторые метрики производительности:</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Цифры</h2>
      <img class="cover" src="./themes/tw/images/basics/numbers.jpg" width="1920" height="1080" alt="Numbers" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Цитата</h2>
      <figure class="place w-[55%]">
        <blockquote class="flex items-start">
          <p>Если вы&nbsp;не&nbsp;можете что-то измерить, значит, вы&nbsp;не&nbsp;можете это исправить</p>
        </blockquote>
        <figcaption>Уильям Томсон</figcaption>
      </figure>
    </section>

    <section class="slide">
      <h2 class="sr-only">Мы разные</h2>
      <img class="cover" src="./themes/tw/images/preview/heads.jpg" alt="heads" width="581" height="1126" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Цитата</h2>
      <figure class="place w-[55%]">
        <blockquote class="flex items-start">
          <p>Преждевременная оптимизация&nbsp;&mdash; корень всех бед</p>
        </blockquote>
        <figcaption>Дональд Кнут</figcaption>
      </figure>
    </section>

    <section class="slide">
      <h2 class="sr-only">Лоадер</h2>
      <div class="flex h-full items-center justify-center">
        <div class="loader animate-wave before:content-['Загрузка...']"></div>
      </div>
    </section>

    <section class="slide" id="cube">
      <h2 class="sr-only">Кубы</h2>
      <video
        muted
        loop
        disablepictureinpicture
        preload="metadata"
        width="400"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/basics/cube.mp4" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2 class="shout">How Fat?</h2>
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://github.com/megahertz/howfat"
        >Howfat</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Local develop</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 bg-[#000] object-cover">
        <video
          muted
          width="500"
          disablepictureinpicture
          preload="metadata"
          class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
          controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
          poster=""
        >
          <source src="./themes/tw/video/cases/registry.webm" type="video/webm" />
        </video>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">OCF</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/ocf.webm" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Ncode</h2>
      <video
        muted
        disablepictureinpicture
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        preload="metadata"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/ncode.webm" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2>Кто помог?</h2>
      <ul>
        <li>
          CSS:
          <a rel="noopener noreferrer" target="_blank" href="https://doka.guide/css/will-change/">will-change</a>
        </li>
        <li>
          JS:
          <a
            rel="noopener noreferrer"
            target="_blank"
            href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame"
            >requestAnimationFrame()</a
          >
        </li>
      </ul>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          myMap.geoObjects.add(myPlacemark)

          window.objectManager.add(featureCollection);
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Скорость загрузки</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Apple</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="600"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/apple.mp4" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2>JIT</h2>
      <img src="./themes/tw/images/basics/arrival.jpg" alt="Arrival" width="56" height="56" />
      <pre class="place">
        <code class="language-typescript">
          «Полный» компилятор, способный генерировать хороший код для любого JavaScript.
Оптимизирующий компилятор, который создает отличный код для большинства JavaScript, но его компиляция занимает больше времени

          Полный компилятор
В V8 полный компилятор работает со всем кодом и начинает его выполнять как можно скорее, быстро генерируя хороший, но не очень хороший код. Этот компилятор почти ничего не предполагает о типах во время компиляции — он ожидает, что типы переменных могут и будут меняться во время выполнения. Код, сгенерированный полным компилятором, использует встроенные кэши (IC) для уточнения знаний о типах во время работы программы, повышая эффективность на лету.

Целью встроенных кэшей является эффективная обработка типов путем кэширования зависящего от типа кода для операций; когда код запускается, он сначала проверяет предположения о типе, а затем использует встроенный кеш для сокращения операции. Однако это означает, что операции, принимающие несколько типов, будут менее производительными.

Поэтому
Мономорфное использование операций предпочтительнее полиморфных операций.
Операции являются мономорфными, если скрытые классы входных данных всегда одни и те же, в противном случае они являются полиморфными, что означает, что некоторые аргументы могут менять тип при разных вызовах операции. Например, второй вызов add() в этом примере вызывает полиморфизм:


function add(x, y) {
  return x + y;
}

add(1, 2);      // + in add is monomorphic
add("a", "b");  // + in add becomes polymorphic```

          Оптимизирующий компилятор
Параллельно с полным компилятором V8 перекомпилирует «горячие» функции (то есть функции, которые выполняются много раз) с помощью оптимизирующего компилятора. Этот компилятор использует обратную связь по типам, чтобы ускорить скомпилированный код — фактически, он использует типы, взятые из микросхем, о которых мы только что говорили!

В оптимизирующем компиляторе операции спекулятивно встраиваются (размещаются непосредственно там, где они вызываются). Это ускоряет выполнение (за счет занимаемой памяти), но также позволяет осуществлять другие оптимизации. Мономорфные функции и конструкторы могут быть полностью встроены (это еще одна причина, почему мономорфизм — хорошая идея в V8).

Вы можете записать то, что оптимизируется, используя автономную версию движка V8 «d8»:


d8 --trace-opt primes.js
(это записывает имена оптимизированных функций в стандартный вывод.)

Однако не все функции могут быть оптимизированы - некоторые функции не позволяют оптимизирующему компилятору запускать данную функцию («спасение»). В частности, оптимизирующий компилятор в настоящее время отказывается от функций с блоками try {} catch {}!

Поэтому
Поместите код, чувствительный к производительности, во вложенную функцию, если у вас есть блоки try {} catch {}: ```js function perf_sensitivity() { // Здесь выполняется работа, чувствительная к производительности }
try { perf_sensitivity() } catch (e) { // Здесь обрабатываем исключения } ```

Это руководство, вероятно, изменится в будущем, поскольку мы включим блоки try/catch в оптимизирующем компиляторе. Вы можете проверить, как оптимизирующий компилятор освобождает функции, используя опцию «--trace-opt» с d8, как указано выше, которая дает вам больше информации о том, какие функции были освобождены:


d8 --trace-opt primes.js
        </code>
      </pre>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/"
        >JIT компилятор</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Мем</h2>
      <img src="./themes/tw/pictures/memes/madman.jpg" alt="Arrival" width="56" height="56" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Мем</h2>
      <img src="./themes/tw/pictures/memes/devs.jpg" alt="Arrival" width="56" height="56" />
    </section>

    <section class="slide">
      <img
        class="rounded-sm border-2"
        src="./themes/tw/images/possibilities/npm/critical.jpg"
        alt="Arrival"
        width="56"
        height="56"
      />
      <img
        class="rounded-sm border-2"
        src="./themes/tw/images/possibilities/npm/debounce.jpg"
        alt="Arrival"
        width="56"
        height="56"
      />
      <img
        class="rounded-sm border-2"
        src="./themes/tw/images/possibilities/npm/perfume.jpg"
        alt="Arrival"
        width="56"
        height="56"
      />
      <img
        class="rounded-sm border-2"
        src="./themes/tw/images/possibilities/npm/throttle.jpg"
        alt="Arrival"
        width="56"
        height="56"
      />
      <img
        src="./themes/tw/images/possibilities/web-almanac/median-page-weight-by-content-type.jpg"
        alt="Arrival"
        width="56"
        height="56"
      />
      <img src="./themes/tw/pictures/emoji/rocket.gif" alt="Arrival" width="56" height="56" />
      <img src="./themes/tw/pictures/emoji/rocket.webp" alt="Arrival" width="56" height="56" />
    </section>

    <section class="slide">
      <h2>Performance: measure() method</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure"
        >https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Счётчики vs&nbsp;Page Speed</h2>
      <footer>
        <p>
          Важно поместить любые советы по производительности в контекст. Советы по производительности вызывают
          привыкание, и иногда сосредоточение внимания сначала на более глубоких советах может сильно отвлечь от
          реальных проблем. Вам необходимо получить целостное представление о производительности вашего веб-приложения —
          прежде чем сосредоточиться на этих советах по производительности, вам, вероятно, следует проанализировать свой
          код с помощью таких инструментов, как PageSpeed , и получить оценку. Это поможет вам избежать преждевременной
          оптимизации.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Performance: measure() method</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://almanac.httparchive.org/en/2022/third-parties#performance-impact"
        >https://almanac.httparchive.org/en/2022/third-parties#performance-impact</a
      >
    </section>

    <section class="slide">
      <h2>Чертовски хорошо</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/"
        >https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/</a
      >
    </section>

    <section class="slide">
      <div>
        <picture>
          <source srcset="./themes/tw/pictures/emoji/eyes.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/eyes.gif" alt="👀" width="32" height="32" />
        </picture>
        <h2 class="shout">Заметно <span class="next">!== значимо</span></h2>
      </div>
    </section>

    <section class="slide">
      <div class="flex h-full items-center justify-center">
        <h2>Что такое скорость загрузки?</h2>
        <p class="next">
          Скорость загрузки&nbsp;&mdash; совокупность факторов, которые влияют на&nbsp;то,
          <mark>воспринимает</mark>&nbsp;ли пользователь загрузку страницы как быструю.
        </p>
      </div>
      <a href="https://web.dev/what-is-speed/" rel="noopener noreferrer" class="copyright" target="_blank"
        >Что такое скорость?</a
      >
    </section>

    <section class="slide">
      <p class="place w-[70%]">
        Ощущаемая пользователем &laquo;производительность&raquo;&nbsp;&mdash; это основная производительность, которая
        имеет значение
      </p>
    </section>

    <section class="slide">
      <h2 class="shout">
        Стресс
        <span class="next text-gray"
          >Задержки в&nbsp;работе мобильных устройств вызывают такой&nbsp;же стресс, как просмотр фильма ужасов!</span
        >
      </h2>
      <a href="https://www.neuronsinc.com/cases/ericsson" class="copyright" target="_blank" rel="noopener noreferrer"
        >The stress of&nbsp;streaming delays</a
      >
    </section>

    <section class="slide">
      <h2 class="shout !text-[42px]">
        производительность
        <span class="bold text-orange">===</span> продуктивность
      </h2>
    </section>

    <section class="slide">
      <h2>Памятка</h2>
      <ul>
        <li class="next">
          выбрать метрики, которыми можно можно охарактериозовать &laquo;степень оптимальности&raquo; нашего сайта или
          приложения
        </li>
        <li class="next">найти код сильене всего ухудшающий метрики</li>
        <li class="next">внести изменния в&nbsp;код</li>
        <li class="next">измерить новые значения</li>
        <li class="next">повторить</li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="shout">Отзывчивость</h2>
      <footer>
        <p>
          Отзывчивость&nbsp;&mdash; это&nbsp;то, как быстро система предлагает ответ (или множество ответов)
          на&nbsp;запрос пользователя. Например, когда пользователь нажимает на&nbsp;экран, он&nbsp;ожидает, что пиксели
          под пальцем изменятся каким-то образом. Для этого случая взаимодействия хорошей метрикой будет время, которое
          прошло между моментом нажатия и&nbsp;изменением пикселей.
        </p>
        <p>
          Отзывчивость иногда включает в&nbsp;себя несколько этапов. Запуск приложения&nbsp;&mdash; один
          из&nbsp;важнейших этапов. Мы&nbsp;обсудим его ниже.
        </p>
        <p>
          Отзывчивость важна просто потому, что пользователи теряются и&nbsp;злятся, когда их&nbsp;игнорируют. Ваше
          приложение игнорирует пользователя каждую секунду, когда оно не&nbsp;отвечает на&nbsp;пользовательский ввод.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">JNT (Just Noticeable Difference)</h2>
      <footer>
        <h2>Хороший алгоритм решения проблемы</h2>
        <ol>
          <li>воспроизвести проблему;</li>
          <li>локализовать ошибку;</li>
          <li>исправить ошибку;</li>
          <li>протестировать;</li>
          <li>избежать повторения в&nbsp;будущем;</li>
          <li>отдать тестировщику.</li>
        </ol>
        <h2>Алгоритм решения проблемы</h2>
        <ol>
          <li>подобрать решение;</li>
          <li>закоммитить;</li>
          <li>отдать тестировщику.</li>
        </ol>
        <p>де-факто</p>
      </footer>
    </section>

    <section class="slide">
      <h2>На&nbsp;что мы&nbsp;можем повлиять?</h2>
      <ul>
        <li class="next">Графика</li>
        <li class="next">Шрифты</li>
        <li class="next">HTML</li>
        <li class="next">CSS</li>
        <li class="next">JS</li>
        <li class="next">Анимации</li>
        <li class="next">Third Party Scripts</li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                <code class="language-typescript">
                  const team = "webpractik";
                </code>
              </pre>
      <table class="mt-5">
        <thead>
          <tr class="next">
            <th>Token</th>
            <th>Token type</th>
          </tr>
        </thead>
        <tbody>
          <tr class="next">
            <td>const</td>
            <td>
              <i>Keyword</i>
            </td>
          </tr>
          <tr class="next">
            <td>num</td>
            <td>
              <i>Identifer</i>
            </td>
          </tr>
          <tr class="next">
            <td>=</td>
            <td>
              <i>Operator</i>
            </td>
          </tr>
          <tr class="next">
            <td>webpractik</td>
            <td>
              <i>String</i>
            </td>
          </tr>
        </tbody>
      </table>
      <footer>
        <p>
          Прежде чем разобрать код в&nbsp;абстрактное синтаксическое дерево, мы&nbsp;сначала преобразуем его
          в&nbsp;токены. Это преобразование происходит в&nbsp;лексическом анализе. Сканер потребляет поток символов
          Unicode, объединяет его в&nbsp;токены и&nbsp;удаляет все проблемы, переводы строк, комментарий. Эти токены
          ключевые слова токены. С&nbsp;помощью парсера V8&nbsp;токены преобразуются в&nbsp;абстрактное дерево
          и&nbsp;проверка синтаксиса языка
        </p>
        https://nolanlawson.com/2024/09/18/improving-rendering-performance-with-css-content-visibility/
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">How Bun supports V8&nbsp;APIs without using&nbsp;V8 (part&nbsp;1)</h2>
      <a
        class="copyright"
        rel="noopener noreferrer"
        target="_blank"
        href="https://bun.sh/blog/how-bun-supports-v8-apis-without-using-v8-part-1"
        >https://bun.sh/blog/how-bun-supports-v8-apis-without-using-v8-part-1</a
      >
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Эффективность</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/battery.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/battery.gif" alt="🔋" width="56" height="56" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <h2>Что может мешать?</h2>
      <ul>
        <li class="next">Network</li>
        <li class="next">RAM</li>
        <li class="next">CPU</li>
      </ul>
    </section>

    <section class="slide">
      <h2>Использование аннотирования типов</h2>
      <pre class="place">
        <code class="language-typescript">
          import { otherFunc } from "other";

          export function func() {
              return otherFunc();
          }
        </code>
      </pre>
      <footer>
        <p>
          Добавление аннотирования типов, особенно для возвращаемых значений, может сэкономить компилятору кучу работы.
          Отчасти потому, что именованные типы обычно компактнее анонимных (которые компилятор может приводить), что
          уменьшает время на&nbsp;чтение и&nbsp;запись объявляющих файлов (например, для инкрементальных сборок).
          Приведение типов очень удобно, так что нет нужды делать это универсально. Но&nbsp;бывает полезно попробовать,
          когда находишь в&nbsp;своём коде медленные фрагменты.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Использование аннотирования типов</h2>
      <pre class="place">
        <code class="language-typescript">
          import { otherFunc, otherType } from "other";

          export function func(): otherType {
                return otherFunc();
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Браузерный движок</h2>
      <p class="place w-[70%]">
        <b>Браузерный движок (layout engine)</b>&nbsp;&mdash; специализированная программа,
        <mark>обрабатывающая и преобразующая</mark> содержимое страниц в интерактивное изображение на экране
      </p>
    </section>

    <section class="slide">
      <h2>Какие движки существуют?</h2>
      <ul>
        <li class="next flex items-center">
          V8
          <a
            class="next ml-4"
            href="https://www.google.com/intl/ru_ru/chrome/"
            target="_blank"
            rel="noopener noreferrer"
          >
            <img src="./themes/tw/images/shared/browsers/chrome.svg" alt="Chrome" width="56" height="56" />
          </a>
          <a
            class="next ml-4"
            href="https://www.google.com/intl/ru_ru/chrome/"
            target="_blank"
            rel="noopener noreferrer"
          >
            <img src="./themes/tw/images/shared/browsers/chromium.svg" alt="Chrome" width="56" height="56" />
          </a>
          <a
            class="next ml-4"
            href="https://www.google.com/intl/ru_ru/chrome/"
            target="_blank"
            rel="noopener noreferrer"
          >
            <img src="./themes/tw/images/shared/browsers/chrome-canary.svg" alt="Chrome" width="56" height="56" />
          </a>
          <a href="https://arc.net/" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/arc.svg" alt="Node.js" width="56" height="56" />
          </a>
          <a href="https://nodejs.org/en" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/tools/node-js.svg" alt="Node.js" width="56" height="56" />
          </a>
        </li>
        <li class="next flex items-center">
          SpiderMonkey
          <a
            href="https://www.mozilla.org/ru/firefox/"
            class="next ml-4 group-has-[&.visited]:hidden"
            target="_blank"
            rel="noopener noreferrer"
          >
            <img src="./themes/tw/images/shared/browsers/firefox-old.svg" alt="Firefox" width="56" height="56" />
          </a>
          <a href="https://www.mozilla.org/ru/firefox/" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/firefox.svg" alt="Firefox" width="56" height="56" />
          </a>
          <a href="https://www.mozilla.org/ru/firefox/" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/opera.svg" alt="Opera" width="56" height="56" />
          </a>
          <a href="https://www.mozilla.org/ru/firefox/" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/vivaldi.svg" alt="Vivaldi" width="56" height="56" />
          </a>
          <a href="https://www.mozilla.org/ru/firefox/" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/yandex.svg" alt="Yandex browser" width="56" height="56" />
          </a>
        </li>
        <li class="next flex items-center">
          Chakra&nbsp;/ ChakraCore
          <a
            class="next ml-4"
            href="https://www.microsoft.com/ru-ru/edge/download?form=MA13FW"
            target="_blank"
            rel="noopener noreferrer"
          >
            <img src="./themes/tw/images/shared/browsers/edge.svg" alt="Edge" width="56" height="56" />
          </a>
        </li>
        <li class="next flex items-center">
          JavaScriptCore
          <a href="" class="next ml-4" target="_blank" rel="noopener noreferrer">
            <img src="./themes/tw/images/shared/browsers/safari.svg" alt="Safari" width="56" height="56" />
          </a>
          <a href="" target="_blank" rel="noopener noreferrer">
            <img class="next ml-4" src="./themes/tw/images/shared/tools/bun.svg" alt="Bun" width="56" height="56" />
          </a>
        </li>
        <li class="next flex items-center">
          и&nbsp;другие
          <a href="https://brave.com/" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/shared/browsers/brave.svg"
              alt="Safari"
              width="56"
              height="56"
            />
          </a>
          <a href="https://sigmaos.com/" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/shared/browsers/sigma.svg"
              alt="Safari"
              width="56"
              height="56"
            />
          </a>
        </li>
      </ul>
      <footer>
        <p>
          Движок&nbsp;&mdash; это ядро любого браузера. Он&nbsp;представлен в&nbsp;виде скрипта и&nbsp;отвечает
          за&nbsp;преобразование кода Web-продукта в&nbsp;динамическое изображение, которое отображается на&nbsp;экране
          устройства пользователя. Различия в движках базируются на&nbsp;том, что они имеют разные алгоритмы обработки
          кода. А&nbsp;ещё в&nbsp;них использованы отличные друг от&nbsp;друга принципы реализации стандартов web.
          Сейчас актуальны движки Blink, WebKit и&nbsp;Quantum (Gecko), а такие как Trident, EdgeHTML и&nbsp;Presto уже
          ушли в&nbsp;прошлое. Ниже мы&nbsp;рассмотрим основные движки и&nbsp;разберём, как их особенности влияют
          на&nbsp;тестирование.
        </p>
        <p>
          Blink Современный движок, созданный в&nbsp;2013 году на&nbsp;основе WebKit. Считается достаточно быстрым и
          высокопроизводительным для работы именно с&nbsp;web-приложениями. Применяется в&nbsp;Google Chrome, Opera
          и&nbsp;новых версиях Microsoft Edge, а&nbsp;также в&nbsp;других браузерах на&nbsp;базе Chromium, например,
          Yandex Browser. WebKit Оптимизирован под устройства компании Apple. Как и&nbsp;Blink, обладает высокой
          производительностью и&nbsp;поддерживает все основные web-стандарты. Ещё одним из&nbsp;его достоинств является
          энергоэффективность и&nbsp;высокое качество рендеринга текста и&nbsp;графики, что особенно важно для дисплеев
          с&nbsp;высоким разрешением. Применяется в&nbsp;Safari. Gecko Довольно-таки старый движок&nbsp;&mdash; был
          разработан аж&nbsp;в&nbsp;1997&nbsp;году. Его неоспоримые преимущества &mdash; кроссплатформенность
          и&nbsp;гибкость, т.к. Gecko поддерживает множество операционных систем, в&nbsp;том числе Windows, macOS, Linux
          и&nbsp;Android. Как и&nbsp;Blink и&nbsp;WebKit, поддерживает все основные web-стандарты. Хотя может быть
          и&nbsp;не такой шустрый, как WebKit, но&nbsp;у&nbsp;него своя фишечка&nbsp;&mdash; расширяемость, т.е. может
          поддерживать множество уникальных расширений и&nbsp;плагинов (например Selenium). Применяется в&nbsp;Firefox
          (до&nbsp;версии&nbsp;57) и&nbsp;других продуктах Mozilla (например, почтовый клиент Thunderbird), SeaMonkey.
          Quantum (Gecko). Это крупное обновление движка Gecko, выпущенное в&nbsp;2017&nbsp;году, которое значительно
          улучшило качество браузера Firefox. Благодаря поддержке современных web-стандартов Firefox сейчас один
          из&nbsp;самых совместимых браузеров. Применяется в&nbsp;Firefox (с&nbsp;версии 57), Tor Browser и&nbsp;Water
          fox. Trident и&nbsp;EdgeHTML Trident использовался в&nbsp;Internet Explorer (начиная с&nbsp;v4.0).
          EdgeHTML&nbsp;&mdash; это ответвление от&nbsp;него, созданное специально для Microsoft Edge. EdgeHTML был
          заменен на&nbsp;Blink в его новых версиях. Главный минус этих движков&nbsp;&mdash; проблемы
          с&nbsp;совместимостью и&nbsp;безопасностью. Presto Основным применением Presto был браузер Opera, который
          до&nbsp;2013 года использовал этот движок. Также Presto использовался в&nbsp;некоторых мобильных браузерах
          и&nbsp;устройствах, таких как Opera Mini и&nbsp;Opera Mobile. Как и&nbsp;EdgeHTML, был заменен на&nbsp;Blink.
          Presto, Trident и&nbsp;Gecko&nbsp;&mdash; уже по&nbsp;большей части история. А&nbsp;вот триумвират Quantum
          (Gecko), Blink и&nbsp;WebKit очень хорош. Эти движки являются самыми современными движками на&nbsp;сегодняшний
          день. Итак, зачем это знать тестировщику? Знание особенностей работы браузерных движков важно для
          QA-специалистов по&nbsp;нескольким причинам.&nbsp;1. Производительность движков может существенно отличаться.
          Например, однажды на&nbsp;проекте у&nbsp;нас возникла ситуация: приложение с&nbsp;интерактивными элементами
          и&nbsp;динамической загрузкой контента прекрасно работало в&nbsp;Chrome (Blink), но&nbsp;в&nbsp;Firefox
          (Gecko) мы&nbsp;заметили явные задержки в&nbsp;рендеринге. В&nbsp;итоге пришлось проводить дополнительную
          оптимизацию, чтобы приложение работало плавно во&nbsp;всех целевых браузерах.&nbsp;2. Кросс-браузерная
          совместимость и&nbsp;обработка HTML/CSS/JavaScript. Движки обрабатывают HTML, CSS и&nbsp;JavaScript
          по-разному. Это может привести к&nbsp;тому, что одно и&nbsp;то&nbsp;же web-приложение будет работать иначе
          в&nbsp;разных браузерах. Например, анимации, макеты или скрипты могут отображаться корректно в&nbsp;Chrome,
          но&nbsp;возникнут проблемы в&nbsp;Safari или Firefox. Знание особенностей каждого движка позволяет выявить
          такие различия на&nbsp;ранних этапах тестирования. По статистике, в&nbsp;Российской Федерации распределение
          среди пользователей предпочтений в&nbsp;использовании браузеров за последний год следующее:
          Chrome&nbsp;&mdash; 50% Yandex Browser&nbsp;&mdash; 23% Safari&nbsp;&mdash; 11% Opera&nbsp;&mdash;
          6%&nbsp;Microsoft Edge и&nbsp;Firefox - 3%&nbsp;Вот именно это и&nbsp;следует учитывать при проведении
          кросс-браузерного тестирования. Около 80-85% пользователей используют браузеры с&nbsp;движком Blink. Так что
          при тестировании мы&nbsp;смело можем выбрать один из&nbsp;них (Google Chrome, Yandex Browser, Opera или
          Microsoft Edge) и&nbsp;примерно с&nbsp;99,9(9)% вероятностью web-продукт в&nbsp;них будет работать
          и&nbsp;отображаться одинаково. А&nbsp;вот чтобы быть полностью уверенным в&nbsp;том, что web-продукт подходит
          остальным 15-20% пользователей, которые используют браузеры на&nbsp;основе иных движков, необходимо
          дополнительно проверить его в&nbsp;браузере Safari и&nbsp;Firefox. В&nbsp;одном из&nbsp;проектов
          мы&nbsp;работали с&nbsp;макетами, построенными на&nbsp;CSS Flexbox и&nbsp;Grid. В&nbsp;Chrome и&nbsp;Safari
          (на&nbsp;WebKit) вёрстка выглядела идеально, но&nbsp;как только мы&nbsp;проверили в&nbsp;старом Internet
          Explorer&nbsp;11 (на&nbsp;Trident), макет полностью поехал. Пришлось внедрять различные CSS-хаки, чтобы
          обеспечить корректное отображение в&nbsp;старых браузерах. В&nbsp;другой раз возникли проблемы работы
          сервис-воркеров (service workers), которые позволяют реализовать оффлайн-режим: с&nbsp;одной стороны всё
          ок&nbsp;в&nbsp;Chrome и&nbsp;Firefox, а&nbsp;с другой проблемы в&nbsp;старых версиях Safari. В&nbsp;итоге
          использовали фолбэки и&nbsp;альтернативные методы для того, чтобы обеспечить работу приложения на&nbsp;всех
          платформах. Эти случаи научили нас всегда помнить про поддержку кросс-браузерности и&nbsp;старых
          движков.&nbsp;3. Движки браузеров влияют на&nbsp;то, как web-приложение будет работать на различных платформах
          (десктоп, мобильные устройства, планшеты). Например, WebKit, который используется в Safari на&nbsp;устройствах
          Apple, обладает лучшей энергоэффективностью и&nbsp;рендерингом для экранов с&nbsp;высоким разрешением.&nbsp;4.
          При обнаружении бага важно понимать, связано&nbsp;ли это с&nbsp;ошибкой в&nbsp;коде приложения или с
          особенностями работы конкретного движка. Это помогает точнее локализовать проблему и&nbsp;эффективнее
          взаимодействовать с&nbsp;разработчиками для ее&nbsp;исправления. Например, баг, который появляется только
          в&nbsp;Firefox, может быть результатом специфики движка Gecko.&nbsp;5. Важно понимать, какой движок лучше
          поддерживает инструменты для автоматизации, чтобы выбрать наиболее подходящий подход к&nbsp;тестированию.
          Движки могут иметь разную степень поддержки инструментов для автоматизации, таких как Selenium или Puppeteer.
          Вот Gecko поддерживает множество уникальных расширений и&nbsp;плагинов для тестирования. Это знание помогает
          выбрать правильный подход для автоматизации тестирования... Как-то в&nbsp;ходе работы с&nbsp;Selenium мой
          коллега обнаружил, что движок Gecko (в Firefox) позволяет лучше интегрировать уникальные расширения
          и&nbsp;плагины для автоматизированного тестирования. Мы&nbsp;использовали это преимущество для создания
          сложных сценариев тестирования.&nbsp;6. Знание устаревших движков, таких как Trident или Presto, важно при
          тестировании старых приложений или для обеспечения поддержки legacy-систем. Тестировщики должны быть готовы
          к&nbsp;специфическим проблемам, которые могут возникнуть в&nbsp;таких системах. В&nbsp;конечном итоге,
          глубокое понимание браузерных движков помогает обеспечивать высокое качество продукта на&nbsp;разных
          устройствах и&nbsp;платформах. Это улучшает пользовательский опыт и&nbsp;снижает вероятность возникновения
          проблем после релиза. Ну&nbsp;разве не&nbsp;стоит знать заранее, что Blink и&nbsp;WebKit активно поддерживают
          API для работы с&nbsp;аппаратным обеспечением устройства, таким как доступ к&nbsp;камере через WebRTC,
          а&nbsp;Gecko может иметь особенности в&nbsp;реализации этого API? Такое поведение легко заметить при
          тестировании видео-конференц-приложений или приложений, использующих запись с&nbsp;камеры&nbsp;&mdash;
          в&nbsp;Firefox возникают проблемы с разрешением камеры или звуком, в&nbsp;то&nbsp;время как в&nbsp;Chrome или
          Safari эти функции работают корректно. Эти примеры помогли нам на&nbsp;практике увидеть, как знание движков
          даёт шанс обнаруживать и&nbsp;решать проблемы, связанные с производительностью, совместимостью, безопасностью
          и&nbsp;функциональностью приложений на&nbsp;разных браузерах. Надеюсь, эта статья убедила вас, что знания
          о&nbsp;движках браузеров нужны специалистам по&nbsp;тестированию. Буду признателен, если дадите обратную связь
          и&nbsp;поделитесь своим опытом в&nbsp;этой теме.
        </p>
        <p></p>
        <p>V8&nbsp;&mdash; это основной движок в&nbsp;Node.js, как и&nbsp;во&nbsp;всех Chrome Based браузерах</p>
        <p>
          Всеми нелюбимая Chakra, которая находится в&nbsp;Internet Explorer. Она даже работает
          не&nbsp;с&nbsp;JavaScript, а&nbsp;с&nbsp;Jscript&nbsp;&mdash; есть такое подмножество.
        </p>
        <p>Современные Chakra и&nbsp;ChakraCore, которые работают в&nbsp;Edge;</p>
        <p>SpiderMonkey в&nbsp;FireFox;</p>
        <p>
          JavaScriptCore в&nbsp;WebKit. Также он&nbsp;используется в&nbsp;React Native. Если у&nbsp;вас RN-приложение
          под Android, то&nbsp;оно так&nbsp;же исполняется на&nbsp;JavaScriptCore&nbsp;&mdash; движок идёт
          в&nbsp;комплекте с&nbsp;приложением.
        </p>
        <p>
          Rhino и&nbsp;Nashorn&nbsp;&mdash; это движки, которые используются в&nbsp;Java. С&nbsp;их&nbsp;помощью там
          тоже можно исполнять JavaScript
        </p>
        <p>JerryScript&nbsp;&mdash; для встраиваемых устройств;</p>
        <p>
          О&nbsp;двух компиляторах, которые использовались в&nbsp;V8&nbsp;Внутреннее устройство V8&nbsp;изменилось
          с&nbsp;выходом версии 5.9, которая появилась совсем недавно. До&nbsp;этого&nbsp;же он&nbsp;использовал два
          компилятора: full-codegen&nbsp;&mdash; простой и&nbsp;очень быстрый компилятор, который выдаёт сравнительно
          медленный машинный код. Crankshaft&nbsp;&mdash; более сложный оптимизирующий JIT-компилятор, который
          генерирует хорошо оптимизированный код. Внутри движка используются несколько потоков: Главный поток, который
          занимается тем, что от&nbsp;него можно ожидать: читает исходный JS-код, компилирует его и&nbsp;выполняет.
          Поток компиляции, который занимается оптимизацией кода в&nbsp;то&nbsp;время, когда выполняется главный поток.
          Поток профилировщика, который сообщает системе о&nbsp;том, в&nbsp;каких методах программа тратит больше всего
          времени, как результат, Crankshaft может эти методы оптимизировать. Несколько потоков, которые поддерживают
          механизм сборки мусора. При первом исполнении JS-кода V8&nbsp;задействует компилятор full-codegen, который
          напрямую, без каких-либо дополнительных трансформаций, транслирует разобранный им&nbsp;JavaScript-код
          в&nbsp;машинный код. Это позволяет очень быстро приступить к&nbsp;выполнению машинного кода. Обратите внимание
          на&nbsp;то, что V8&nbsp;не использует промежуточное представление программы в&nbsp;виде байт-кода, таким
          образом, устраняя необходимость в&nbsp;интерпретаторе. После того, как код какое-то время поработает, поток
          профилировщика соберёт достаточно данных для того, чтобы система могла понять, какие методы нужно
          оптимизировать. Далее, в&nbsp;другом потоке, начинается оптимизация с&nbsp;помощью Crankshaft.
          Он&nbsp;преобразует абстрактное синтаксическое дерево JavaScript в&nbsp;высокоуровневое представление,
          использующее модель единственного статического присваивания (static single-assignment, SSA). Это представление
          называется Hydrogen. Затем Crankshaft пытается оптимизировать граф потока управления Hydrogen. Большинство
          оптимизаций выполняется на&nbsp;этом уровне.
        </p>
      </footer>
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Codeium 1</h2>
      <img class="cover" src="./themes/tw/images/basics/v8/codeium/1.jpg" width="989" height="316" alt="Codeium 1" />
      <img
        class="next translate-x-[600px] translate-y-[340px]"
        src="./themes/tw/pictures/memes/Ilon.jpg"
        width="300"
        height="150"
        alt="Мем Ilon"
      />
      <a class="copyright" href="https://codeium.com/live/general" target="_blank" rel="noopener noreferrer">codeium</a>
      <footer>
        <p>
          Процентные результаты представляют собой количество операций, выполненных в&nbsp;течение 1&nbsp;с, деленное на
          количество операций в&nbsp;случае с&nbsp;наивысшей оценкой. Чем выше, тем лучше.
        </p>
        <p>
          Как видите, разница может быть существенной. Разница не&nbsp;обязательно связана со&nbsp;стоимостью, strcmp
          поскольку движки иногда могут использовать пул строк и&nbsp;сравнивать по&nbsp;ссылке, но&nbsp;она также
          связана с&nbsp;тем, что целые числа обычно передаются по&nbsp;значению в&nbsp;движках&nbsp;JS, тогда как
          строки всегда передаются как указатели, а&nbsp;доступ к памяти является дорогостоящим (см. раздел 5).
          В&nbsp;коде с&nbsp;большим количеством строк это может иметь огромное влияние. В&nbsp;качестве примера
          из&nbsp;реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в&nbsp;2 раза быстрее *,
          просто заменив строковые константы числами.&nbsp;0. Избегать работы Это может показаться очевидным,
          но&nbsp;это должно быть здесь, потому что не&nbsp;может быть другого первого шага к&nbsp;оптимизации: если
          вы&nbsp;пытаетесь оптимизировать, вы&nbsp;должны сначала рассмотреть возможность избегания работы. Это
          включает в&nbsp;себя такие концепции, как мемоизация, лень и&nbsp;инкрементальные вычисления. Это будет
          применяться по-разному в&nbsp;зависимости от&nbsp;контекста. В&nbsp;React, например, это будет означать
          применение memo()и useMemo()других применимых примитивов. 21&nbsp;марта 2024&nbsp;г. Оптимизация Javascript
          для развлечения и&nbsp;прибыли&nbsp;Я часто чувствую, что код javascript в&nbsp;целом работает гораздо
          медленнее, чем мог&nbsp;бы, просто потому, что он&nbsp;не&nbsp;оптимизирован должным образом. Вот сводка
          распространенных методов оптимизации, которые я&nbsp;нашел полезными. Обратите внимание, что компромиссом для
          производительности часто является читаемость, поэтому вопрос о&nbsp;том, когда выбирать между
          производительностью и читаемостью, остается на&nbsp;усмотрение читателя. Я&nbsp;также отмечу, что разговор
          об&nbsp;оптимизации обязательно требует разговора о&nbsp;бенчмаркинге. Микрооптимизация функции в&nbsp;течение
          нескольких часов, чтобы она работала в&nbsp;100 раз быстрее, бессмысленна, если функция изначально
          представляла лишь часть фактического общего времени выполнения. Если вы&nbsp;оптимизируете, первым
          и&nbsp;самым важным шагом является бенчмаркинг. Я&nbsp;рассмотрю эту тему в&nbsp;последующих пунктах. Также
          имейте в&nbsp;виду, что микробенчмарки часто имеют недостатки, и&nbsp;это может включать&nbsp;те, что
          представлены здесь. Я&nbsp;сделал все возможное, чтобы избежать этих ловушек, но&nbsp;не&nbsp;применяйте слепо
          ни&nbsp;один из пунктов, представленных здесь, без бенчмаркинга. Я&nbsp;включил примеры запуска для всех
          случаев, где это возможно. По&nbsp;умолчанию они показывают результаты, которые я&nbsp;получил на&nbsp;своей
          машине (brave 122&nbsp;на archlinux), но&nbsp;вы можете запустить их&nbsp;самостоятельно. Как&nbsp;бы мне
          ни&nbsp;было неприятно это говорить, Firefox немного отстал в&nbsp;плане оптимизации и&nbsp;на&nbsp;данный
          момент представляет собой очень малую часть трафика , поэтому я&nbsp;не&nbsp;рекомендую использовать
          результаты, которые вы&nbsp;получите на&nbsp;Firefox, в&nbsp;качестве полезных индикаторов.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Codeium 2</h2>
      <img class="cover" src="./themes/tw/images/basics/v8/codeium/2.jpg" width="989" height="316" alt="Codeium 2" />
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="!m-0">Как устроен <i>V8</i> ?</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/eyes.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/eyes.gif" alt="👀" width="56" height="56" aria-hidden="true" />
        </picture>
        <a class="copyright" href="https://v8.dev/blog/10-years" target="_blank" rel="noopener noreferrer">V8</a>
      </div>
      <footer>
        <p>
          В&nbsp;движке V8&nbsp;нет интерпретаторов, но&nbsp;существует 2&nbsp;типа компиляторов&nbsp;&mdash; общий
          и&nbsp;оптимизирующий. Это привод к&nbsp;тмоу, что&nbsp;JS всегда компилируется и&nbsp;запускается так&nbsp;же
          как и&nbsp;машинный код. Означает&nbsp;ли это, что код работает быстро? Нет, Сама по&nbsp;себе компиляция
          не&nbsp;ускоряет работу кода. Она позволяет избежать накладных расходов, вызванных работой интерпретатора,
          но&nbsp;неоптимизированный код будет работать медленно.
        </p>
        <p>Через скрытые классы V8&nbsp;идентифицирует объекты</p>
        <p>
          когда вы&nbsp;создаете новый объект движок создаст для него новый скрытый класс. Затем если вы&nbsp;измените
          тот&nbsp;же объект добавив новое свойство механизм создаст новый скрытый класс со&nbsp;всеми свойствам
          из&nbsp;предыдущего класса и&nbsp;включит новое свойство
        </p>
        <p>Мономофризм что у&nbsp;объектов одинаковые ключи без отличий</p>
        <p>Мегаморфизм тут объекты совершенно разные и&nbsp;их&nbsp;нельзя сравнивать</p>
        <p>Полиморфизм у&nbsp;объектов общая структура но&nbsp;меняются небольшие отличия</p>
        <p>
          Если вы не можете удалить фрагмент кода, постарайтесь выполнять его реже Ваш код работает в том числе за счет
          простого повторения операций, но тут легко переборщить и начать выполнять их чаще необходимого. Вот несколько
          конкретных примеров, на которые стоит обратить внимание.
        </p>
        <p>
          preload– когда вам понадобится ресурс через несколько секунд prefetch– когда вам нужен ресурс для следующей
          страницы preconnect– когда вы знаете, что вам скоро понадобится ресурс, но вы пока не знаете его полный URL
          dns-prefetch– когда вы знаете, что вам скоро понадобится ресурс, но вы еще не знаете его полный URL (для
          старых браузеров) prerender– когда вы уверены, что большинство пользователей перейдут на определенную
          страницу, и вы хотите ускорить этот процесс modulepreload– когда вам скоро понадобится скрипт модуля ES других
          статьях я писал о том, что использовать Set может быть быстрее, чем Array, а Map — чем регулярные объекты. Set
          и Map — это коллекции, которые используют ключи, они могу пригодиться, если вы регулярно
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Works</h2>
      <div class="columns three">
        .js .wasm
        <img class="m-auto" src="./themes/tw/images/basics/v8/ignition.svg" alt="ignition" width="221" height="1080" />
        <img class="m-auto" src="./themes/tw/images/basics/v8/liftoff.svg" alt="Liftoff" width="221" height="1080" />
        <img class="m-auto" src="./themes/tw/images/basics/v8/logo.svg" alt="main" width="221" height="1080" />
        <img class="m-auto" src="./themes/tw/images/basics/v8/orinoco.svg" alt="Orinoco" width="221" height="1080" />
        <img class="m-auto" src="./themes/tw/images/basics/v8/turbofan.svg" alt="Turbofan" width="221" height="1080" />
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Works</h2>
      <img class="cover" src="./themes/tw/images/basics/v8/works.jpg" alt="Works" width="706" height="1448" />
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://addyosmani.com/">Addy Osmani</a>
    </section>

    <section class="slide">
      <h2 class="place">Он&nbsp;развивается?</h2>
      <a class="copyright" href="https://v8.dev/blog/10-years" target="_blank" rel="noopener noreferrer"
        >10&nbsp;years</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Чем измерять производительность?</h2>
      <footer>
        <p>Лабораторные</p>
        <ul>
          <li>Имитируются в&nbsp;лабораторных условиях</li>
          <li>Зависят от&nbsp;среды проверки</li>
          <li>Результаты от&nbsp;проверки к&nbsp;проверке могут отличаться</li>
        </ul>
        <p>Полевые</p>
        <ul>
          <li>Собираются с&nbsp;реальных пользователей</li>
          <li>Отличаются для разных пользователей</li>
          <li>Необходимо достаточное количество для анализа</li>
        </ul>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Dev Tools</h2>
      <a class="copyright" href="https://www.youtube.com/watch?v=70XMVfGv2Q0" target="_blank" rel="noopener noreferrer"
        >Chrome DevTools&nbsp;&mdash; спрятанные полезности</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Directed by</h2>
      <img class="cover" src="./themes/tw/pictures/memes/directed-by.jpg" alt="Directed by" width="800" height="750" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Network</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/network.jpg"
        alt="Network"
        width="921"
        height="1080"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Perfomance</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/perfomance/base.jpg"
        alt="Perfomance"
        width="921"
        height="1080"
      />
      <a
        class="copyright"
        href="https://github.com/iamakulov/devtools-perf-features"
        target="_blank"
        rel="noopener noreferrer"
        >(devtools-perf-features)</a
      >
      <footer>
        <p>
          Если вы&nbsp;профилируете в&nbsp;браузере, убедитесь, что вы&nbsp;используете чистый и&nbsp;пустой профиль
          браузера. Я&nbsp;даже использую для этого отдельный браузер. Если вы&nbsp;профилируете и&nbsp;у&nbsp;вас
          включены расширения браузера, они могут испортить измерения. React devtools в&nbsp;частности существенно
          повлияют на&nbsp;результаты, код рендеринга может выглядеть медленнее, чем он&nbsp;есть на&nbsp;самом деле
          в&nbsp;зеркале для ваших пользователей. Различные движки будут оптимизировать определенные шаблоны лучше или
          хуже других. Вам следует провести бенчмаркинг для движков, которые имеют отношение к&nbsp;вам,
          и&nbsp;расставить приоритеты, какой из&nbsp;них важнее. Вот реальный пример в&nbsp;Babel, где улучшение
          V8&nbsp;означает снижение производительности JSC. https://github.com/babel/babel/pull/16357 11.2 Сомневаетесь
          в&nbsp;своих результатах Если вы&nbsp;только что оптимизировали функцию, и&nbsp;теперь она работает в&nbsp;100
          раз быстрее, усомнитесь в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме
          производства, забросайте ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам
          факт наблюдения за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Heap profile</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/perfomance/heap-profile.jpg"
        alt="Perfomance memory"
        width="854"
        height="1319"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Perfomance memory</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/perfomance/memory.jpg"
        alt="Perfomance memory"
        width="854"
        height="1319"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Perfomance insights</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/perfomance/perfomance-insights.jpg"
        alt="Perfomance insights"
        width="755"
        height="1440"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Стек</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/stack.jpg"
        alt="Стек"
        width="1367"
        height="459"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/memory.jpg"
        alt="Memory"
        width="1921"
        height="1080"
      />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/rendering.jpg"
        alt="Rendering"
        width="2154"
        height="1081"
      />
    </section>

    <section class="slide">
      <h2>console.table(performance.timing)</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/console/timing.jpg"
        alt="Timing"
        width="554"
        height="1438"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Memory</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/console/memory.jpg"
        alt="Memory"
        width="628"
        height="183"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/console/navigator-connection.jpg"
        alt="Navigator connection"
        width="628"
        height="183"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/dev-tools/console/supported-entry-types.jpg"
        alt="Supported entry types"
        width="928"
        height="379"
      />
    </section>

    <section class="slide">
      <h2>Дорогая Консоль, дай мне список всех ресурсов, блокирующих рендеринг</h2>
      <pre class="place">
        <code class="language-typescript">
          copy(window.performance.getEntriesByType('resource')
            .filter(entry => entry.renderBlockingStatus === 'blocking')
            .map(({name}) => name).join('\n')) $$('*')
            .forEach(el => el.style.outline=`1px solid hsl(${el.tagName.split('').reduce((sum, c)=> sum+=c.charCodeAt(0), 0) % 360 },99%,50%)`)
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">AI&nbsp;assistance panel</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://developer.chrome.com/docs/devtools/ai-assistance?hl=ru"
        >AI assistance</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">React Developer Tools</h2>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
        >React Developer Tools</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Custom Dev Tools</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://github.com/coryhouse/react-switchboard?tab=readme-ov-file"
        >React Switchboard</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Дом света <span class="next">(Lighthouse)</span></h2>
      <img
        class="cover"
        src="./themes/tw/images/shared/tools/lighthouse.svg"
        alt="Lighthouse"
        width="300"
        height="300"
      />
    </section>

    <section class="slide">
      <h2 class="shout">Lighthouse Scoring Calculator</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://googlechrome.github.io/lighthouse/scorecalc/#FCP=6000&SI=1000&FMP=4000&TTI=7300&FCI=6500&LCP=1000&TBT=0&CLS=0&device=mobile&version=10"
        >Lighthouse scoring calculator</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Page Speed</h2>
      <a class="copyright" href="https://pagespeed.web.dev/" target="_blank" rel="noopener noreferrer">PageSpeed</a>
    </section>

    <section class="slide">
      <h2>Benchmarks</h2>
      <a rel="noopener noreferrer" target="_blank" class="https://jsbenchmark.com/">https://jsbenchmark.com/</a>
    </section>

    <section class="slide">
      <h2>Мониторинг производительности</h2>
      <ul>
        <li>
          <a
            rel="noopener noreferrer"
            target="_blank"
            href="https://docs.sentry.io/platforms/javascript/tracing/instrumentation/performance-metrics/"
            >Sentry</a
          >
        </li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://treo.sh/">https://treo.sh/</a>
        </li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://browserbench.org/Speedometer3.0/"
            >https://browserbench.org/Speedometer3.0/</a
          >
        </li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://www.npmjs.com/package/perfume.js"
            >https://www.npmjs.com/package/perfume.js</a
          >
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="shout">Third Party Scripts</h2>
      <img class="next ml-4" src="./themes/tw/pictures/memes/party.jpg" alt="Party" width="56" height="56" />
      <footer>
        <p>
          Причина этому&nbsp;&mdash; в&nbsp;мобильных устройствах срабатывает задержка в&nbsp;несколько сотен
          миллисекунд между касанием экрана и&nbsp;запуском обработчика click. Из-за этого приложение может ощущаться
          медленным. Если вы&nbsp;будете тестировать ваше приложение на&nbsp;предмет работы с&nbsp;касаниями,
          вы&nbsp;не&nbsp;пожертвуете доступностью. Кроме того, существуют библиотеки, которые ускорят разработку.
          Например, Financial Times использует библиотеку Секрет быстрой загрузки требует двух вещей: UPP (ощущаемая
          пользователем скорость)&nbsp;&mdash; это единственное, что имеет значение; эта скорость зависит
          от&nbsp;критического пути рендеринга (Critical Rendering Path). Критический путь - это единственный
          и&nbsp;необходимый код, который должен запускать перечисленные выше события.
        </p>
        <p>Загрузка приложения может быть поделена на&nbsp;три этапа, которые влияют на&nbsp;UPP:</p>
        <p>
          Первая отрисовка. Момент, когда приложение загрузило достаточно данных и&nbsp;ресурсов, чтобы отрисовать
          первый - начальный&nbsp;&mdash; кадр
        </p>
        <p>
          Начало интерактивности&nbsp;&mdash; например, когда пользователю становится доступна возможность нажать
          кнопку, а приложение может ему ответить
        </p>
        <p>
          Если вы&nbsp;ориентируетесь на&nbsp;современные браузеры, вы&nbsp;можете выбрать &quot;ES2018&laquo;или
          &laquo;ES2019&raquo;, что может привести к&nbsp;более эффективному выводу, чем старые версии, такие как
          &laquo;ES5&raquo;.
        </p>
        <p>
          Сердцем движка V8&nbsp;являются Ignition и&nbsp;TurboFan. Ignition&nbsp;&mdash; это компонент, который
          помогает интерпретировать ваш байт-код. Как только движок получает AST, он&nbsp;отправляет это дерево
          в&nbsp;Ignition, который преобразует его в&nbsp;байт-код. Затем этот байт-код интерпретируется
          высокопроизводительным интерпретатором.
        </p>
        <p>
          Ignition имеет быстрое время запуска, а&nbsp;байт-код, который он&nbsp;производит, очень мал, поэтому
          V8&nbsp;использует его для выполнения кода при загрузке страницы. Ignition используется для редкого кода,
          потому что производительность имеет свою цену, а&nbsp;V8&nbsp;не хочет потреблять много памяти.
        </p>
        <p>
          TurboFan&nbsp;&mdash; это оптимизирующий компилятор, который компилирует ваш код в&nbsp;оптимизированный
          машинный язык. Он&nbsp;генерирует чрезвычайно быстрый машинный код. Он&nbsp;делает это с&nbsp;помощью
          предположений (мы&nbsp;вернемся к&nbsp;этому позже). Поскольку TurboFan генерирует оптимизированный машинный
          код, V8&nbsp;использует TurboFan для создания оптимизированной версии часто используемого кода.
        </p>
        <p>
          Полная загрузка&nbsp;&mdash; например, когда все пользовательские альбомы перечислены в&nbsp;музыкальном
          плеере
        </p>
        <p>
          Каждый раз, когда пользователь посещает вашу веб-страницу, он&nbsp;начинает гонку за&nbsp;получение контента
          как можно быстрее. Производительность является критическим фактором , который влияет на&nbsp;то, как
          посетители взаимодействуют с&nbsp;вашим сайтом. Некоторые могут подумать, что перемещение контента
          по&nbsp;всему миру приводит к&nbsp;значительной задержке, но&nbsp;на&nbsp;некоторое время скорость передачи
          данных в&nbsp;сети приблизилась к&nbsp;своим теоретическим пределам . Для сравнения, данные на&nbsp;Cloudflare
          могут преодолеть 11 000-километровое расстояние между Нью-Йорком и&nbsp;Лондоном примерно
          за&nbsp;76&nbsp;миллисекунд&nbsp;&mdash; быстрее, чем моргнуть глазом . Однако задержки в&nbsp;загрузке
          веб-страниц сохраняются из-за сложностей обработки запросов, ответов и&nbsp;конфигураций. В&nbsp;дополнение
          к&nbsp;продвижению достижений в&nbsp;установлении соединения , сжатии , оборудовании и&nbsp;программном
          обеспечении , мы&nbsp;создали новый способ сокращения задержки загрузки страницы, предвидя, как посетители
          будут взаимодействовать с&nbsp;данной веб-страницей.
        </p>
        <p>
          Использование памяти&nbsp;&mdash; это отдельная ключевая метрика. В&nbsp;отличии от&nbsp;отзывчивости
          и&nbsp;частоты кадров, пользователи не&nbsp;могут напрямую почувствовать использование памяти,
          но&nbsp;её&nbsp;использование влияет на&nbsp;&laquo;состояние пользователя&raquo;.
        </p>
        <p>
          Последний показатель, который нужно упомянуть&nbsp;&mdash; это потребление энергии. Подобно использованию
          памяти, пользователь чувствует потребление энергии опосредованно, отмечая время, через которое устройство
          начинает изменять воспринимаемую пользователем производительность (UPP). Для минимизации отрицательных
          эффектов использования энергии, мы&nbsp;должны делать систему экономной.
        </p>
        <p>
          Для примера, вспомните, как работают мобильные устройства: вы&nbsp;можете включить режим энергосбережения,
          когда отключаются другие системы. Но&nbsp;есть и&nbsp;более жёсткий режим, который включается автоматически,
          когда заряд уменьшается до&nbsp;5%&nbsp;&mdash; система включает троттлинг процессора, замедляя выполнение
          всех инструкций.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Unlighthouse</h2>
      <img
        class="cover"
        src="./themes/tw/images/shared/tools/unlighthouse.jpg"
        alt="Unlighthouse"
        width="760"
        height="1440"
      />
      <a class="copyright" href="https://unlighthouse.dev/" target="_blank" rel="noopener noreferrer">Unlighthouse</a>
    </section>

    <section class="slide">
      <h2 class="shout">Web Vitals <span class="next"><- Core Web Vitals</span></h2>
      <a href="https://web.dev/" class="copyright" target="_blank" rel="noopener noreferrer">Web Dev</a>
    </section>

    <section class="slide">
      <h2>Метрики Core Web Vitals</h2>
      <div class="columns two">
        <ul>
          <li class="next">LCP</li>
          <li class="next">CLS</li>
          <li class="next">INP</li>
        </ul>
        <ul>
          <li class="next">TTFB</li>
          <li class="next">SI</li>
          <li class="next">FP</li>
          <li class="next">FCP</li>
          <li class="next"><s>FID</s>&nbsp;TBT</li>
          <li class="next">TTI</li>
        </ul>
      </div>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://www.debugbear.com/test/core-web-vitals"
        >Test core-web-vitals</a
      >
      <footer>
        <p>
          Длительная задача&nbsp;&mdash; это задача, выполнение которой занимает более 50&nbsp;мс. Это непрерывный
          период, когда основной поток пользовательского интерфейса занят в&nbsp;течение 50&nbsp;мс или дольше. Обычные
          примеры включают долго работающие обработчики событий, дорогие перекомпоновки и&nbsp;другие повторные рендеры,
          а&nbsp;также работу браузера между различными поворотами цикла событий, которая превышает 50&nbsp;мс.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Влияние Core Web Vitals</h2>
      <ul>
        <li class="next">
          <a rel="noopener noreferrer" target="_blank" href="https://aliexpress.ru/">AliExpress</a>
          улучшил CLS в&nbsp;10&nbsp;раз, а&nbsp;LCP в&nbsp;2&nbsp;раза, что привело к&nbsp;снижению показателя отказов
          на&nbsp;15%
        </li>
        <li class="next">
          <a rel="noopener noreferrer" target="_blank" href="https://onlineconvertfree.com/">Onlineconvertfree</a>
          улучшив CLS, LCP, INP
        </li>
        <li class="next">
          <a rel="noopener noreferrer" target="_blank" href="">2pdf</a>
        </li>
      </ul>
      <a href="https://web.dev/vitals-business-impact/" class="copyright" target="_blank" rel="noopener noreferrer"
        >The business impact of&nbsp;Core Web Vitals</a
      >
    </section>

    <section class="slide">
      <h2>Node.js</h2>
      <ul>
        <li>node &mdash;inspect-brk</li>
        <li>chrome://inspect</li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://perf.link">perf.link</a>
        </li>
        <li>https://npmgraph.js.org/</li>
        <li>eslint-plugin-depend https://github.com/es-tooling/eslint-plugin-depend</li>
        <li>https://github.com/thepassle/eslint-plugin-barrel-files</li>
      </ul>
    </section>

    <section class="slide">
      <h2>Влияние</h2>
      <ul>
        <li class="next">
          Для
          <a
            href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales"
            target="_blank"
            rel="noopener noreferrer"
            >Amazon</a
          >
          каждые 100мс задержки обходятся в&nbsp;1% продаж.
        </li>
        <li class="next">
          <a href="https://www.walmart.com/" target="_blank" rel="noopener noreferrer"
            >walmart: 1&nbsp;секунда ускорения + 2%&nbsp;конверсии от&nbsp;400 млрд</a
          >
        </li>
        <li class="next">
          AliExpress сократил время загрузки на&nbsp;36%, увеличил количество заказов на&nbsp;10,5% и&nbsp;увеличил
          конверсию для новых клиентов на&nbsp;27%.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="cover left-0 mt-[24px] -translate-y-[50%] pl-[120px] text-left">
        <span class="text-gray">Акт 2</span>
        <br />
        <span>Возможности</span>
      </h2>
    </section>

    <section class="slide">
      <h2>Как анализировать бандл?</h2>
      <ul>
        <li>https://github.com/statoscope/statoscope</li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <p>
        API кооперативного планирования фоновых задач (также называемый API фоновых задач или requestIdleCallback()API)
        предоставляет возможность ставить задачи в&nbsp;очередь для автоматического выполнения агентом пользователя,
        когда он&nbsp;определяет, что для этого есть свободное время.
      </p>
    </section>

    <section class="slide">
      <h2 class="sr-only">O notation</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/o-notation.jpg"
        alt="O notation"
        width="1280"
        height="1008"
      />
    </section>

    <section class="slide">
      <h2 class="shout">
        Техники оптимизации
        <span class="next text-gray">the status quo</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">Сжатие размера изображений<span class="next text-gray">, без потери качества</span></h2>
    </section>

    <section class="slide">
      <h2 class="shout">
        Оптимизация шрифтов<span class="next text-gray">, где можно использовать только нужные символы</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Stats</h2>
      <img src="./themes/tw/images/possibilities/stats.jpg" width="1195" height="1181" alt="" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Project</h2>
      <img src="./themes/tw/images/possibilities/project.jpg" width="1221" height="658" alt="" />
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img src="./themes/tw/images/possibilities/techniques/lazy-load.gif" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img src="./themes/tw/images/shared/tools/biome.svg" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img src="./themes/tw/images/shared/tools/browserstack.svg" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Фичи</h2>
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://webstatus.dev/"
        >https://webstatus.dev/</a
      >
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img src="./themes/tw/images/shared/tools/oxc.svg" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img
        src="./themes/tw/images/possibilities/techniques/remove-unused-code.jpg"
        width="2000"
        height="860"
        alt="Lazy load"
      />
    </section>

    <section class="slide">
      <h2>Tree shaking</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/possibilities/techniques/tree-shaking.jpg"
        width="686"
        height="895"
        alt="Tree shaking"
      />
    </section>

    <section class="slide">
      <h2>Code splitting</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/possibilities/techniques/code-splitting.jpg"
        width="600"
        height="967"
        alt="Code splitting"
      />
      <a rel="noopener noreferrer" target="_blank" class="copyright">https://www.npmjs.com/package/size-limit</a>
    </section>

    <section class="slide">
      <h2>🤝 Объединение</h2>
      <footer>
        <p>
          В мире HTTP/1.1 мы могли извлекать только шесть ресурсов из заданного источника одновременно. Учитывая это
          ограничение, было выгодно иметь меньше файлов: если нам нужно было загрузить 18 файлов, это три отдельных
          фрагмента работы; если мы могли каким-то образом сократить это число до шести, это был бы только один
          отдельный фрагмент работы. Это привело к тяжелому объединению и конкатенации — зачем загружать три CSS-файла
          (половина нашего бюджета), если мы могли бы сжать их в один?
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>content-visibility</h2>
    </section>

    <section class="slide">
      <h2>
        <a rel="noopener noreferrer" target="_blank" href="https://github.com/sharkdp/hyperfine">hyperfine</a>
      </h2>
    </section>

    <section class="slide">
      <a rel="noopener noreferrer" target="_blank" href="https://biomejs.dev/">Biome</a>
    </section>

    <section class="slide">
      <h2>🗜️ Minify code</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/possibilities/techniques/minified.jpg"
        width="1857"
        height="841"
        alt="Minified"
      />
      <footer>
        <p>Пользователям - производительность</p>
        <p>поисковым системам - seo ranking</p>
        <p>бизнесу - конверсия</p>
        <p>
          Отсюда и&nbsp;взрыв разработки новых инструментов, которые являются, по&nbsp;большому счёту, упрощённой
          заменой существующих: Rolldown для Rollup, Oxlint для ESLint, Biome для Prettier и&nbsp;так далее. Однако
          работают эти инструменты быстрее не&nbsp;обязательно из-за того, что написаны на&nbsp;более быстром языке.
          Их&nbsp;скорость может объясняться тем, что: 1) их&nbsp;пишут с&nbsp;упором на&nbsp;производительность
          и&nbsp;2) поверхность API уже налажена, поэтому авторам не&nbsp;нужно тратить время на&nbsp;проработку общего
          дизайна. Чёрт возьми, да&nbsp;вам даже не&nbsp;требуется писать тесты! Просто используйте существующий набор
          от&nbsp;предыдущего инструмента.
        </p>
        <p>
          За&nbsp;свою карьеру я&nbsp;часто видел, как в&nbsp;случаях, когда переписывание&nbsp;А в&nbsp;B приводит
          к&nbsp;повышению скорости, автор этого ремейка заявляет, что&nbsp;B быстрее А.&nbsp;Тем не&nbsp;менее, как
          отметил Райан Карниато, ремейк зачастую быстрее, просто потому что это ремейк&nbsp;&mdash; при переписывании
          чего-то вы&nbsp;знаете больше, больше внимания уделяете производительности и&nbsp;так далее.
        </p>
        <p>
          Когда дело доходит до&nbsp;производительности веб-сайта, вы&nbsp;можете подумать о&nbsp;таких методах, как
          сжатие, оптимизация ресурсов или даже кэширование HTTP. Они действительно важны, и&nbsp;существует множество
          существующих ресурсов, охватывающих способы их&nbsp;исправления или внедрения. Однако некоторые менее
          обсуждаемые узкие места производительности могут серьезно повлиять на&nbsp;скорость веб-сайта. В&nbsp;этой
          статье мы&nbsp;обсудим три проблемы, которые часто возникают из-за неэффективных шаблонов JavaScript:
        </p>
        <p>
          Длительные задачи&nbsp;&mdash; операции JavaScript, которые монополизируют основной поток, что приводит
          к&nbsp;неотзывчивости пользовательских интерфейсов
        </p>
        <p>
          Большие размеры пакетов&nbsp;&mdash; код JavaScript слишком велик для быстрой загрузки, анализа
          и&nbsp;выполнения
        </p>
        <p>
          Проблемы гидратации&nbsp;&mdash; процесс присоединения функциональности JavaScript к&nbsp;HTML, отображаемому
          сервером
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Pre (предварительный)</h2>
      <ul>
        <li><span>Pre</span>fetching</li>
        <li><span>Pre</span>rendering</li>
        <li><span>Pre</span>caching</li>
      </ul>
      <a rel="noopener noreferrer" target="_blank" class="copyright"
        >https://web.dev/learn/performance/prefetching-prerendering-precaching</a
      >
    </section>

    <section class="slide">
      <h2>Удалить неиспользуемый код</h2>
      <img
        class="cover"
        src="./themes/tw/images/possibilities/web-almanac/unused-js.jpg"
        alt="Unused js"
        width="1200"
        height="742"
      />
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://almanac.httparchive.org/ru/2022/"
        >httparchive</a
      >
    </section>

    <section class="slide">
      <ul>
        <li>
          <a
            rel="noopener noreferrer"
            target="_blank"
            href="https://www.npmjs.com/package/@cerner/duplicate-package-checker-webpack-plugin"
          >
            duplicate-package-checker-webpack-plugin
          </a>
        </li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://www.npmjs.com/package/dependency-cruiser">
            dependency-cruiser
          </a>
        </li>
        <li>
          <a rel="noopener noreferrer" target="_blank" href="https://www.npmjs.com/package/depcheck">depcheck</a>
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="shout">🗳️ Кэширование</h2>
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://v8.dev/blog/code-caching-for-devs"
        >Code caching for devs</a
      >
      <footer>
        <p>
          Вторая категория отрывов в&nbsp;производительности связана с&nbsp;теми возможностями, которые браузеры
          предоставляют нам бесплатно, и&nbsp;тем, что мы&nbsp;редко думаем о&nbsp;кэшировании байткода
          и&nbsp;JIT-компиляции.
        </p>
        <p>
          Если при загрузке сайта второй или третий раз JS-код правильно кэширован, то&nbsp;браузеру не&nbsp;приходится
          больше парсить и&nbsp;компилировать исходный код в&nbsp;байткод. В&nbsp;таком случае он&nbsp;просто загружает
          последний напрямую с&nbsp;диска &mdash;&nbsp;это называется кэшированием байткода. Более того, если функция
          &laquo;горячая&raquo; (часто выполняется), то&nbsp;она дополнительно оптимизируется в&nbsp;машинный код. Так
          работает JIT-компиляция.
        </p>
        <p>
          Тем не&nbsp;менее, благодаря непревзойдённому Джойи Чунгу, в&nbsp;Node появилась функциональность
          &laquo;compile cache&raquo;. Теперь вы&nbsp;можете настроить переменную среды и&nbsp;сразу получить ускорение
          загрузки скриптов Node.js: export NODE_COMPILE_CACHE=~/.cache/nodejs-compile-cache
        </p>
        <p>https://github.com/nodejs/node/pull/52535</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Parallel DOM</h2>
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://github.com/pdomdev/pdom"
        >https://github.com/pdomdev/pdom</a
      >
    </section>

    <section class="slide">
      <h2>Доставка современного кода (tl;dr)</h2>
      <p class="next"><samp>modern.js</samp> и <samp>old.bundle.js</samp></p>
      <pre class="next">
        <code class="language-typescript">
          &lt;script type="module" src="modern.js"&gt;&lt;/script&gt;
          &lt;script no module src="old.bundle.js" defer&gt;&lt;/script&gt;
        </code>
      </pre>
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://www.npmjs.com/package/size-limit"
        >size limit</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Barrel imports</h2>
      <pre class="place">
        <code class="language-typescript">
          // feature/index.js
          export * from "./user";
          export * from "./permissions";
          export * from "./actions";
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Подключить CDN</h2>
      <div>
        <img
          class="m-auto"
          src="./themes/tw/images/possibilities/technologies/cdn.jpg"
          width="312"
          height="512"
          alt="CDN"
        />
      </div>
    </section>

    <section class="slide">
      <h2>Что если проблема в стороннем пакете?</h2>
      <img
        class="next"
        src="./themes/tw/images/shared/tools/patch-package.svg"
        width="200"
        height="200"
        alt="Patch package"
      />
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://www.npmjs.com/package/patch-package"
        >https://www.npmjs.com/package/patch-package</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Этого бывает мало...</h2>
    </section>

    <section class="slide">
      <h2 class="cover !left-0 mt-[24px] -translate-y-[50%] pl-[100px] text-left">
        <span class="text-gray">Акт 3</span> <br />
        <span>Набор практик / советов</span>
      </h2>
    </section>

    <section class="slide">
      <img class="next" src="./themes/tw/images/shared/languages/js.svg" width="200" height="200" alt="Patch package" />
      <img class="next" src="./themes/tw/images/shared/languages/ts.svg" width="200" height="200" alt="Patch package" />
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <img
        class="next absolute translate-x-[50%] translate-y-[100%]"
        src="./themes/tw/images/shared/tools/vite.svg"
        alt="Vite"
        width="132"
        height="32"
      />
      <img
        class="next absolute translate-x-[200%] translate-y-[50%]"
        src="./themes/tw/images/shared/tools/rollup.svg"
        alt="Rollup"
        width="126"
        height="16"
      />
      <img
        class="next absolute translate-x-[300%] translate-y-[10%]"
        src="./themes/tw/images/shared/tools/rolldown.svg"
        alt="Rolldown"
        width="200"
        height="300"
      />
      <img
        class="next absolute translate-x-[20%] translate-y-[300%]"
        src="./themes/tw/images/shared/tools/rsbuild.svg"
        alt="Rsbuild"
        width="116"
        height="16"
      />
      <img
        class="next absolute translate-x-[40%] translate-y-[90%]"
        src="./themes/tw/images/shared/tools/webpack.svg"
        alt="Webpack"
        width="116"
        height="16"
      />
      <img
        class="next absolute translate-x-[100%] translate-y-[100%]"
        src="./themes/tw/images/shared/tools/brunch.svg"
        alt="Brunch"
        width="256"
        height="256"
      />
      <img
        class="next absolute translate-x-[100%] translate-y-[100%]"
        src="./themes/tw/images/shared/tools/farm.png"
        alt="Brunch"
        width="256"
        height="256"
      />
    </section>

    <section class="slide">
      <img src="./themes/tw/images/tips/bundle.jpg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Node vs Bun</h2>
      <img
        class="cover"
        src="./themes/tw/images/shared/tools/node-vs-bun.jpg"
        alt="Node vs bun"
        width="580"
        height="720"
      />
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>The Release Radar</h2>
        📡
      </div>
    </section>

    <section class="slide">
      <video
        autoplay
        muted
        disablepictureinpicture
        preload="metadata"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        width="500"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/possibilities/yandex-tecnhologies.webm" type="video/mp4" />
      </video>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://yandex.ru/company/researches/2023/frontenders"
        >Researches frontenders</a
      >
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <iframe
        class="absolute left-1/2 top-1/2 my-2 -translate-x-1/2 -translate-y-1/2 rounded-sm"
        title="Vanilla js"
        width="700"
        height="700"
        id="iframe-vanilla-js"
      ></iframe>
      <div class="absolute left-1/2 top-1/2 my-2 -translate-x-1/2 -translate-y-1/2">
        <button
          class="upload-btn-iframe relative box-border flex h-[60px] w-[169px] cursor-pointer items-center overflow-hidden rounded-sm border-[3px] border-solid border-white bg-black px-[15px] py-0 text-white no-underline shadow-[6px_6px_0_#00a4ef] transition-all duration-[0.1s] ease-[ease-out] before:rounded-sm"
          type="button"
          id="upload-iframe"
        >
          <span>
            <span>Нажми на&nbsp;меня</span>
          </span>
        </button>
      </div>
      <script>
        document.addEventListener("DOMContentLoaded", function () {
          const uploadIframe = document.querySelector("#upload-iframe");
          const iframeVanillaJs = document.querySelector("#iframe-vanilla-js");

          uploadIframe.addEventListener("click", function () {
            iframeVanillaJs.src = "http://vanilla-js.com";
            iframeVanillaJs.classList.add("z-10");
          });
        });
      </script>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/everywhere.jpg" alt="Everywhere" width="880" height="1188" />
    </section>

    <section class="slide relative">
      <h2 class="shout">Java Script <span class="next">(клин клином)</span></h2>
      <p
        class="next absolute translate-x-[200px] translate-y-[80px] rotate-[30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;React!
      </p>
      <p
        class="next absolute translate-x-[100px] translate-y-[400px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Vue!
      </p>
      <p
        class="next absolute translate-x-[400px] translate-y-[400px] rotate-[30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Angular!
      </p>
      <p
        class="next absolute translate-x-[500px] translate-y-[100px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Solid!
      </p>

      <p
        class="next absolute translate-x-[700px] translate-y-[270px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        А&nbsp;я на&nbsp;jQuery!
        <img src="./themes/tw/images/shared/tools/jquery-book.jpg" alt="JQuery Book" width="147" height="705" />
      </p>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const startTime = Date.now();

          doTask();

          console.log(`Длительность выполнения: ${Date.now() - startTime} ms`);
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          console.profile();

          doTask();

          console.profileEnd();
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Создание метки
          performance.mark('task-start');

          // Выполнение функции
          doTask();

          // Завершение метки
          performance.mark('task-end');

          // Создание измерения
          performance.measure('task', 'task-start', 'task-end');

          // Получение результатов
          const [firstItem, ...rest] = performance.getEntriesByName('task');

          console.log(firstItem.duration);
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          import { performance } from "node:perf_hooks";

          console.log(performance.now());
        </code>
      </pre>
      <a class="copyright" href="https://nodejs.org/api/perf_hooks.html" target="_blank" rel="noopener noreferrer"
        >perf_hooks</a
      >
    </section>

    <section class="slide">
      <h2 class="shout"><span>===</span> <br />Сравнение строк</h2>
      <footer>
        <p>
          Javascript позволяет легко скрыть реальную стоимость сравнения строк. Если вам нужно сравнить строки в&nbsp;C,
          вы&nbsp;бы использовали функцию strcmp(a, b). Javascript использует ===вместо этого , поэтому
          вы&nbsp;не&nbsp;видите strcmp. Но&nbsp;он&nbsp;есть, и&nbsp;сравнение строк обычно (но&nbsp;не&nbsp;всегда)
          требует сравнения каждого символа в&nbsp;строке с&nbsp;символами в&nbsp;другой строке; сравнение
          строк&nbsp;&mdash; это O(n). Один из&nbsp;распространенных шаблонов JavaScript, которого следует
          избегать,&nbsp;&mdash; это строки как перечисления. Но&nbsp;с&nbsp;появлением TypeScript этого должно быть
          легко избежать, поскольку перечисления по&nbsp;умолчанию являются целыми числами.
        </p>
        <p>
          Как видите, разница может быть существенной. Разница не&nbsp;обязательно связана со&nbsp;strcmp стоимостью,
          поскольку движки иногда могут использовать пул строк и&nbsp;сравнивать по&nbsp;ссылке, но&nbsp;она также
          связана с&nbsp;тем, что целые числа обычно передаются по&nbsp;значению в&nbsp;движках&nbsp;JS, тогда как
          строки всегда передаются как указатели, а&nbsp;доступ к&nbsp;памяти является дорогостоящим (см. раздел 5).
          В&nbsp;коде с&nbsp;большим количеством строк это может иметь огромное влияние. В&nbsp;качестве примера
          из&nbsp;реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в&nbsp;2&nbsp;раза быстрее
          *, просто заменив строковые константы числами. *К&nbsp;сожалению, он&nbsp;не&nbsp;был объединен, но&nbsp;таков
          принцип работы с&nbsp;открытым исходным кодом.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
        <code class="language-typescript">
          // #1
          enum Position {
            TOP    = 'TOP',
            BOTTOM = 'BOTTOM',
          }

          // #2
          enum Position {
            TOP,    // = 0
            BOTTOM, // = 1
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
        <code class="language-typescript">
          let _ = 0;

          for (let i = 0; i < 1000000; i++) {
            let current = i % 2 === 0 ? Position.TOP : Position.BOTTOM;

            if (current === Position.TOP) {
              _ += 1;
            }
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place flex w-[50%] flex-col gap-4">
        <custom-scale name="string" percentage="50"></custom-scale>
        <custom-scale name="int" percentage="95" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">
        <span>△ ▢</span> <br />
        Избегайте разных форм
      </h2>
      <footer>
        <p>
          Движки Javascript пытаются оптимизировать код, предполагая, что объекты имеют определенную форму, и&nbsp;что
          функции будут получать объекты той&nbsp;же формы. Это позволяет им&nbsp;хранить ключи формы один раз для всех
          объектов этой формы, а&nbsp;значения&nbsp;&mdash; в&nbsp;отдельном плоском массиве. Чтобы представить это
          в&nbsp;javascript:
        </p>
        <p>
          Я&nbsp;использовал слово &laquo;форма&raquo; для описания этой концепции, но&nbsp;имейте в&nbsp;виду, что
          вы&nbsp;также можете встретить термины &laquo;скрытый класс&raquo; или &laquo;карта&raquo; для
          ее&nbsp;описания, в&nbsp;зависимости от&nbsp;движка.
        </p>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
        <p>
          Движки обычно могут кодировать целые числа как значения. Например, V8&nbsp;представляет значения
          в&nbsp;32&nbsp;битах, причем целые числа представляют собой компактные значения Smi (SMall Integer),
          но&nbsp;числа с&nbsp;плавающей точкой и&nbsp;большие целые числа передаются как указатели, как строки
          и&nbsp;объекты. JSC использует 64-битное кодирование, двойное тестирование , чтобы передавать все числа
          по&nbsp;значению, как это делает SpiderMonkey, а&nbsp;остальное передается как указатели.
        </p>
        <p>https://github.com/facebook/react/pull/28569</p>
        <p>
          Что, черт возьми, мне с&nbsp;этим делать? Легче сказать, чем сделать, но: создайте все свои объекты
          с&nbsp;одинаковой формой . Даже что-то столь тривиальное, как написание свойств компонента React в&nbsp;другом
          порядке, может вызвать это . Например, вот простые случаи, которые я&nbsp;нашел в&nbsp;кодовой базе React,
          но&nbsp;у&nbsp;них уже был случай с&nbsp;гораздо более сильным влиянием той&nbsp;же проблемы несколько лет
          назад, потому что они инициализировали объект целым числом, а&nbsp;затем сохраняли число с&nbsp;плавающей
          точкой. Да, изменение типа также меняет форму. Да, есть целые и&nbsp;плавающие типы, скрытые за&nbsp;number.
          Разберитесь с&nbsp;этим.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Код</h2>
      <pre class="place">
        <code class="language-typescript">
          // Вводные
          const objects = [
            {
              name: 'Анатолий',
              age: 36,
            },
            {
              name: 'Иннокентий',
              age: 42
            },
          ];
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Код</h2>
      <pre class="place">
        <code class="language-typescript">
            const shape = [
              { name: 'name', type: 'string' },
              { name: 'age',  type: 'integer' },
            ];

            const objects = [
              ['Анатолий', 36],
              ['Иннокентий', 42],
            ];
        </code>
      </pre>
      <footer>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          function add(a, b) {
            return {
              name: a.name + b.name,
              type: a.type + b.type
            }
          }
        </code>
      </pre>
      <footer>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Вводные
          let _ = 0;

          // Monomorphic
          const data1 = { a: 1, b: _, c: _, d: _ };
          const data2 = { a: 1, b: _, c: _, d: _ };
          const data3 = { a: 1, b: _, c: _, d: _ };

          // Polymorphic
          const data1 = { a: 1, b: _, c: _, d: _ };
          const data2 = { a: 1, b: _, c: _, d: _ };
          const data3 = { a: _, b: 1, c: _, d: _ };

          // Megamorphic
          const data1 = { a: 1, b: _, c: _, d: _ };
          const data2 = { b: _, a: 1, c: _, d: _ };
          const data3 = { b: _, c: _, a: 1, d: _ };
        </code>
      </pre>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html"
        >Мономорфизм</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          function add(a, b) {
            return a.a + a.b + a.c + a.d +
                   b.a + b.b + b.c + b.d;
          }

          let result = 0;

          for (let i = 0; i < 1000000; i++) {
            result += add(data1, data2);
            result += add(data3, data4);
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="megamorphic" percentage="4"></custom-scale>
        <custom-scale name="polymorphic" percentage="13"></custom-scale>
        <custom-scale name="monomorphism" percentage="95" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          for (let i = 0; i < 1000; ++i) {
            // fast 🚀
          }

          for (let i = 0.1; i < 1000.1; ++i) {
            // slow 🐌
          }

          https://v8.dev/blog/react-cliff
        </code>
      </pre>
      <footer>
        <p>
          32-битное представление дополнения до двух полезно не только для операций с массивами. В целом, процессоры
          выполняют целочисленные операции намного быстрее, чем операции с плавающей точкой . Вот почему в следующем
          примере первый цикл легко в два раза быстрее по сравнению со вторым циклом.
        </p>
        <p>
          Если оба операнда представлены как целые числа, процессор может вычислить результат очень эффективно. V8 имеет
          дополнительные быстрые пути для случаев, когда divisorявляется степенью двойки. Для значений, представленных
          как числа с плавающей точкой, вычисления намного сложнее и занимают гораздо больше времени
        </p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex flex-col items-center">
        <h2>
          <span>[...] {...}</span> <br />
          Избегайте методов<br />массивов/объектов
        </h2>
      </div>
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <img
        class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%]"
        src="./themes/tw/images/tips/skills-team/1.jpg"
        alt="Skills team 1"
        width="392"
        height="137"
      />
      <img
        class="next translate-x-[450px] translate-y-[150px] rotate-[30deg]"
        src="./themes/tw/images/tips/skills-team/2.jpg"
        alt="Skills team 2"
        width="356"
        height="123"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Вводные
          const numbers = Array.from({ length: 10_000 }).map(() => Math.random());

          // 1. Декларативный подход
          const result =
            numbers.map(n => Math.round(n * 10))
                   .filter(n => n % 2 === 0)
                   .reduce((a, n) => a + n, 0);

          // 2. Императивный подход
          let result = 0;

          for (let i = 0; i < numbers.length; i++) {
            let n = Math.round(numbers[i] * 10);
            if (n % 2 !== 0) continue;

            result = result + n;
          }
        </code>
      </pre>
      <footer>
        <p>
          Я&nbsp;люблю функциональное программирование так&nbsp;же, как и&nbsp;все остальные, но&nbsp;если
          вы&nbsp;не&nbsp;работаете с&nbsp;Haskell/OCaml/Rust, где функциональный код компилируется в&nbsp;эффективный
          машинный код, то&nbsp;функциональное программирование всегда будет медленнее императивного.
        </p>
        <p>Проблема с&nbsp;этими методами заключается в&nbsp;следующем:</p>
        <p>
          Им&nbsp;нужно сделать полную копию массива, и&nbsp;эти копии позже должны быть освобождены сборщиком мусора.
          Мы&nbsp;более подробно рассмотрим вопросы ввода-вывода памяти в&nbsp;разделе 5.
        </p>
        <p>
          Они выполняют цикл&nbsp;N раз для&nbsp;N операций, тогда как for цикл допускает выполнение цикла один раз.
        </p>
        <p>
          Методы объектов, такие как Object.values(), Object.keys()и Object.entries()страдают от&nbsp;похожих проблем,
          так как они также выделяют больше данных, а&nbsp;доступ к&nbsp;памяти является корнем всех проблем
          с&nbsp;производительностью. Нет, правда, я&nbsp;клянусь, я&nbsp;покажу вам в&nbsp;разделе 5.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="функциональный" percentage="36"></custom-scale>
        <custom-scale name="императивный" percentage="97" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Используйте строки<span class="next text-gray">, осторожно</span></h2>
      <footer>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST (https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)&nbsp;&mdash; так,
          чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном уровне по&nbsp;мере его роста
          и&nbsp;выполнять такие операции, как поиск, как можно быстрее.
        </p>
        <p>
          Строковые операции являются основной частью JavaScript из-за его контекста. Чтобы оптимизировать код,
          насыщенный строками, движки должны были быть креативными. Под этим я&nbsp;подразумеваю, что они должны были
          представлять String объект с&nbsp;помощью множественного строкового представления в&nbsp;C++,
          в&nbsp;зависимости от&nbsp;варианта использования. Есть два общих случая, о&nbsp;которых вам следует
          беспокоиться, поскольку они справедливы для&nbsp;V8 (наиболее распространенного движка на&nbsp;сегодняшний
          день), а&nbsp;также, как правило, и&nbsp;для других движков.
        </p>
        <p>
          Но&nbsp;вот в&nbsp;чем проблема: как только вам нужно начать мутировать эти байты, в&nbsp;этот момент
          вы&nbsp;начинаете платить за&nbsp;копирование. Допустим, мы&nbsp;возвращаемся к&nbsp;нашему String классу
          и&nbsp;пытаемся добавить .trimEnd метод:
        </p>
        <p>
          В&nbsp;общем, старайтесь избегать мутаций как можно дольше.trim() . Это включает такие методы , как
          .replace(), и&nbsp;т.&nbsp;д. Подумайте, как можно избежать этих методов. В&nbsp;некоторых движках шаблоны
          строк также могут быть медленнее, чем +. В&nbsp;V8&nbsp;на данный момент это так, но&nbsp;может не&nbsp;быть
          в&nbsp;будущем, поэтому, как всегда, бенчмарк.
        </p>
        <p>
          Примечание SlicedString выше: следует отметить, что если в&nbsp;памяти находится небольшая подстрока очень
          большой строки,это может бытьне позволяйте сборщику мусора собирать большую строку! Если вы&nbsp;обрабатываете
          большие тексты и&nbsp;извлекаете из&nbsp;них маленькие строки, вы&nbsp;можете допустить утечку большого объема
          памяти.
        </p>
        <p>
          Решение здесь&nbsp;&mdash; использовать методы мутации в&nbsp;наших интересах. Если мы&nbsp;используем один
          из&nbsp;них на&nbsp;small, это приведет к&nbsp;принудительному копированию, и&nbsp;старый указатель
          на&nbsp;largeбудет потерян:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const classNames = ['primary', 'selected', 'active', 'medium'];

          // 1. Мутация
          const result =
            classNames
              .map(c => `button--${c}`)
              .join(' ');

          // 2. concatenation
          const result =
            classNames
              .map(c => 'button--' + c)
              .reduce((acc, c) => acc + ' ' + c, '');
        </code>
      </pre>
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const large = Array.from({ length: 10_000 }).map(() => 'string').join('');
          const small = large.slice(0, 50);
        </code>
      </pre>
      <img
        class="next absolute translate-x-[90px] translate-y-[290px]"
        src="./themes/tw/pictures/arrow.svg"
        alt=""
        width=""
        height=""
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // replace a token that doesn't exist
          const small = small.replace('#'.repeat(small.length + 1), '')
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="mutation" percentage="37"></custom-scale>
        <custom-scale name="concatenation" percentage="98" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="!m-0">Используйте eval</h2>
        <picture class="ml-2">
          <source srcset="./themes/tw/pictures/emoji/evil.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/evil.gif" alt="😈" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>
          Некоторые шаблоны javascript трудно оптимизировать для движков, и&nbsp;с&nbsp;помощью использования eval() или
          его производных вы&nbsp;можете заставить эти шаблоны исчезнуть. В&nbsp;этом примере мы&nbsp;можем наблюдать,
          как использование eval()позволяет избежать затрат на&nbsp;создание объекта с&nbsp;динамическим ключом объекта:
        </p>
        <p>
          Другим хорошим вариантом использования eval может быть компиляция функции предиката фильтра, где вы
          отбрасываете ветви, которые, как вы&nbsp;знаете, никогда не&nbsp;будут выполнены. В&nbsp;общем, любая функция,
          которая будет запущена в&nbsp;очень горячем цикле, является хорошим кандидатом для такого рода оптимизации.
        </p>
        <p>
          Очевидно, что обычные предупреждения eval()применимы: не&nbsp;доверяйте пользовательскому вводу, очищайте все,
          что передается в&nbsp;eval()&rsquo;d-код, и&nbsp;не&nbsp;создавайте никаких возможностей XSS. Также обратите
          внимание, что некоторые среды не&nbsp;разрешают доступ к&nbsp;eval(), например, страницы браузера с&nbsp;CSP.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // С&nbsp;eval
          const key = "requestId";
          const values = Array.from({ length: 100_000 }).fill(42);

          function createMessages(key, values) {
            const messages = []
            for (let i = 0; i < values.length; i++) {
              messages.push({ [key]: values[i] })
            }
            return messages
          }

          createMessages(key, values);
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Без eval
          const key = "requestId";
          const values = Array.from({ length: 100_000 }).fill(42)

          function createMessages(key, values) {
            const messages = [];
            const createMessage = new Function('value',
              `return { ${JSON.stringify(key)}: value }`
            )
            for (let i = 0; i < values.length; i++) {
              messages.push(createMessage(values[i]))
            }
            return messages
          }

          createMessages(key, values)
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div class="place w-[50%]">
        <custom-scale name="С eval" percentage="53"></custom-scale>
        <custom-scale name="not eval" percentage="90" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Косвенность</h2>
      <footer>
        <p>
          Еще одним местом, где можно искать выгоды от&nbsp;оптимизации, является любой источник косвенности,
          из&nbsp;которых я&nbsp;вижу 3&nbsp;основных источника:
        </p>
        <p>
          Тест proxy на&nbsp;V8&nbsp;сейчас особенно жесток. В&nbsp;последний раз, когда я&nbsp;проверял, объекты proxy
          всегда откатывались от&nbsp;JIT к&nbsp;интерпретатору, судя по&nbsp;этим результатам, это все еще может быть
          так.
        </p>
        <p>
          Я&nbsp;также хотел продемонстрировать доступ к&nbsp;глубоко вложенному объекту по&nbsp;сравнению с&nbsp;прямым
          доступом, но&nbsp;движки очень хорошо оптимизируют доступ к&nbsp;удаленным объектам с&nbsp;помощью анализа
          выхода, когда есть горячий цикл и&nbsp;постоянный объект. Я&nbsp;вставил немного косвенности, чтобы
          предотвратить это
        </p>
        <a
          target="_blank"
          rel="noopener noreferrer"
          href="https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be"
          >https://www.youtube.com/watch?t=1055&amp;v=KiWEWLwQ3oI&amp;feature=youtu.be</a
        >
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const point = new Proxy({ x: 10, y: 20 }, { get: (t, k) => t[k] });

          for (let _ = 0, i = 0; i < 100_000; i++) {
            _ += point.x;
          };
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const point = { x: 10, y: 20 };
          const x = point.x;

          for (let _ = 0, i = 0; i < 100_000; i++) {
            _ += x;
          };
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div class="place w-[50%]">
        <custom-scale name="proxy" percentage="2"></custom-scale>
        <custom-scale name="direct" percentage="94" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/cooper.jpg" alt="Купер" width="968" height="544" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const a = { state: { center: { point: { x: 10, y: 20 } } } }
          const b = { state: { center: { point: { x: 10, y: 20 } } } }
          const get = (i) => i % 2 ? a : b

          let result = 0
          for (let i = 0; i < 100_000; i++) {
            result = result + get(i).state.center.point.x }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // 2. direct access
          const a = { x: 10, y: 20 }.x
          const b = { x: 10, y: 20 }.x
          const get = (i) => i % 2 ? a : b

          let result = 0
          for (let i = 0; i < 100_000; i++) {
            result = result + get(i) }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="nested" percentage="42"></custom-scale>
        <custom-scale name="direct" percentage="92" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">
        Специализация
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f422/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f422/512.gif" alt="🐢" width="32" height="32" />
        </picture>
      </h2>
      <footer>
        <p>
          Одной из&nbsp;важных концепций оптимизации производительности является специализация : адаптация вашей логики
          для соответствия ограничениям вашего конкретного варианта использования. Обычно это означает выяснение того,
          какие условия, скорее всего, будут верны для вашего случая, и&nbsp;кодирование для этих условий. Допустим,
          мы&nbsp;торговец, которому иногда нужно добавлять теги в&nbsp;список продуктов. Мы&nbsp;знаем по&nbsp;опыту,
          что наши теги обычно пустые. Зная эту информацию, мы&nbsp;можем специализировать нашу функцию для этого случая
        </p>
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f4af/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f4af/512.gif" alt="💯" width="32" height="32" />
        </picture>
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f525/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f525/512.gif" alt="🔥" width="32" height="32" />
        </picture>
      </footer>
    </section>

    <section class="slide">
      <h2>задержка на мобильных</h2>
      <picture>
        <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1fae3/512.webp" type="image/webp" />
        <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1fae3/512.gif" alt="🫣" width="32" height="32" />
      </picture>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // 1. not specialized
          for (let i = 0; i < 100; i++) {
            productsToString(descriptions, someTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // 2. specialized
          for (let i = 0; i < 100; i++) {
            productsToStringSpecialized(descriptions, someTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          const descriptions = ['apples', 'oranges', 'bananas', 'seven']
          const someTags = {
            apples: '::promotion::',
          }
          const noTags = {}

          function productsToString(description, tags) {
            let result = '';

            description.forEach(product => {
              result += product
              if (tags[product]) result += tags[product]
              result += ', '
            });

            return result;
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Specialize it now
          function productsToStringSpecialized(description, tags) {
            // We know that `tags` is likely to be empty, so we check
            // once ahead of time, and then we can remove the `if` check
            // from the inner loop
            if (isEmpty(tags)) {
              let result = ''
              description.forEach(product => {
                result += product + ', '
              })
              return result
            } else {
              let result = ''
              description.forEach(product => {
                result += product
                if (tags[product]) result += tags[product]
                result += ', '
              })
              return result
            }
          }

          function isEmpty(o) { for (let _ in o) { return false } return true }
        </code>
      </pre>
      <footer>
        <p>
          Этот тип оптимизации может дать вам умеренные улучшения, но&nbsp;они будут накапливаться. Они являются хорошим
          дополнением к&nbsp;более важным оптимизациям, таким как формы и&nbsp;ввод-вывод памяти. Но&nbsp;учтите, что
          специализация может обернуться против вас, если ваши условия изменятся, поэтому будьте осторожны,
          применяя&nbsp;ее.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">
        Структуры данных
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f43e/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f43e/512.gif" alt="🐾" width="32" height="32" />
        </picture>
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Вводные:
          const userIds = Array.from({ length: 1_000 }).map((_, i) => i)
          const adminIdsArray = userIds.slice(0, 10)
          const adminIdsSet = new Set(adminIdsArray)

          // 1. Array
          let _ = 0
          for (let i = 0; i < userIds.length; i++) {
            if (adminIdsArray.includes(userIds[i])) { _ += 1 }
          }

          // 2. Set
          let _ = 0
          for (let i = 0; i < userIds.length; i++) {
            if (adminIdsSet.has(userIds[i])) { _ += 1 }
          }
        </code>
      </pre>
      <footer>
        <p>
          Но&nbsp;для быстрого примера давайте сравним, как Array.includes работает функция against Set.has для
          небольшого списка
        </p>
        <p>
          Я&nbsp;оставил этот раздел напоследок по&nbsp;одной причине: мне нужно было завоевать доверие с&nbsp;помощью
          забавных разделов выше. Теперь, когда у&nbsp;меня (надеюсь) это есть, позвольте мне сказать вам, что
          бенчмаркинг&nbsp;&mdash; самая важная часть оптимизации. Он&nbsp;не&nbsp;только самый важный,
          но&nbsp;и&nbsp;сложный . Даже после 20&nbsp;лет опыта я&nbsp;все еще иногда создаю бенчмарки, которые
          несовершенны, или неправильно использую инструменты профилирования. Поэтому, что&nbsp;бы
          вы&nbsp;ни&nbsp;делали, пожалуйста, приложите максимум усилий для правильного бенчмаркинга . 11.0 Начните
          с&nbsp;самого верха Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют
          большую часть времени выполнения. Если вы&nbsp;тратите время на&nbsp;оптимизацию чего-либо еще, кроме верхней
          части, вы&nbsp;тратите время впустую.&nbsp;11.1 Избегайте микро-бенчмарков Запустите свой код в&nbsp;режиме
          производства и&nbsp;основывайте свои оптимизации на&nbsp;этих наблюдениях. Движки JS&nbsp;очень сложны
          и&nbsp;часто ведут себя по-разному в&nbsp;микро-бенчмарках, чем в&nbsp;реальных сценариях. Например, возьмем
          этот микро-бенчмарк:
        </p>
        <p>https://darksi.de/d.sea-of-nodes/</p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="array" percentage="32"></custom-scale>
        <custom-scale name="set" percentage="91" winner="true"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">
        Избегайте крупных предметов
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/203c_fe0f/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/203c_fe0f/512.gif" alt="‼" width="32" height="32" />
        </picture>
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const USERS_LENGTH = 100_000
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // Вводные
          const USERS_LENGTH = 1_000;

          // setup:
          const byId = {}
          Array.from({ length: USERS_LENGTH }).forEach((_, id) => {
            byId[id] = { id, name: 'John'}
          })

          let _ = 0

          // 1. [] access
          Object.keys(byId).forEach(id => { _ += byId[id].id })

          // 2. direct access
          Object.values(byId).forEach(user => { _ += user.id })
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="[]" percentage="43"></custom-scale>
        <custom-scale name="direct" percentage="88" winner="true"></custom-scale>
      </div>
      <footer>
        <p>
          Как показано выше, избегайте частой индексации в&nbsp;больших объектах. Предпочитайте заранее превратить
          объект в&nbsp;массив. Организация данных для получения идентификатора в&nbsp;модели может помочь, так как
          вы&nbsp;можете использовать Object.values()и не&nbsp;обращаться к&nbsp;карте ключей, чтобы получить
          идентификатор.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте промахов кэша</h2>
      <footer>
        <p>
          Этот момент требует некоторых низкоуровневых знаний, но&nbsp;имеет последствия даже в&nbsp;javascript, поэтому
          я&nbsp;объясню. С&nbsp;точки зрения&nbsp;ЦП, извлечение памяти из&nbsp;ОЗУ происходит медленно. Для ускорения
          используются в&nbsp;основном две оптимизации.
        </p>
        <p>
          5.1 Предварительная выборка Первый&nbsp;&mdash; предварительная выборка: она заранее извлекает больше памяти
          в&nbsp;надежде, что это именно та&nbsp;память, которая вас интересует. Она всегда предполагает, что если
          вы&nbsp;запросите один адрес памяти, вас будет интересовать область памяти, которая идет сразу за&nbsp;ним.
          Поэтому последовательный доступ к&nbsp;данным&nbsp;&mdash; это ключ. В&nbsp;следующем примере мы&nbsp;можем
          наблюдать влияние доступа к&nbsp;памяти в&nbsp;случайном порядке.
        </p>
        <p>
          Этот аспект, вероятно, сложнее всего реализовать на&nbsp;практике, поскольку javascript не&nbsp;имеет способа
          размещения объектов в&nbsp;памяти, но&nbsp;вы&nbsp;можете использовать это знание в&nbsp;своих интересах, как
          в&nbsp;примере выше, например, для работы с&nbsp;данными перед их&nbsp;переупорядочением или сортировкой.
          Вы&nbsp;не&nbsp;можете предполагать, что объекты, созданные последовательно, останутся в&nbsp;том&nbsp;же
          месте через некоторое время, потому что сборщик мусора может переместить&nbsp;их. Есть одно исключение
          из&nbsp;этого, и&nbsp;это массивы чисел, предпочтительно TypedArray экземпляры:
        </p>
        <p>
          Безжалостно устраняйте все данные или выделения памяти , которые можно устранить. Чем меньше ваш набор данных,
          тем быстрее будет работать ваша программа. Ввод-вывод памяти является узким местом для&nbsp;95% программ.
          Другой хорошей стратегией может быть разделение вашей работы на&nbsp;части и&nbsp;обеспечение работы
          с&nbsp;небольшим набором данных за&nbsp;раз.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // setup:
          const K = 1024
          const length = 1 * K * K

          // Theses points are created one after the other, so they are allocated
          // sequentially in memory.
          const points = new Array(length)
          for (let i = 0; i < points.length; i++) {
            points[i] = { x: 42, y: 0 }
          }

          // This array contains the *same data* as above, but shuffled randomly.
          const shuffledPoints = shuffle(points.slice())
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
          // 1. sequential
          let _ = 0
          for (let i = 0; i < points.length; i++) { _ += points[i].x }

          // 2. random
          let _ = 0
          for (let i = 0; i < shuffledPoints.length; i++) { _ += shuffledPoints[i].x }
         </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="sequential" percentage="87" winner="true"></custom-scale>
        <custom-scale name="random" percentage="26"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Бесплатных функций в&nbsp;программных продуктах не&nbsp;бывает</h2>
      <footer>
        <p>
          Бесплатных&quot; функций в&nbsp;программных продуктах просто не&nbsp;бывает. Если рассматривать материальную
          сторону, то&nbsp;любые ненужные, но&nbsp;фактически реализованные &laquo;фичи&raquo; оплачиваются либо
          Заказчиком (в&nbsp;бюджет закладываются расходы на&nbsp;те&nbsp;функции, которые не&nbsp;нужны), либо
          Исполнителем из&nbsp;прибыли по&nbsp;проекту. И&nbsp;тот, и&nbsp;другой варианты с&nbsp;точки зрения бизнеса
          неверны. Если&nbsp;же говорить о&nbsp;нематериальных затратах, то&nbsp;любые &laquo;бонусные&raquo;
          возможности усложняют сопровождение, увеличивают вероятность ошибок и&nbsp;усложняют взаимодействие
          с&nbsp;продуктом,&nbsp;&mdash; между объёмом кодовой базы и&nbsp;описанными характеристиками есть прямая
          зависимость. Больше написанного кода&nbsp;&mdash; труднее сопровождать и&nbsp;выше вероятность появления
          &laquo;багов&raquo;.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          if (person?.isActive) {
            console.log('Пользователь активен');
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          if (person !== null && person !== void 0 && person.isActive) {
            console.log('Пользователь активен');
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          if (person && person.isActive) {
            console.log('Пользователь активен');
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          const items = await getItems()

          for (let item of items) {
            await processItem(item)
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          const items = await getItems()
          await Promise.all(items.map(processItem))
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">В&nbsp;чём разница между типом и&nbsp;интерфейсом?</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Что быстрее типы или интерфейсы?</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://github.com/microsoft/TypeScript/wiki/Performance"
        >https://github.com/microsoft/TypeScript/wiki/Performance</a
      >
      <footer>
        <p>Предпочитайте интерфейсы пересечениям</p>
        <p>Отношения типов между интерфейсами кешируется, в&nbsp;отличие от&nbsp;типов пересения.</p>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST (https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)&nbsp;&mdash; так,
          чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном уровне по&nbsp;мере его роста
          и&nbsp;выполнять такие операции, как поиск, как можно быстрее.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          - type Foo = Bar & Baz & {
          -     someProp: string;
          - }

          + interface Foo extends Bar, Baz {
          +     someProp: string;
          + }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          import { HTMLAttributes } from "react";

          type InputProps = HTMLAttributesHTMLInputElement & {
            variant: 'base' | 'custom';
          };

          const Input = ({ variant, ...props }: InputProps) => {
            console.log({ variant });

            return input {...props}
          };
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          import React from "react";

          interface ButtonProps
            extends React.HTMLAttributesHTMLButtonElement {
            extraProp: string;
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          import { MouseEvent } from "react";

          Input
            extraProp="base"
            onClick={(event) => {
              // event: MouseEventHTMLButtonElement, MouseEvent
            }}
        </code>
      </pre>
      <footer>
        <p>В случае строковых перечислений это также очень хорошо сжималось gzip из-за повторяющихся строк.</p>
        <p>
          Циклы должны завершаться как можно раньше Оценочный тест Обращайте внимание, есть ли необходимость выполнять
          каждую итерацию цикла. Например, если вы ищете конкретное значение и находите его, нет смысла в дальнейших
          итерациях, лучше прервать выполнение цикла оператором break: for (let i = 0; i < haystack.length; i++) { if
          (haystack[i] !== needle) break; } Или, если нужно произвести операции с определенными элементами цикла, вы
          можете пропустить другие операции с помощью оператора continue, который останавливает выполнение операторов в
          текущей итерации и немедленно переходит к следующей: for (let i = 0; i < haystack.length; i++) { if
          (!haystack[i] === needle) continue; doSomething(); } Стоит также помнить, что вложенные циклы можно разрывать
          с помощью меток. Это позволяет привязать оператор break или continue к определенному циклу: loop1: for (let i
          = 0; i < haystacks.length; i++) { loop2: for (let j = 0; j < haystacks[i].length; j++) { if (haystacks[i][j]
          === needle) { break loop1; } } }
        </p>
        <p>Удалите ненужные функции</p>
        <p>
          LCP LCP основывается на том, когда был отрендерен самый большой элемент на веб-странице. Обычно рендеринг
          больших элементов ставится в первую очередь, для того чтобы показать как можно больше контента пользователю.
          Первым большим элементом может быть большой блок текста, картинка или видео. CSR, SSR, SSG, ISR и другие
          аббревиатуры FID FID это показатель времени, который указывает на то, сколько занимает времени обработать
          первое взаимодействие пользователя с приложением. CSR, SSR, SSG, ISR и другие аббревиатуры CLS CLS это
          показатель сдвига элементов на странице. Если у приложения есть огромный скрипт, который долго грузится, а
          после загрузки дополняет DOM-дерево какими-то элементами в результате чего все на странице сдвигается - это
          плохо. Данный показатель измеряется не по временной шкале, а по шкале перцентилей. Данная шкала измеряется
          следующей формулой: Оценка смещения макета = доля воздействия * доля расстояния Если вы более подробно хотите
          разобраться в том что такое "доля воздействия" и "доля расстояния", то вы можете ознакомиться с данными
          понятиями на странице CLS в
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">d.ts</h2>
      <footer>
        <p>
          Анализ .d.ts файлов происходит намного быстрее, поскольку они содержат только биты, необходимые для проверки
          типов по&nbsp;сравнению с&nbsp;обычным .ts файлом. .d.tsФайл не&nbsp;содержит тел функций или других вещей,
          только определения типов, необходимые для использования модуля.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Контроль за типами</h2>
      <pre class="place">
        <code class="language-typescript">
          // src/tsconfig.json
          {
             "compilerOptions": {
                 // ...

                 // Don't automatically include anything.
                 // Only include `@types` packages that we need to import.
                 "types" : []
             },
             "files": ["foo.ts"]
          }

            // tests/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Only include `@types/node` and `@types/mocha`.
                   "types" : ["node", "mocha"]
               },
               "files": ["foo.test.ts"]
            }
        </code>
      </pre>
      <footer>
        <p>
          По&nbsp;умолчанию TypeScript автоматически добавляет все найденные в&nbsp;папке node_modules пакеты @types,
          вне зависимости от&nbsp;того, импортировали вы&nbsp;их&nbsp;или нет. Это сделано для того, чтобы определённые
          функции &laquo;просто работали&raquo; при использовании Node.js, Jasmine, Mocha, Chai и&nbsp;т.&nbsp;д., так
          как эти инструменты/пакеты не&nbsp;импортируются, а&nbsp;загружаются в&nbsp;глобальное окружение. Иногда эта
          логика может замедлять компиляцию и&nbsp;редактирование программы. И&nbsp;даже приводить к&nbsp;конфликтам
          объявлений в&nbsp;многочисленных глобальных пакетах, которые вызывают подобные ошибки:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
        <code class="language-typescript">
        {
          "compilerOptions": {
          "strict": true,
          ...
          },
          ...
          }
        </code>
      </pre>
      <footer>
        <p>
          По умолчанию TypeScript автоматически включает каждый @types пакет, который он находит в вашей node_modules
          папке, независимо от того, импортируете ли вы его. Это сделано для того, чтобы определенные вещи "просто
          работали" при использовании Node.js, Jasmine, Mocha, Chai и т. д., поскольку эти инструменты/пакеты не
          импортируются — они просто загружаются в глобальную среду.
        </p>
        <p>
          Один из&nbsp;способов повысить производительность&nbsp;&mdash; включить strict режим в&nbsp;вашем
          tsconfig.json. Это заставляет TypeScript перехватывать больше ошибок во&nbsp;время компиляции, что, хотя это
          может показаться нелогичным, на самом деле может повысить производительность. Строго типизированный код может
          быть легче оптимизирован движками JavaScript, а&nbsp;раннее обнаружение ошибок также означает меньше времени,
          затрачиваемого на&nbsp;отладку. Это может быть полезно как для разработки, так и&nbsp;для производительности
          во&nbsp;время выполнения.
        </p>
        <p>
          Если вы&nbsp;профилируете в&nbsp;браузере, убедитесь, что вы&nbsp;используете чистый + пустой профиль
          браузера. Я&nbsp;даже использую для этого отдельный браузер. Если вы&nbsp;профилируете и&nbsp;у&nbsp;вас
          включены расширения браузера, они могут испортить измерения. React devtools в&nbsp;частности существенно
          повлияют на&nbsp;результаты, код рендеринга может выглядеть медленнее, чем он&nbsp;есть на&nbsp;самом деле для
          ваших пользователей.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
                     // src/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Don't automatically include anything.
                   // Only include `@types` packages that we need to import.
                   "types" : ["node", "jest"]
               },
               "files": ["foo.ts"]
            }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Перфоманс CSS-селекторов</h2>
      <a class="copyright" href="https://web.dev/blog/at-property-performance" target="_blank" rel="noopener noreferrer"
        >At property performance</a
      >
      <footer>
        <p>
          мобильные браузеры будут ждать около 300&nbsp;мс с&nbsp;момента нажатия кнопки, чтобы запустить событие click.
          Причина этого в&nbsp;том, что браузер ждет, чтобы увидеть, действительно&nbsp;ли вы&nbsp;выполняете двойное
          нажатие
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          function add(x,y) {
            return x + y
          }

          add(1,2) // monomorphic
          add('a', 'b') // polymorphic
          add(true, false)
          add({},{})
          add([],[]) // megamorphic - at this stage, 4+ tries, no optimization will happen
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
          <code class="language-typescript">
            const markerNameA = "example-marker-a"
          const markerNameB = "example-marker-b"

          // Run some nested timeouts, and create a PerformanceMark for each.
          performance.mark(markerNameA);
          setTimeout(function() {
          performance.mark(markerNameB);
          setTimeout(function() {

            // Create a variety of measurements.
            performance.measure("measure a to b", markerNameA, markerNameB);
            performance.measure("measure a to now", markerNameA);
            performance.measure("measure from navigation start to b", undefined, markerNameB);
            performance.measure("measure from the start of navigation to now");

            // Pull out all of the measurements.
            console.log(performance.getEntriesByType("measure"));

            // Finally, clean up the entries.
            performance.Marks();
            performance.Measures();
          }, 1000);
          }, 1000);

                console.time("answer time");
          alert("Click to continue");
          console.timeLog("answer time");
          alert("Do a bunch of other stuff...");
          console.timeEnd("answer time");
          </code>
        </pre>
      <footer>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST&nbsp;&mdash; так, чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном
          уровне по&nbsp;мере его роста и&nbsp;выполнять такие операции, как поиск, как можно быстрее. Если
          вы&nbsp;только что оптимизировали функцию, и теперь она работает в&nbsp;100 раз быстрее, усомнитесь
          в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме производства, забросайте
          ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам факт наблюдения
          за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.
        </p>
        <p>
          Анализ JavaScript Итак, первым делом мы&nbsp;обрабатываем наш код JavaScript, чтобы разобрать его. Давайте
          обсудим, что такое парсинг. Анализ состоит из&nbsp;двух этапов: Eager (полный анализ)&nbsp;&mdash; анализирует
          каждую строку сразу Ленивый (предварительный анализ)&nbsp;&mdash; делаем минимум, анализируем&nbsp;то, что нам
          нужно, и&nbsp;оставляем остальное на потом. Что лучше? Все зависит от&nbsp;обстоятельств. Давайте посмотрим
          на&nbsp;код
        </p>
        <p>
          Избегайте ненужных утверждений типов Утверждения типов следует использовать осторожно. Чрезмерное их
          использование может привести к&nbsp;ненужным проверкам типов, что может снизить производительность. Вместо
          этого позвольте TypeScript выводить типы, когда это возможно. let value: any = &laquo;Hello,
          TypeScript!&raquo;; let strLength: number = (value as&nbsp;string).length; // Avoid using &rsquo;as
          string&rsquo; if&nbsp;TypeScript can infer the type
        </p>
        <p>
          Когда аргументы передаются в функцию, важно, чтобы они были одного типа. Turbofan прекратит попытки
          оптимизировать ваш JavaScript после 4 попыток, если типы аргументов различаются. Возьмем следующий пример:
        </p>
        <p>
          Если в&nbsp;течение 10-15 секунд пользователь не&nbsp;покинул ваш сайт, то&nbsp;это почти успех. Главная
          страница&nbsp;&mdash; лицо вашей фирмы в&nbsp;интернете. Захватите внимание пользователя, удержите его
          и&nbsp;перенаправьте на&nbsp;нужные ему разделы. Эффективно работающая главная страница сайта является
          четвертой татуировкой для вашего ресурса.
        </p>
        <p>
          Постоянные улучшения Чтобы сайт не&nbsp;лежал мертвым грузом в&nbsp;сети интернет, а&nbsp;работал как один
          из&nbsp;ваших лучших сотрудников, необходимо время от&nbsp;времени производить анализ поведения пользователей
          и&nbsp;делать выводы, основываясь на&nbsp;этих данных, повышать конверсию (превращение обычного пользователя
          в&nbsp;лояльного клиента). Постоянные улучшения&nbsp;&mdash; 15&nbsp;татуировка для вашего сайта.
        </p>
        <p>
          Акцент на&nbsp;качество и&nbsp;доверие Доверие к&nbsp;вашей компании будет стимулировать посетителя вашего
          сайта к&nbsp;покупке. Поэтому очень важно заполучить его расположение. В&nbsp;этом поможет размещенная
          на&nbsp;сайте следующая информация: официальная отчетность о&nbsp;деятельности вашей организации, информация
          о&nbsp;партнерах, ссылки на&nbsp;приложения вашего ресурса, данные по&nbsp;количеству просмотров каждой
          из&nbsp;статей на&nbsp;сайте, возможность оставлять комментарии и&nbsp;отзывы на&nbsp;вашем сайте, удобное
          портфолио с&nbsp;вашими реальными работами, фото ваших сотрудников, ссылки на&nbsp;социальные сети и&nbsp;т.д.
          Также предоставьте клиентам все необходимые гарантии: продемонстрируйте свои награды, сертификаты качества
          продукции, грамоты и&nbsp;лицензии.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Скрытые классы — это то, как V8 идентифицирует наши объекты</h2>
      <pre class="place">
        <code class="language-typescript">
          Давайте разберем это на этапы.

          Мы объявляем объект:

          const obj = { name: 'John'}
          Затем V8 объявит classId для этого объекта.

          const objClassId = ['name', 1]
          Тогда наш объект создается следующим образом:

          const obj = {...objClassId, 'John'}
          Затем, когда мы получаем доступ к name свойству нашего объекта следующим образом:

          obj.name
          V8 выполняет следующий поиск:

          obj[getProp(obj[0], name)]
          Это процесс, который V8 выполняет при создании наших объектов. Теперь давайте посмотрим, как мы можем оптимизировать наши объекты и использовать их повторно classIds.

          function Point(x, y) {
  this.x = x;
  this.y = y;
}

var p1 = new Point(11, 22);
var p2 = new Point(33, 44);
// At this point, p1 and p2 have a shared hidden class
p2.z = 55;
// warning! p1 and p2 now have different hidden classes!```
        </code>
      </pre>
      <footer>
        <p>
          В JavaScript имеется ограниченная информация о типах во время компиляции: типы могут быть изменены во время
          выполнения, поэтому естественно ожидать, что рассуждать о типах JS во время компиляции будет затратно. Это
          может заставить вас задаться вопросом, как производительность JavaScript может когда-либо приблизиться к C++.
          Однако в V8 есть скрытые типы, созданные внутри объектов во время выполнения; объекты с одним и тем же скрытым
          классом могут затем использовать один и тот же оптимизированный сгенерированный код.
        </p>
        <p>
          Пока в экземпляре объекта p2 не будет добавлен дополнительный элемент «.z», p1 и p2 внутри имеют один и тот же
          скрытый класс, поэтому V8 может генерировать одну версию оптимизированной сборки для кода JavaScript, который
          манипулирует либо p1, либо p2. Чем больше вы сможете избежать расхождения скрытых классов, тем выше
          производительность вы добьетесь. Поэтому Инициализируйте все члены объекта в функциях-конструкторах (чтобы
          экземпляры не меняли тип позже) Всегда инициализируйте члены объекта в одном и том же порядке.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          for (var b = 0; b &lt; 10; b++) {
  a[0] |= b;  // Oh no!
}
//vs.
a = new Array();
a[0] = 0;
for (var b = 0; b &lt; 10; b++) {
  a[0] |= b;  // Much better! 2x faster.
}
        </code>
      </pre>
      <footer>
        <p>
          Для обработки больших и разреженных массивов существует два типа внутреннего хранилища массивов: Fast
          Elements: линейное хранилище для компактных наборов ключей Элементы словаря: хранение хэш-таблицы в противном
          случае Лучше не переключать хранилище массива с одного типа на другой. Поэтому Используйте смежные ключи,
          начиная с 0, для массивов. Не выделяйте заранее большие массивы (например, > 64 КБ элементов) до максимального
          размера, вместо этого увеличивайте их по мере продвижения. Не удаляйте элементы в массивах, особенно числовых
          массивах. Не загружайте неинициализированные или удаленные элементы:
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
          Кроме того, массивы двойных значений работают быстрее - скрытый класс массива отслеживает типы элементов, а массивы, содержащие только двойные значения, распаковываются (что вызывает скрытое изменение класса). Однако небрежное манипулирование массивами может вызвать дополнительную работу из-за упаковки и распаковки - например


var a = new Array();
a[0] = 77;   // Allocates
a[1] = 88;
a[2] = 0.5;   // Allocates, converts
a[3] = true; // Allocates, converts```
менее эффективен, чем:


var a = [77, 88, 0.5, true];
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre class="place">
        <code class="language-typescript">
           Если вы можете, вы должны объявить свои свойства в конструкторе . Это гарантирует, что структура объекта останется прежней, чтобы V8 мог оптимизировать ваши объекты.

           class Point {
             constructor(x,y) {
               this.x = x
               this.y = y
             }
           }

           const p1 = new Point(11, 22) // hidden classId created
           const p2 = new Point(33, 44)
        </code>
      </pre>
      <footer>
        <p>
          Процентные результаты представляют собой количество операций, выполненных в&nbsp;течение 1&nbsp;с, деленное на
          количество операций в&nbsp;случае с&nbsp;наивысшей оценкой. Чем выше, тем лучше
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>node --cpu-prof $(which npm) run script</h2>
      <footer>
        <p>
          Большая часть времени тратится на загрузку всех модулей, составляющих npm cli. Время скрипта, который мы
          запускаем, меркнет в сравнении. Мы видим кучу файлов, которые кажутся необходимыми только при выполнении
          определенных условий. Примером этого может служить код для форматирования сообщений об ошибках, который
          требуется только при возникновении ошибки.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>https://github.com/danielroe/beasties (Critters)</h2>
    </section>

    <section class="slide">
      <h2 class="shout">no(po)lyfill</h2>
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://github.com/SukkaW/nolyfill"
        >https://github.com/SukkaW/nolyfill</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                       <code class="language-typescript">
                       - import { otherFunc } from "other";
                       + import { otherFunc, OtherType } from "other";

                       - export function func() {
                       + export function func(): OtherType {
                             return otherFunc();
                         }
                       </code>
                     </pre>
      <footer>
        <p>
          Добавление аннотаций типов, особенно возвращаемых типов, может сэкономить компилятору много работы. Отчасти
          это связано с тем, что именованные типы, как правило, более компактны, чем анонимные типы (которые компилятор
          может вывести), что сокращает время, затрачиваемое на чтение и запись файлов объявлений (например, для
          инкрементных сборок). Вывод типов очень удобен, поэтому нет необходимости делать это повсеместно — однако, это
          может быть полезно, если вы определили медленный раздел своего кода.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">TS производительность</h2>
      <img class="cover" src="./themes/tw/images/tips/ts/perfomance.jpg" width="701" height="996" alt="Perfomance" />
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Code Run</h2>
        <img
          class="ml-4"
          src="./themes/tw/images/shared/companies/yandex.svg"
          alt="Логотип Яндекс"
          width="56"
          height="56"
        />
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/cases/code-run/format.jpg"
        alt="Формат ввода"
        width="1002"
        height="438"
      />
      <footer>
        <p>Её&nbsp;величество Сортировка Сортировка&nbsp;&mdash; один из&nbsp;самых фундаментальных алгоритмов</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/cases/code-run/restrictions.jpg"
        alt="Формат ввода"
        width="1039"
        height="202"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                     <code class="language-typescript">
                       module.exports = function(N, staff, K) {
                         staff.sort((a, b) => b - a);

                         let sum = 0;

                         for (let = 0; i < Math.min(K, N); i++) {
                           sum += staff[i];
                         }

                         return sum;
                       }
                     </code>
                   </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Код</h2>
      <pre class="place">
                     <code class="language-typescript">
                       module.exports = function(N, staff, K) {
                         let count = new Array(26).fill(0);
                         let maxGrade = 0;
                         let keyboardsUsed = 0;
                         ley grade = 25;

                         for (let i = 0; i < N; i++) {
                           count[staff[i]]++;
                         }

                         while (keyboardUsed < K) {
                           if (count[grade] > 0) {
                             maxGrade += grade;
                             count[grade]--;
                             keyboardUsed++;
                           } else {
                             grade--;
                           }
                         }

                         return maxGrade;
                       }
                     </code>
                   </pre>
    </section>

    <section class="slide">
      <h2>Typescript VS Javascript benchmarks</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://programming-language-benchmarks.vercel.app/typescript-vs-javascript"
        >https://programming-language-benchmarks.vercel.app/typescript-vs-javascript</a
      >
    </section>

    <section class="slide">
      <h2>Всё познается в&nbsp;сравнении</h2>
      <img class="cover" src="./themes/tw/pictures/memes/statham.jpg" alt="Ограничения" width="640" height="760" />
    </section>

    <section class="slide">
      <h2 class="cover left-0 mt-[24px] -translate-y-[50%] pl-[120px] text-left">
        <span class="text-gray">Акт 3</span>
        <br />
        <span>Кейсы</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">Lessons learned from 222,557 font file subsets?</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://www.phpied.com/lessons-learned-from-222557-font-file-subsets/"
      >
        Font file subsets
      </a>
    </section>

    <section class="slide">
      <h2 class="shout">How I&nbsp;Created a&nbsp;3.78MB Docker Image for a&nbsp;JS Service</h2>
      <a
        rel="noopener noreferrer"
        target="_blank"
        class="copyright"
        href="https://shenzilong.cn/record/How%20I%20Created%20a%203.78MB%20Docker%20Image%20for%20a%20JavaScript%20Service"
        >How I&nbsp;Created a&nbsp;3.78MB Docker Image for a&nbsp;JavaScript Service</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Analyzing Notion app performance</h2>
      <a rel="noopener noreferrer" target="_blank" class="copyright" href="https://3perf.com/blog/notion/"
        >https://3perf.com/blog/notion/</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Notion уменьшила задержку на&nbsp;20% с&nbsp;кэшированием</h2>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://blog.quastor.org/p/notion-decreased-latency-20-caching-40c7?_bhlid=9dc7c5eafdb7c1ace16ba521b74792a35e9807c6"
        >Notion decreased latency 20 caching</a
      >
    </section>

    <section class="slide">
      <img src="./themes/tw/images/cases/CLS.jpg" alt="CLS" width="100" height="100" />
    </section>

    <section class="slide">
      <img src="./themes/tw/images/cases/wiki.jpg" alt="Wiki" width="100" height="100" />
    </section>

    <section class="slide">
      <img src="./themes/tw/images/cases/muz-souz.jpg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <img src="./themes/tw/images/cases/skolkovo-map.jpg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Сколково</h2>
      <img class="cover" src="./themes/tw/images/cases/skolkovo-map.jpg" alt="Skolkovo" width="1907" height="846" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/maestro-dent.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">DoubleB</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/doubleb.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Greencof</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/greencof.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">MSC</h2>
      <video
        muted
        disablepictureinpicture
        preload="metadata"
        width="500"
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-[#000] object-cover"
        controlslist="nofullscreen nodownload noremoteplayback noplaybackrate foobar"
        poster=""
      >
        <source src="./themes/tw/video/cases/msc.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="cover !left-0 mt-[24px] -translate-y-[50%] pl-[100px] text-left">
        <span class="text-gray">Акт&nbsp;4</span>
        <br />
        <span>Выводы</span>
      </h2>
      <footer>
        <ul>
          <li>делайте замеры</li>
          <li>начаните с&nbsp;малого</li>
          <li>перфоманс это навсегда</li>
        </ul>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Mem</h2>
      <img class="cover" src="./themes/tw/pictures/memes/klitschko.jpg" alt="Кличко" width="525" height="340" />
    </section>

    <section class="slide">
      <h2 class="shout">
        perfomance
        <span class="next text-red">
          <picture class="" style="display: inline-block">
            <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/2757/512.webp" type="image/webp" />
            <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/2757/512.gif" alt="❗" width="32" height="32" />
          </picture>
          important
        </span>
      </h2>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Чтобы прилетало меньше багов</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/air.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/air.gif" alt="🛫" width="56" height="56" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <div>
        <picture>
          <source srcset="./themes/tw/pictures/emoji/diamond.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/diamond.gif" alt="💎" width="32" height="32" />
        </picture>
        <h2 class="shout">Ваша система&nbsp;&mdash; это ответственность надолго</h2>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/basics/ux-core.jpg" alt="UX core" width="1913" height="914" />
      <a class="copyright" href="https://keepsimple.io/ru/uxcore/" target="_blank" rel="noopener noreferrer"
        >UX&nbsp;Core</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">20% усилий <span class="next">= 80% результата</span></h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="columns three">
        <img
          class="cover"
          src="./themes/tw/pictures/memes/oop/encapsulation.jpg"
          alt="Инкапсуляция"
          width="1184"
          height="1141"
        />
        <img
          class="cover"
          src="./themes/tw/pictures/memes/oop/inheritance.jpg"
          alt="Наследование"
          width="1183"
          height="1133"
        />
        <img
          class="cover"
          src="./themes/tw/pictures/memes/oop/polymorphism.jpg"
          alt="Полиморфизм"
          width="1183"
          height="1137"
        />
      </div>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Спасибо за&nbsp;внимание!</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/finish.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/finish.gif" alt="🏁" width="72" height="72" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="columns two">
        <img
          class="cover"
          src="./themes/tw/images/conclusions/qr-code-form.svg"
          alt="Qr code form"
          width="400"
          height="400"
        />
        <img
          class="cover"
          src="./themes/tw/images/conclusions/qr-code-presentation.svg"
          alt="Qr code form"
          width="400"
          height="400"
        />
      </div>
      <footer>
        <p>
          Big O&nbsp;&mdash; нотация, которая позволяет определить верхнюю границу скорости работы алгоритма. Как
          справедливо отметил один из&nbsp;комментаторов, это асимптотическая сложность, которая описывает верхнюю
          границу сложности алгоритма при увеличении размера входных данных, или&nbsp;то, как рост размера входных
          данных влияет на&nbsp;количество операций.
        </p>
        <p>
          Многие шаблоны, которые делают ваш код более гибким, полагаются на&nbsp;виртуальную диспетчеризацию,
          интерфейсы, указатели, сообщения и&nbsp;другие механизмы , которые все имеют по&nbsp;крайней мере некоторые
          затраты времени выполнения.
        </p>
        <p>
          Здесь есть спектр гибкости. Когда вы&nbsp;пишете код для вызова конкретного метода в&nbsp;некотором классе, вы
          фиксируете этот класс во&nbsp;время создания&nbsp;&mdash; вы&nbsp;жестко запрограммировали, какой класс
          вы&nbsp;вызываете. Когда вы проходите через виртуальный метод или интерфейс, класс, который вызывается,
          неизвестен до&nbsp;времени выполнения . Это гораздо более гибко, но&nbsp;подразумевает некоторые накладные
          расходы во&nbsp;время выполнения. Метапрограммирование шаблонов находится где-то посередине. Там
          вы&nbsp;принимаете решение о&nbsp;том, какой класс вызывать, во&nbsp;время компиляции , когда создается
          экземпляр шаблона.
        </p>
        <p>
          Отсюда следует одно неочевидное заключение: хорошо спроектированная система не&nbsp;заботится
          об&nbsp;увеличении свободной памяти. Память&nbsp;&mdash; это ресурс, а&nbsp;свободная память&nbsp;&mdash;
          неиспользуемый ресурс. Наоборот, хорошо спроектированная система использует достаточно много памяти, чтобы
          обеспечить такое состояние, когда пользователь не&nbsp;чувствует изменений в&nbsp;производительности.
        </p>
        <p>
          Но&nbsp;производительность&nbsp;&mdash; это все о&nbsp;предположениях. Практика оптимизации процветает
          на&nbsp;конкретных ограничениях. Можем&nbsp;ли мы&nbsp;с&nbsp;уверенностью предположить, что у&nbsp;нас
          никогда не&nbsp;будет больше 256&nbsp;врагов? Отлично, мы&nbsp;можем упаковать идентификатор в&nbsp;один байт.
          Мы&nbsp;будем вызывать здесь только метод для одного конкретного типа? Хорошо, мы&nbsp;можем статически
          диспетчеризировать или встроить его. Все&nbsp;ли сущности будут одного класса? Отлично, мы можем создать
          из&nbsp;них хороший непрерывный массив . (https://gameprogrammingpatterns.com/data-locality.html) Но это
          не&nbsp;значит, что гибкость плоха! Она позволяет нам быстро менять игру, а&nbsp;скорость разработки абсолютно
          необходима для получения интересного опыта. Никто, даже Уилл Райт, не&nbsp;может придумать сбалансированный
          игровой дизайн на&nbsp;бумаге. Он&nbsp;требует итераций и&nbsp;экспериментов. Чем быстрее вы&nbsp;сможете
          опробовать идеи и&nbsp;увидеть, как они себя чувствуют, тем больше вы&nbsp;сможете попробовать и&nbsp;тем
          больше вероятность найти что-то отличное. Даже после того, как вы&nbsp;нашли правильную механику, вам нужно
          много времени для настройки. Небольшой дисбаланс может испортить удовольствие от&nbsp;игры. Здесь нет простого
          ответа. Сделать программу более гибкой, чтобы вы&nbsp;могли быстрее создавать прототипы, будет иметь некоторые
          потери производительности. Аналогично, оптимизация вашего кода сделает его менее гибким. Однако мой опыт
          показывает, что легче сделать веселую игру быстрой, чем сделать быструю игру веселой. Один
          из&nbsp;компромиссов&nbsp;&mdash; сохранять код гибким, пока дизайн не&nbsp;устоятся, а&nbsp;затем вырвать
          часть абстракции позже, чтобы улучшить производительность.
        </p>
      </footer>
    </section>

    <section class="slide relative">
      <div class="shout flex flex-col items-center">
        <div class="dots relative h-[46px] w-[52px] text-white before:animate-jump"></div>
        <h2 class="place">Вопросы</h2>
      </div>
    </section>

    <script src="node_modules/@shower/core/dist/shower.js"></script>

    <script src="./themes/tw/libs/highlight/highlight.min.js"></script>
    <script src="./themes/tw/libs/highlight/init.js"></script>
    <script src="./themes/tw/libs/custom-scale.js"></script>
    <script src="./themes/tw/libs/playing-video.js"></script>
  </body>
</html>
