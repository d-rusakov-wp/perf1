<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1" />
    <meta name="description" content="Презентация по TailwindCSS" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="color-scheme" content="light dark" />

    <title>Семь раз отмерь, один раз оптимизируй</title>

    <style>
      .shower {
        --slide-ratio: calc(16 / 9);
      }
    </style>

    <link rel="icon" href="./themes/tw/images/logo.png" type="image/svg+xml" />
    <link rel="stylesheet" href="node_modules/@shower/ribbon/styles/styles.css" />
    <link rel="stylesheet" href="./themes/tw/libs/highlight/hybrid.min.css" />
    <link rel="stylesheet" href="./bundled/main.css" />
  </head>
  <body class="shower list custom-scrollbar all-clear">
    <header class="caption">
      <h1>Семь раз отмерь, один раз оптимизируй</h1>
      <p class="mt-2">
        <i>Денис Русаков</i>
      </p>
    </header>

    <section class="slide p-0">
      <div class="flex h-full flex-col items-center justify-end">
        <img class="!my-10" src="./themes/tw/images/logo.png" width="250" height="250" alt="Перо" />
        <div class="text-center">
          <h2 class="!my-[20px] text-5xl">Семь раз отмерь, один раз оптимизируй</h2>
          <p class="text-md italic leading-6">
            <i class="text-gray">Денис Русаков</i>
          </p>
        </div>
      </div>
      <footer>
        <p>Всем привет</p>
        <p>На&nbsp;слайде изображено перо жар птицы</p>
        <p>
          Фраза &laquo;семь раз отмерь, один раз отрежь&raquo; означает, что перед принятием важного решения или
          совершением действия нужно тщательно обдумать все возможные последствия и&nbsp;взвесить все
          за&nbsp;и&nbsp;против. Эта пословица призывает к&nbsp;осторожности, планированию и&nbsp;размышлению, чтобы
          сделать верный выбор или действие с&nbsp;первого раза, избегая необдуманных поступков
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="mt-[70px] flex flex-col items-center justify-center opacity-90">
        <div class="-mx-8 flex items-start justify-center gap-8">
          <img src="./themes/tw/images/preview/o-reilly/1.jpg" width="200" height="200" alt="Книга 1" />
          <img src="./themes/tw/images/preview/o-reilly/2.jpg" width="200" height="200" alt="Книга 2" />
          <img src="./themes/tw/images/preview/o-reilly/3.jpg" width="200" height="200" alt="Книга 3" />
        </div>
        <img
          class="mt-8"
          src="./themes/tw/images/preview/o-reilly/logo.svg"
          width="400"
          height="200"
          alt="Логотип O'Reilly"
        />
        <a target="_blank" rel="noopener noreferrer" class="copyright" href="https://www.oreilly.com/"
          >o&rsquo;reilly</a
        >
      </div>
      <footer>
        <p>Многие на&nbsp;обложках находятся на&nbsp;грани вымирания</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Жар птица</h2>
      <img class="cover" src="./themes/tw/images/preview/bird.jpg" width="736" height="490" alt="Жар птица" />
      <footer>
        <p>Птица из&nbsp;новой Гвинеи</p>
        <p>
          Сказание о&nbsp;необычной пташке зародилось еще в&nbsp;стародавние времена. Наши предки тогда верили
          в&nbsp;Перуна&nbsp;&mdash; бога грома и&nbsp;справедливости. Иногда он&nbsp;являлся в&nbsp;образе Жар-птицы.
          По&nbsp;другим легендам, она была символом бессмертия и&nbsp;богатства, поэтому добыть себе перо
          из&nbsp;ее&nbsp;хвоста считалось настоящим счастьем
        </p>
        <p>Перо&nbsp;&mdash; это производительность, которую нам иногда необходимо достичь/поймать?</p>
        <p>
          Вспомните, когда вы&nbsp;последний раз были в&nbsp;отпуске. Что вы&nbsp;помните? Возможно, вы&nbsp;вспомнили
          особенно красивый вид с&nbsp;вершины горы после долгого похода. Возможно, вы&nbsp;подумали об&nbsp;интересной
          выставке, которую вы&nbsp;увидели в&nbsp;музее, или об&nbsp;идеальном утре на&nbsp;пляже с&nbsp;семьей.
          Вы&nbsp;также могли представить себе момент, когда ваша последняя поездка приняла худший оборот: возможно,
          вы&nbsp;подумали о&nbsp;потере паспорта или о&nbsp;том, что заболели вдали от&nbsp;дома. Независимо
          от&nbsp;того, были&nbsp;ли воспоминания счастливыми или грустными, ваше общее впечатление от&nbsp;последнего
          отпуска, вероятно, включало несколько особенно сильных моментов. Мы&nbsp;помним события в&nbsp;нашей жизни как
          серию снимков, а&nbsp;не&nbsp;как полный каталог событий. Наш разум быстро усредняет моменты, которые наиболее
          выделяются в наших воспоминаниях, чтобы сформировать наше мнение о&nbsp;прошлом. Наиболее эмоционально
          интенсивные моменты опыта и&nbsp;его завершение оказывают большое влияние на&nbsp;то, как мы&nbsp;помним
          событие. Правило пика-конца: когнитивное искажение, которое влияет на&nbsp;то, как люди помнят прошлые
          события. Интенсивные позитивные или негативные моменты (&laquo;пики&raquo;) и&nbsp;финальные моменты опыта
          (&laquo;конец&raquo;) имеют большой вес в&nbsp;наших ментальных расчетах. Резюме: Когнитивные искажения
          меняют&nbsp;то, как мы&nbsp;вспоминаем прошлые события. Правило пика-конца фокусирует наши воспоминания вокруг
          самых интенсивных моментов опыта и&nbsp;того, как опыт заканчивается.
        </p>
        <p>
          Когда дело доходит до&nbsp;производительности веб-сайта, вы&nbsp;можете подумать о&nbsp;таких методах, как
          сжатие, оптимизация ресурсов или даже кэширование HTTP. Они действительно важны, и&nbsp;существует множество
          существующих ресурсов, охватывающих способы их&nbsp;исправления или внедрения. Однако некоторые менее
          обсуждаемые узкие места производительности могут серьезно повлиять на&nbsp;скорость веб-сайта. В&nbsp;этой
          статье мы&nbsp;обсудим три проблемы, которые часто возникают из-за неэффективных шаблонов JavaScript:
          Длительные задачи: операции JavaScript, которые монополизируют основной поток, что приводит
          к&nbsp;неотзывчивости пользовательских интерфейсов. Большие размеры пакетов: код JavaScript слишком велик для
          быстрой загрузки, анализа и&nbsp;выполнения. Проблемы гидратации: процесс присоединения функциональности
          JavaScript к&nbsp;HTML, отображаемому сервером. Хотя эти проблемы не&nbsp;новы, современные веб-практики
          и&nbsp;веб-фреймворки могут усугубить эти проблемы, снова поставив их&nbsp;в&nbsp;центр внимания. Примечание:
          Эти проблемы могут также возникать из&nbsp;других источников, таких как CSS. Например, долгая задача может
          быть вызвана сложным селектором CSS, которому требуется много времени для сопоставления элементов. Однако
          в&nbsp;этой статье основное внимание уделяется JavaScript.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Цель доклада</h2>
      <footer>
        <p>Простота и&nbsp;предсказуемость</p>
        <p>Подсветить важность производительности</p>
        <p>повысить приоритет</p>
        <p>
          при подготовке к&nbsp;докладу я&nbsp;просмотрел множество презентаций и&nbsp;везде плюс минус один
          план&nbsp;&mdash; рассказать про v8&nbsp;как она работает, что там есть как не&nbsp;писать js &mdash; поэтому
          поступим также
        </p>
        <p>
          V8&nbsp;&mdash; это высокопроизводительный движок&nbsp;JS и&nbsp;WebAssembly от&nbsp;Google с&nbsp;открытым
          исходным кодом, написанный на&nbsp;C++.&nbsp;Он&nbsp;используется в&nbsp;Chrome и&nbsp;Node.js.
          Он&nbsp;реализует ECMAScript и&nbsp;WebAssembly и&nbsp;работает в&nbsp;системах Windows, macOS и&nbsp;Linux,
          использующих процессоры x64, IA-32 или ARM. V8&nbsp;можно встроить в&nbsp;любое приложение C++.
          C++&nbsp;Реализует ECMAScript, как указано в&nbsp;ECMA-262 последней версии Microsoft Edge
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <footer>
        Анализ JavaScript Итак, первым делом мы&nbsp;обрабатываем наш код JavaScript, чтобы разобрать его. Давайте
        обсудим, что такое парсинг. Анализ состоит из&nbsp;двух этапов: Eager (полный анализ)&nbsp;&mdash; анализирует
        каждую строку сразу Ленивый (предварительный анализ)&nbsp;&mdash; делаем минимум, анализируем&nbsp;то, что нам
        нужно, и&nbsp;оставляем остальное на потом. Что лучше? Все зависит от&nbsp;обстоятельств. Давайте посмотрим
        на&nbsp;код.
        <pre>
        <code>
          // eager parse declarations right away
const a = 1;
const b = 2;

// lazily parse this as we don't need it right away
function add(a, b) {
  return a + b;
}

// oh looks like we do need add so lets go back and parse it
add(a, b);
        </code>
      </pre>

        <pre>
          <code>
            // eager parse declarations right away
const a = 1;
const b = 2;

// eager parse this too
var add = (function(a, b) {
  return a + b;
})();

// we can use this right away as we have eager parsed
// already
add(a, b);
          </code>
        </pre>

        <pre>
          <code>
            const square = (x) => { return x * x }

const callFunction100Times = (func) => {
  for(let i = 0; i < 100; i++) {
    // the func param will be called 100 times
    func(2)
  }
}

callFunction100Times(square)
          </code>
        </pre>

        <pre>
          <code>
            const square = (x) => { return x * x }

const callFunction100Times = (func) => {
  for(let i = 100; i < 100; i++) {
    // the function is inlined so we don't have
    // to keep calling func
    return x * x
  }
}

callFunction100Times(square)


            const square = (x) => { return x * x }
const cube = (x) => { return x * x * x }

const callFunction100Times = (func) => {
  for(let i = 100; i < 100; i++) {
    // the function is inlined so we don't have
    // to keep calling func
    func(2)
  }
}

callFunction100Times(square)
callFunction100Times(cube)
Итак, на этот раз после того, как мы вызвали square функцию 100times, мы затем вызовем cube функцию 100times. Перед тем, cube как ее можно будет вызвать, мы должны сначала деоптимизировать, callFunction100Times так как мы встроили square тело функции. В таких случаях square функция будет казаться быстрее, чем cube функция, но на самом деле этап деоптимизации делает выполнение более долгим.


       // mono example
const person = { name: 'John' }
const person2 = { name: 'Paul' }
// poly example
const person = { name: 'John' }
const person2 = { name: 'Paul', age: 27 }
            // mega example
const person = { name: 'John' }
const building = { rooms: ['cafe', 'meeting room A', 'meeting room B'], doors: 27 }


            Скрытые классы — это то, как V8 идентифицирует наши объекты.

Давайте разберем это на этапы.

Мы объявляем объект:

const obj = { name: 'John'}
Затем V8 объявит classId для этого объекта.

const objClassId = ['name', 1]
Тогда наш объект создается следующим образом:

const obj = {...objClassId, 'John'}
Затем, когда мы получаем доступ к name свойству нашего объекта следующим образом:

obj.name
V8 выполняет следующий поиск:

obj[getProp(obj[0], name)]
Это процесс, который V8 выполняет при создании наших объектов. Теперь давайте посмотрим, как мы можем оптимизировать наши объекты и использовать их повторно classIds.

            Советы по созданию объектов
Если вы можете, вы должны объявить свои свойства в конструкторе . Это гарантирует, что структура объекта останется прежней, чтобы V8 мог оптимизировать ваши объекты.

class Point {
  constructor(x,y) {
    this.x = x
    this.y = y
  }
}

const p1 = new Point(11, 22) // hidden classId created
const p2 = new Point(33, 44)
Вам следует поддерживать постоянный порядок свойств , возьмем следующий пример:

const obj = { a: 1 } // hidden class created
obj.b = 3

const obj2 = { b: 3 } // another hidden class created
obj2.a = 1

// this would be better
const obj = { a: 1 } // hidden class created
obj.b = 3

const obj2 = { a: 1 } // hidden class is reused
obj2.b = 3
Общие советы по оптимизации
Теперь давайте рассмотрим несколько общих советов, которые помогут лучше оптимизировать ваш код JavaScript.

Исправлены типы аргументов функции
Когда аргументы передаются в функцию, важно, чтобы они были одного типа. Turbofan прекратит попытки оптимизировать ваш JavaScript после 4 попыток, если типы аргументов различаются.

Возьмем следующий пример:

function add(x,y) {
  return x + y
}

add(1,2) // monomorphic
add('a', 'b') // polymorphic
add(true, false)
add({},{})
add([],[]) // megamorphic - at this stage, 4+ tries, no optimization will happen
Еще один совет — обязательно объявляйте классы в глобальной области видимости :

// don't do this
function createPoint(x, y) {
  class Point {
    constructor(x,y) {
      this.x = x
      this.y = y
    }
  }

  // new point object created every time
  return new Point(x,y)
}

function length(point) {
  //...
}
Заключение
Надеюсь, вы узнали кое-что новое о том, как работает V8 «под капотом» и как писать более оптимизированный код JavaScript.
          </code>
        </pre>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <ul>
        <li>отправка формы занимает очень много времени</li>
        <li>отправка формы занимает очень много времени</li>
        <li>npm install работает медленно</li>
      </ul>
    </section>

    <section class="slide">
      <h2>Алгоритмы</h2>
      <ul>
        <li>
          выбрать метрики, которыми можно можно охарактериозовать &laquo;степень оптимальности&raquo; нашего сайта или
          приложения
        </li>
        <li>найти код сильене всего ухудшающий метрики</li>
        <li>внести изменния в&nbsp;код</li>
        <li>измерить новые значения</li>
        <li>повторить</li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <p>
        API кооперативного планирования фоновых задач (также называемый API фоновых задач или requestIdleCallback()API)
        предоставляет возможность ставить задачи в&nbsp;очередь для автоматического выполнения агентом пользователя,
        когда он&nbsp;определяет, что для этого есть свободное время.
      </p>
    </section>

    <section class="slide">
      <h2 class="shout">Почему это проблема?</h2>
      <p class="next text-gray">ведь таски закрываются</p>
      <footer>
        <p>
          Если в&nbsp;течение 10-15 секунд пользователь не&nbsp;покинул ваш сайт, то&nbsp;это почти успех. Главная
          страница&nbsp;&mdash; лицо вашей фирмы в&nbsp;интернете. Захватите внимание пользователя, удержите его
          и&nbsp;перенаправьте на&nbsp;нужные ему разделы. Эффективно работающая главная страница сайта является
          четвертой татуировкой для вашего ресурса.
        </p>
        <p>
          Постоянные улучшения Чтобы сайт не&nbsp;лежал мертвым грузом в&nbsp;сети интернет, а&nbsp;работал как один
          из&nbsp;ваших лучших сотрудников, необходимо время от&nbsp;времени производить анализ поведения пользователей
          и&nbsp;делать выводы, основываясь на&nbsp;этих данных, повышать конверсию (превращение обычного пользователя
          в&nbsp;лояльного клиента). Постоянные улучшения&nbsp;&mdash; 15&nbsp;татуировка для вашего сайта.
        </p>
        <p>
          Акцент на&nbsp;качество и&nbsp;доверие Доверие к&nbsp;вашей компании будет стимулировать посетителя вашего
          сайта к&nbsp;покупке. Поэтому очень важно заполучить его расположение. В&nbsp;этом поможет размещенная
          на&nbsp;сайте следующая информация: официальная отчетность о&nbsp;деятельности вашей организации, информация
          о&nbsp;партнерах, ссылки на&nbsp;приложения вашего ресурса, данные по&nbsp;количеству просмотров каждой
          из&nbsp;статей на&nbsp;сайте, возможность оставлять комментарии и&nbsp;отзывы на&nbsp;вашем сайте, удобное
          портфолио с&nbsp;вашими реальными работами, фото ваших сотрудников, ссылки на&nbsp;социальные сети и&nbsp;т.д.
          Также предоставьте клиентам все необходимые гарантии: продемонстрируйте свои награды, сертификаты качества
          продукции, грамоты и&nbsp;лицензии.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Цель оптимизаций</h2>
      <ul>
        <li class="next">Избежать загрузки лишних ресурсов</li>
        <li class="next">Уменьшить размер ресурсов</li>
        <li class="next">Уменьшить время получения ресурсов</li>
        <li class="next">Избегать блокировки основного потока</li>
        <li class="next">Отложить загрузку второстепенных ресурсов</li>
      </ul>
    </section>

    <section class="slide">
      <h2>На&nbsp;что мы&nbsp;можем повлиять?</h2>
      <ul>
        <li class="next">Графика</li>
        <li class="next">HTML</li>
        <li class="next">CSS</li>
        <li class="next">JS</li>
        <li class="next">Шрифты</li>
        <li class="next">Third Party Scripts</li>
        <li class="next">Analytics</li>
      </ul>
      <ul>
        <li>Сервер и&nbsp;сеть</li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <ul>
        <li>Network</li>
        <li>RAM</li>
        <li>CPU</li>
      </ul>
      <footer>
        <p>Мы&nbsp;можем снизить нагрузку</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">ts-blank-space</h2>
      <a href="https://bloomberg.github.io/ts-blank-space/">https://bloomberg.github.io/ts-blank-space/</a>
      <footer>
        <p>
          быстрый компилятор с&nbsp;разделением типов, который преобразует TypeScript в&nbsp;JavaScript.
          Он&nbsp;поддерживает современное подмножество TypeScript, стирая типы и&nbsp;заменяя их&nbsp;пробелами. Вот
          и&nbsp;все. Он&nbsp;не&nbsp;является средством проверки типов и&nbsp;не&nbsp;выполняет никаких других
          преобразований кода. Базовая техника может улучшить производительность сборки и&nbsp;упростить разработку.
          Реализация&nbsp;&mdash; чистый TypeScript. Она достаточно проста для чтения и&nbsp;понимания за&nbsp;несколько
          минут, поскольку содержит всего 700 строк кода и&nbsp;повторно использует оригинальный парсер TypeScript.
          Тип-демонтаж Основная идея заключается в&nbsp;использовании пробелов в&nbsp;качестве замены аннотаций типов.
          Вы&nbsp;можете рассматривать это ts-blank-space как эталонную реализацию этой техники удаления типов. Подобно
          другим техникам компиляции, которые можно увидеть в&nbsp;экосистеме JavaScript, таким как tree-shaking, это
          идея многократного использования, которую может реализовать любой компилятор
        </p>
        <p>
          Взвешенные решения в&nbsp;процессе разработки&nbsp;&mdash; ключ к&nbsp;выходу здорового продукта в&nbsp;жизнь.
          Любое принятое сегодня решение определяет наше завтра. Поэтому сегодня важно принимать такие решения, которые
          завтра помогут продвинуться в&nbsp;сторону результата.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Google Optimize</h2>
      <p>
        Google Optimize и&nbsp;Optimize 360 ​​больше не&nbsp;доступны с&nbsp;30&nbsp;сентября 2023&nbsp;года. Все
        эксперименты и&nbsp;персонализации, которые были активны на&nbsp;эту дату, завершены.
      </p>
      <a class="copyright">https://web.dev/articles/top-cwv?hl=ru</a>
    </section>

    <section class="slide group">
      <h2>Какой план?</h2>
      <ul class="toc">
        <li class="toc__list-item next">
          <div class="toc__name">Теория <span>(подготовка)</span></div>
          <div class="page">1</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Практика (набор приемов/советов)</div>
          <div class="page">5</div>
        </li>
        <li class="toc__list-item next">
          <div class="toc__name">Выводы</div>
          <div class="page">9</div>
        </li>
      </ul>
      <img
        class="next float-right translate-x-[70px] translate-y-[200px] group-has-[#first-item.active]:hidden"
        src="./themes/tw/pictures/memes/plan.jpg"
        width="300"
        height="183"
        alt="План"
        aria-hidden="true"
      />
      <footer>
        <p>В&nbsp;теории подведу через некоторые истории и&nbsp;кейсы к&nbsp;сути темы</p>
        <p>
          V8&nbsp;&mdash; движок с&nbsp;открытым исходным кодом, написан на&nbsp;C++, его разработкой занимается Google.
        </p>
        <p>Скорость и&nbsp;метрики Немного цифр Инструменты для замеров Способы оптимизации</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="cover !left-0 mt-[24px] -translate-y-[50%] pl-[100px] text-left">
        <span class="text-gray">Акт 1</span> <br />Теория
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/numbers.jpg" width="1920" height="1080" alt="Numbers" />
      <footer>
        <p>производительность это не&nbsp;математика</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <figure class="place w-[55%]">
        <blockquote class="flex items-start">
          <p>Преждевременная оптимизация&nbsp;&mdash; корень всех бед</p>
        </blockquote>
        <figcaption>Дональд Кнут</figcaption>
      </figure>
      <footer>
        <p>Памятка</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <figure class="place w-[55%]">
        <blockquote class="flex items-start">
          <p>Если вы&nbsp;не&nbsp;можете что-то измерить, значит, вы&nbsp;не&nbsp;можете это исправить</p>
        </blockquote>
        <figcaption>Уильям Томсон</figcaption>
      </figure>
      <footer>
        <p>Памятка</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">производительность === продуктивность</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Доверя, но&nbsp;проверяй</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Скорость загрузки</h2>
      <footer>
        <p>
          Ваш мозг знает, что движение&nbsp;&mdash; это не&nbsp;отрывчатый или дискретный процесс, а&nbsp;плавный
          и&nbsp;последовательный. Дисплей устройств с&nbsp;высокой частотой кадров сделаны просто для того, чтобы
          сделать эту иллюзию более реальной. (Интересно, что стробоскопы переворачивают эту концепцию, заставляя наш
          мозг создавать иллюзию дискретной реальности).
        </p>
      </footer>
    </section>

    <section class="slide">
      <div class="flex h-full items-center justify-center">
        <h2>Что такое скорость загрузки?</h2>
        <p class="next">
          Скорость загрузки&nbsp;&mdash; совокупность факторов, которые влияют на&nbsp;то,
          <mark>воспринимает</mark>&nbsp;ли пользователь загрузку страницы как быструю.
        </p>
      </div>
      <a href="https://web.dev/what-is-speed/" rel="noopener noreferrer" class="copyright" target="_blank"
        >What is&nbsp;speed?</a
      >
      <footer>
        <h2>Почему скорость важна?</h2>
        <ul>
          <li>Удержание пользователей</li>
          <li>Повышение конверсии</li>
          <li>Улучшение пользовательского опыта</li>
          <li>SEO</li>
          <li>Забота о&nbsp;людях</li>
          <li>Не&nbsp;у&nbsp;всех мощное железо</li>
          <li>Не&nbsp;у&nbsp;всех безлимитный интернет</li>
          <li>Не&nbsp;у&nbsp;всех хорошее интернет-соединение</li>
          <li>Нужно быстро получить информацию</li>
          <li>Может создавать дискомфорт и&nbsp;вредить здоровью</li>
        </ul>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="flex h-full items-center justify-center">
        <div class="loader"></div>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Девайсы</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Качество интернет соединения</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Слишком много зависимостей</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Отзывчивость</h2>
      <footer>
        <p>
          Отзывчивость&nbsp;&mdash; это&nbsp;то, как быстро система предлагает ответ (или множество ответов)
          на&nbsp;запрос пользователя. Например, когда пользователь нажимает на&nbsp;экран, он&nbsp;ожидает, что пиксели
          под пальцем изменятся каким-то образом. Для этого случая взаимодействия хорошей метрикой будет время, которое
          прошло между моментом нажатия и&nbsp;изменением пикселей.
        </p>
        <p>
          Отзывчивость иногда включает в&nbsp;себя несколько этапов. Запуск приложения&nbsp;&mdash; один
          из&nbsp;важнейших этапов. Мы&nbsp;обсудим его ниже.
        </p>
        <p>
          Отзывчивость важна просто потому, что пользователи теряются и&nbsp;злятся, когда их&nbsp;игнорируют. Ваше
          приложение игнорирует пользователя каждую секунду, когда оно не&nbsp;отвечает на&nbsp;пользовательский ввод.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Загрузка и&nbsp;стресс</h2>
      <a
        href="https://files.stample.co/stample-1490437638577-emr-feb-2016-the-stress-of-steaming-delays.pdf"
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        >The stress of&nbsp;streaming delays</a
      >
      <footer>
        <ul>
          <li>100&nbsp;мс. мгновеннл</li>
          <li>1&nbsp;с.&nbsp;ок</li>
          <li>2&nbsp;c оке</li>
          <li>Больше&nbsp;&mdash; теряет фокус внимнаия</li>
        </ul>
        <p>
          Ощущаемая пользователем &laquo;производительность&raquo;&nbsp;&mdash; это единственная производительность,
          которая имеет значение. Пользователи взаимодействуют с&nbsp;системой с&nbsp;помощью ввода каких-то данных:
          прикосновений, движения и&nbsp;речи. В ответ, они получают реакцию, основанную на&nbsp;зрительном, тактильном
          или слуховом аппаратах. Производительность - это качество того, как система реагирует на&nbsp;действия
          пользователя.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <p class="place">
        <b>Движок JS</b>&nbsp;&mdash; специализированная программа, обрабатывающая&nbsp;JS, в&nbsp;частности,
        в&nbsp;браузерах.
      </p>
      <!-- <a target="_blank" rel="noopener noreferrer" href="">https://v8.dev/blog/react-cliff</a> -->
      <footer>
        <p>
          Почему был создан движок V8? Движок с&nbsp;открытым кодом V8&nbsp;был создан компанией Google, он&nbsp;написан
          на&nbsp;C++.&nbsp;Движок используется в&nbsp;браузере Google Chrome. Кроме того, что отличает
          V8&nbsp;от&nbsp;других движков, он&nbsp;применяется в&nbsp;популярной серверной среде Node.js.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">незнание (сопртивление страх) -&gt; знание (дискусиия доверие)</h2>
    </section>

    <section class="slide">
      <h2 class="shout">
        У&nbsp;всех разная кодовоя база, разные фреймворки и&nbsp;разные пользователи ...нет универсального решения
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
            if (true) [
              console.log('да')
            ]
            else [
              console.log('да нет же')
            ]
        </code>
          </pre>
    </section>

    <section class="slide">
      <h2>Какие движки существуют?</h2>
      <ul>
        <li class="next flex items-center">
          V8
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/chrome.svg"
              alt="Chrome"
              width="56"
              height="56"
            />
          </a>
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/tools/node-js.svg"
              alt="Node.js"
              width="56"
              height="56"
            />
          </a>
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/arc.svg"
              alt="Node.js"
              width="56"
              height="56"
            />
          </a>
        </li>
        <li class="next flex items-center">
          SpiderMonkey
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/firefox-old.svg"
              alt="Firefox"
              width="56"
              height="56"
            />
          </a>
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/firefox.svg"
              alt="Firefox"
              width="56"
              height="56"
            />
          </a>
        </li>
        <li class="next flex items-center">
          Chakra&nbsp;/ ChakraCore
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/edge.svg"
              alt="Edge"
              width="56"
              height="56"
            />
          </a>
        </li>
        <li class="next flex items-center">
          JavaScriptCore
          <a href="" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/safari.svg"
              alt="Safari"
              width="56"
              height="56"
            />
          </a>
          <a href="" target="_blank" rel="noopener noreferrer">
            <img class="next ml-4" src="./themes/tw/images/theory/tools/bun.svg" alt="Bun" width="56" height="56" />
          </a>
        </li>
        <li class="next flex items-center">
          и&nbsp;другие
          <a href="https://brave.com/" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/brave.svg"
              alt="Safari"
              width="56"
              height="56"
            />
          </a>
          <a href="https://sigmaos.com/" target="_blank" rel="noopener noreferrer">
            <img
              class="next ml-4"
              src="./themes/tw/images/theory/browsers/sigma.svg"
              alt="Safari"
              width="56"
              height="56"
            />
          </a>
        </li>
      </ul>
      <footer>
        <p>
          Движок&nbsp;&mdash; это ядро любого браузера. Он&nbsp;представлен в&nbsp;виде скрипта и&nbsp;отвечает
          за&nbsp;преобразование кода Web-продукта в&nbsp;динамическое изображение, которое отображается на&nbsp;экране
          устройства пользователя. Различия в движках базируются на&nbsp;том, что они имеют разные алгоритмы обработки
          кода. А&nbsp;ещё в&nbsp;них использованы отличные друг от&nbsp;друга принципы реализации стандартов web.
          Сейчас актуальны движки Blink, WebKit и&nbsp;Quantum (Gecko), а такие как Trident, EdgeHTML и&nbsp;Presto уже
          ушли в&nbsp;прошлое. Ниже мы&nbsp;рассмотрим основные движки и&nbsp;разберём, как их особенности влияют
          на&nbsp;тестирование.
        </p>
        <p>
          Blink Современный движок, созданный в&nbsp;2013 году на&nbsp;основе WebKit. Считается достаточно быстрым и
          высокопроизводительным для работы именно с&nbsp;web-приложениями. Применяется в&nbsp;Google Chrome, Opera
          и&nbsp;новых версиях Microsoft Edge, а&nbsp;также в&nbsp;других браузерах на&nbsp;базе Chromium, например,
          Yandex Browser. WebKit Оптимизирован под устройства компании Apple. Как и&nbsp;Blink, обладает высокой
          производительностью и&nbsp;поддерживает все основные web-стандарты. Ещё одним из&nbsp;его достоинств является
          энергоэффективность и&nbsp;высокое качество рендеринга текста и&nbsp;графики, что особенно важно для дисплеев
          с&nbsp;высоким разрешением. Применяется в&nbsp;Safari. Gecko Довольно-таки старый движок&nbsp;&mdash; был
          разработан аж&nbsp;в&nbsp;1997&nbsp;году. Его неоспоримые преимущества &mdash; кроссплатформенность
          и&nbsp;гибкость, т.к. Gecko поддерживает множество операционных систем, в&nbsp;том числе Windows, macOS, Linux
          и&nbsp;Android. Как и&nbsp;Blink и&nbsp;WebKit, поддерживает все основные web-стандарты. Хотя может быть
          и&nbsp;не такой шустрый, как WebKit, но&nbsp;у&nbsp;него своя фишечка&nbsp;&mdash; расширяемость, т.е. может
          поддерживать множество уникальных расширений и&nbsp;плагинов (например Selenium). Применяется в&nbsp;Firefox
          (до&nbsp;версии&nbsp;57) и&nbsp;других продуктах Mozilla (например, почтовый клиент Thunderbird), SeaMonkey.
          Quantum (Gecko). Это крупное обновление движка Gecko, выпущенное в&nbsp;2017&nbsp;году, которое значительно
          улучшило качество браузера Firefox. Благодаря поддержке современных web-стандартов Firefox сейчас один
          из&nbsp;самых совместимых браузеров. Применяется в&nbsp;Firefox (с&nbsp;версии 57), Tor Browser и&nbsp;Water
          fox. Trident и&nbsp;EdgeHTML Trident использовался в&nbsp;Internet Explorer (начиная с&nbsp;v4.0).
          EdgeHTML&nbsp;&mdash; это ответвление от&nbsp;него, созданное специально для Microsoft Edge. EdgeHTML был
          заменен на&nbsp;Blink в его новых версиях. Главный минус этих движков&nbsp;&mdash; проблемы
          с&nbsp;совместимостью и&nbsp;безопасностью. Presto Основным применением Presto был браузер Opera, который
          до&nbsp;2013 года использовал этот движок. Также Presto использовался в&nbsp;некоторых мобильных браузерах
          и&nbsp;устройствах, таких как Opera Mini и&nbsp;Opera Mobile. Как и&nbsp;EdgeHTML, был заменен на&nbsp;Blink.
          Presto, Trident и&nbsp;Gecko&nbsp;&mdash; уже по&nbsp;большей части история. А&nbsp;вот триумвират Quantum
          (Gecko), Blink и&nbsp;WebKit очень хорош. Эти движки являются самыми современными движками на&nbsp;сегодняшний
          день. Итак, зачем это знать тестировщику? Знание особенностей работы браузерных движков важно для
          QA-специалистов по&nbsp;нескольким причинам.&nbsp;1. Производительность движков может существенно отличаться.
          Например, однажды на&nbsp;проекте у&nbsp;нас возникла ситуация: приложение с&nbsp;интерактивными элементами
          и&nbsp;динамической загрузкой контента прекрасно работало в&nbsp;Chrome (Blink), но&nbsp;в&nbsp;Firefox
          (Gecko) мы&nbsp;заметили явные задержки в&nbsp;рендеринге. В&nbsp;итоге пришлось проводить дополнительную
          оптимизацию, чтобы приложение работало плавно во&nbsp;всех целевых браузерах.&nbsp;2. Кросс-браузерная
          совместимость и&nbsp;обработка HTML/CSS/JavaScript. Движки обрабатывают HTML, CSS и&nbsp;JavaScript
          по-разному. Это может привести к&nbsp;тому, что одно и&nbsp;то&nbsp;же web-приложение будет работать иначе
          в&nbsp;разных браузерах. Например, анимации, макеты или скрипты могут отображаться корректно в&nbsp;Chrome,
          но&nbsp;возникнут проблемы в&nbsp;Safari или Firefox. Знание особенностей каждого движка позволяет выявить
          такие различия на&nbsp;ранних этапах тестирования. По статистике, в&nbsp;Российской Федерации распределение
          среди пользователей предпочтений в&nbsp;использовании браузеров за последний год следующее:
          Chrome&nbsp;&mdash; 50% Yandex Browser&nbsp;&mdash; 23% Safari&nbsp;&mdash; 11% Opera&nbsp;&mdash;
          6%&nbsp;Microsoft Edge и&nbsp;Firefox - 3%&nbsp;Вот именно это и&nbsp;следует учитывать при проведении
          кросс-браузерного тестирования. Около 80-85% пользователей используют браузеры с&nbsp;движком Blink. Так что
          при тестировании мы&nbsp;смело можем выбрать один из&nbsp;них (Google Chrome, Yandex Browser, Opera или
          Microsoft Edge) и&nbsp;примерно с&nbsp;99,9(9)% вероятностью web-продукт в&nbsp;них будет работать
          и&nbsp;отображаться одинаково. А&nbsp;вот чтобы быть полностью уверенным в&nbsp;том, что web-продукт подходит
          остальным 15-20% пользователей, которые используют браузеры на&nbsp;основе иных движков, необходимо
          дополнительно проверить его в&nbsp;браузере Safari и&nbsp;Firefox. В&nbsp;одном из&nbsp;проектов
          мы&nbsp;работали с&nbsp;макетами, построенными на&nbsp;CSS Flexbox и&nbsp;Grid. В&nbsp;Chrome и&nbsp;Safari
          (на&nbsp;WebKit) вёрстка выглядела идеально, но&nbsp;как только мы&nbsp;проверили в&nbsp;старом Internet
          Explorer&nbsp;11 (на&nbsp;Trident), макет полностью поехал. Пришлось внедрять различные CSS-хаки, чтобы
          обеспечить корректное отображение в&nbsp;старых браузерах. В&nbsp;другой раз возникли проблемы работы
          сервис-воркеров (service workers), которые позволяют реализовать оффлайн-режим: с&nbsp;одной стороны всё
          ок&nbsp;в&nbsp;Chrome и&nbsp;Firefox, а&nbsp;с другой проблемы в&nbsp;старых версиях Safari. В&nbsp;итоге
          использовали фолбэки и&nbsp;альтернативные методы для того, чтобы обеспечить работу приложения на&nbsp;всех
          платформах. Эти случаи научили нас всегда помнить про поддержку кросс-браузерности и&nbsp;старых
          движков.&nbsp;3. Движки браузеров влияют на&nbsp;то, как web-приложение будет работать на различных платформах
          (десктоп, мобильные устройства, планшеты). Например, WebKit, который используется в Safari на&nbsp;устройствах
          Apple, обладает лучшей энергоэффективностью и&nbsp;рендерингом для экранов с&nbsp;высоким разрешением.&nbsp;4.
          При обнаружении бага важно понимать, связано&nbsp;ли это с&nbsp;ошибкой в&nbsp;коде приложения или с
          особенностями работы конкретного движка. Это помогает точнее локализовать проблему и&nbsp;эффективнее
          взаимодействовать с&nbsp;разработчиками для ее&nbsp;исправления. Например, баг, который появляется только
          в&nbsp;Firefox, может быть результатом специфики движка Gecko.&nbsp;5. Важно понимать, какой движок лучше
          поддерживает инструменты для автоматизации, чтобы выбрать наиболее подходящий подход к&nbsp;тестированию.
          Движки могут иметь разную степень поддержки инструментов для автоматизации, таких как Selenium или Puppeteer.
          Вот Gecko поддерживает множество уникальных расширений и&nbsp;плагинов для тестирования. Это знание помогает
          выбрать правильный подход для автоматизации тестирования... Как-то в&nbsp;ходе работы с&nbsp;Selenium мой
          коллега обнаружил, что движок Gecko (в Firefox) позволяет лучше интегрировать уникальные расширения
          и&nbsp;плагины для автоматизированного тестирования. Мы&nbsp;использовали это преимущество для создания
          сложных сценариев тестирования.&nbsp;6. Знание устаревших движков, таких как Trident или Presto, важно при
          тестировании старых приложений или для обеспечения поддержки legacy-систем. Тестировщики должны быть готовы
          к&nbsp;специфическим проблемам, которые могут возникнуть в&nbsp;таких системах. В&nbsp;конечном итоге,
          глубокое понимание браузерных движков помогает обеспечивать высокое качество продукта на&nbsp;разных
          устройствах и&nbsp;платформах. Это улучшает пользовательский опыт и&nbsp;снижает вероятность возникновения
          проблем после релиза. Ну&nbsp;разве не&nbsp;стоит знать заранее, что Blink и&nbsp;WebKit активно поддерживают
          API для работы с&nbsp;аппаратным обеспечением устройства, таким как доступ к&nbsp;камере через WebRTC,
          а&nbsp;Gecko может иметь особенности в&nbsp;реализации этого API? Такое поведение легко заметить при
          тестировании видео-конференц-приложений или приложений, использующих запись с&nbsp;камеры&nbsp;&mdash;
          в&nbsp;Firefox возникают проблемы с разрешением камеры или звуком, в&nbsp;то&nbsp;время как в&nbsp;Chrome или
          Safari эти функции работают корректно. Эти примеры помогли нам на&nbsp;практике увидеть, как знание движков
          даёт шанс обнаруживать и&nbsp;решать проблемы, связанные с производительностью, совместимостью, безопасностью
          и&nbsp;функциональностью приложений на&nbsp;разных браузерах. Надеюсь, эта статья убедила вас, что знания
          о&nbsp;движках браузеров нужны специалистам по&nbsp;тестированию. Буду признателен, если дадите обратную связь
          и&nbsp;поделитесь своим опытом в&nbsp;этой теме.
        </p>
        <p></p>
        <p>V8&nbsp;&mdash; это основной движок в&nbsp;Node.js, как и&nbsp;во&nbsp;всех Chrome Based браузерах</p>
        <p>
          Всеми нелюбимая Chakra, которая находится в&nbsp;Internet Explorer. Она даже работает
          не&nbsp;с&nbsp;JavaScript, а&nbsp;с&nbsp;Jscript&nbsp;&mdash; есть такое подмножество.
        </p>
        <p>Современные Chakra и&nbsp;ChakraCore, которые работают в&nbsp;Edge;</p>
        <p>SpiderMonkey в&nbsp;FireFox;</p>
        <p>
          JavaScriptCore в&nbsp;WebKit. Также он&nbsp;используется в&nbsp;React Native. Если у&nbsp;вас RN-приложение
          под Android, то&nbsp;оно так&nbsp;же исполняется на&nbsp;JavaScriptCore&nbsp;&mdash; движок идёт
          в&nbsp;комплекте с&nbsp;приложением.
        </p>
        <p>
          Rhino и&nbsp;Nashorn&nbsp;&mdash; это движки, которые используются в&nbsp;Java. С&nbsp;их&nbsp;помощью там
          тоже можно исполнять JavaScript
        </p>
        <p>JerryScript&nbsp;&mdash; для встраиваемых устройств;</p>
        <p>
          О&nbsp;двух компиляторах, которые использовались в&nbsp;V8&nbsp;Внутреннее устройство V8&nbsp;изменилось
          с&nbsp;выходом версии 5.9, которая появилась совсем недавно. До&nbsp;этого&nbsp;же он&nbsp;использовал два
          компилятора: full-codegen&nbsp;&mdash; простой и&nbsp;очень быстрый компилятор, который выдаёт сравнительно
          медленный машинный код. Crankshaft&nbsp;&mdash; более сложный оптимизирующий JIT-компилятор, который
          генерирует хорошо оптимизированный код. Внутри движка используются несколько потоков: Главный поток, который
          занимается тем, что от&nbsp;него можно ожидать: читает исходный JS-код, компилирует его и&nbsp;выполняет.
          Поток компиляции, который занимается оптимизацией кода в&nbsp;то&nbsp;время, когда выполняется главный поток.
          Поток профилировщика, который сообщает системе о&nbsp;том, в&nbsp;каких методах программа тратит больше всего
          времени, как результат, Crankshaft может эти методы оптимизировать. Несколько потоков, которые поддерживают
          механизм сборки мусора. При первом исполнении JS-кода V8&nbsp;задействует компилятор full-codegen, который
          напрямую, без каких-либо дополнительных трансформаций, транслирует разобранный им&nbsp;JavaScript-код
          в&nbsp;машинный код. Это позволяет очень быстро приступить к&nbsp;выполнению машинного кода. Обратите внимание
          на&nbsp;то, что V8&nbsp;не использует промежуточное представление программы в&nbsp;виде байт-кода, таким
          образом, устраняя необходимость в&nbsp;интерпретаторе. После того, как код какое-то время поработает, поток
          профилировщика соберёт достаточно данных для того, чтобы система могла понять, какие методы нужно
          оптимизировать. Далее, в&nbsp;другом потоке, начинается оптимизация с&nbsp;помощью Crankshaft.
          Он&nbsp;преобразует абстрактное синтаксическое дерево JavaScript в&nbsp;высокоуровневое представление,
          использующее модель единственного статического присваивания (static single-assignment, SSA). Это представление
          называется Hydrogen. Затем Crankshaft пытается оптимизировать граф потока управления Hydrogen. Большинство
          оптимизаций выполняется на&nbsp;этом уровне.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">
        Задержки в&nbsp;работе мобильных устройств вызывают такой&nbsp;же стресс, как просмотр фильма ужасов!
      </h2>
      <a class="copyright" href="https://www.neuronsinc.com/cases/ericsson"
        >https://www.neuronsinc.com/cases/ericsson</a
      >
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="!m-0">Как устроен <i>V8</i> ?</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/eyes.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/eyes.gif" alt="👀" width="56" height="56" aria-hidden="true" />
        </picture>
        <a class="copyright" href="https://v8.dev/blog/10-years" target="_blank" rel="noopener noreferrer">V8</a>
      </div>
      <footer>
        <p>
          В&nbsp;движке V8&nbsp;нет интерпретаторов, но&nbsp;существует 2&nbsp;типа компиляторов&nbsp;&mdash; общий
          и&nbsp;оптимизирующий. Это привод к&nbsp;тмоу, что&nbsp;JS всегда компилируется и&nbsp;запускается так&nbsp;же
          как и&nbsp;машинный код. Означает&nbsp;ли это, что код работает быстро? Нет, Сама по&nbsp;себе компиляция
          не&nbsp;ускоряет работу кода. Она позволяет избежать накладных расходов, вызванных работой интерпретатора,
          но&nbsp;неоптимизированный код будет работать медленно.
        </p>
        <p>Через скрытые классы V8&nbsp;идентифицирует объекты</p>
        <p>
          когда вы&nbsp;создаете новый объект движок создаст для него новый скрытый класс. Затем если вы&nbsp;измените
          тот&nbsp;же объект добавив новое свойство механизм создаст новый скрытый класс со&nbsp;всеми свойствам
          из&nbsp;предыдущего класса и&nbsp;включит новое свойство
        </p>
        <p>Мономофризм что у&nbsp;объектов одинаковые ключи без отличий</p>
        <p>Мегаморфизм тут объекты совершенно разные и&nbsp;их&nbsp;нельзя сравнивать</p>
        <p>Полиморфизм у&nbsp;объектов общая структура но&nbsp;меняются небольшие отличия</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/languages/java.svg" alt="Java" width="1921" height="1080" />
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/codeium/1.jpg" width="989" height="316" alt="Codeium 1" />
      <img
        class="next translate-x-[600px] translate-y-[340px]"
        src="./themes/tw/pictures/memes/Ilon.jpg"
        width="300"
        height="150"
        alt="Мем Ilon"
      />
      <a class="copyright" href="https://codeium.com/live/general" target="_blank" rel="noopener noreferrer">codeium</a>
      <footer>
        <p>
          Процентные результаты представляют собой количество операций, выполненных в&nbsp;течение 1&nbsp;с, деленное на
          количество операций в&nbsp;случае с&nbsp;наивысшей оценкой. Чем выше, тем лучше.
        </p>
        <p>
          Как видите, разница может быть существенной. Разница не&nbsp;обязательно связана со&nbsp;стоимостью, strcmp
          поскольку движки иногда могут использовать пул строк и&nbsp;сравнивать по&nbsp;ссылке, но&nbsp;она также
          связана с&nbsp;тем, что целые числа обычно передаются по&nbsp;значению в&nbsp;движках&nbsp;JS, тогда как
          строки всегда передаются как указатели, а&nbsp;доступ к памяти является дорогостоящим (см. раздел 5).
          В&nbsp;коде с&nbsp;большим количеством строк это может иметь огромное влияние. В&nbsp;качестве примера
          из&nbsp;реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в&nbsp;2 раза быстрее *,
          просто заменив строковые константы числами.&nbsp;0. Избегать работы Это может показаться очевидным,
          но&nbsp;это должно быть здесь, потому что не&nbsp;может быть другого первого шага к&nbsp;оптимизации: если
          вы&nbsp;пытаетесь оптимизировать, вы&nbsp;должны сначала рассмотреть возможность избегания работы. Это
          включает в&nbsp;себя такие концепции, как мемоизация, лень и&nbsp;инкрементальные вычисления. Это будет
          применяться по-разному в&nbsp;зависимости от&nbsp;контекста. В&nbsp;React, например, это будет означать
          применение memo()и useMemo()других применимых примитивов. 21&nbsp;марта 2024&nbsp;г. Оптимизация Javascript
          для развлечения и&nbsp;прибыли&nbsp;Я часто чувствую, что код javascript в&nbsp;целом работает гораздо
          медленнее, чем мог&nbsp;бы, просто потому, что он&nbsp;не&nbsp;оптимизирован должным образом. Вот сводка
          распространенных методов оптимизации, которые я&nbsp;нашел полезными. Обратите внимание, что компромиссом для
          производительности часто является читаемость, поэтому вопрос о&nbsp;том, когда выбирать между
          производительностью и читаемостью, остается на&nbsp;усмотрение читателя. Я&nbsp;также отмечу, что разговор
          об&nbsp;оптимизации обязательно требует разговора о&nbsp;бенчмаркинге. Микрооптимизация функции в&nbsp;течение
          нескольких часов, чтобы она работала в&nbsp;100 раз быстрее, бессмысленна, если функция изначально
          представляла лишь часть фактического общего времени выполнения. Если вы&nbsp;оптимизируете, первым
          и&nbsp;самым важным шагом является бенчмаркинг. Я&nbsp;рассмотрю эту тему в&nbsp;последующих пунктах. Также
          имейте в&nbsp;виду, что микробенчмарки часто имеют недостатки, и&nbsp;это может включать&nbsp;те, что
          представлены здесь. Я&nbsp;сделал все возможное, чтобы избежать этих ловушек, но&nbsp;не&nbsp;применяйте слепо
          ни&nbsp;один из пунктов, представленных здесь, без бенчмаркинга. Я&nbsp;включил примеры запуска для всех
          случаев, где это возможно. По&nbsp;умолчанию они показывают результаты, которые я&nbsp;получил на&nbsp;своей
          машине (brave 122&nbsp;на archlinux), но&nbsp;вы можете запустить их&nbsp;самостоятельно. Как&nbsp;бы мне
          ни&nbsp;было неприятно это говорить, Firefox немного отстал в&nbsp;плане оптимизации и&nbsp;на&nbsp;данный
          момент представляет собой очень малую часть трафика , поэтому я&nbsp;не&nbsp;рекомендую использовать
          результаты, которые вы&nbsp;получите на&nbsp;Firefox, в&nbsp;качестве полезных индикаторов.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/codeium/2.jpg" width="989" height="316" alt="Codeium 2" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/work.jpg" alt="Work" width="2006" height="1448" />
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://addyosmani.com/">Addy Osmani</a>
    </section>

    <section class="slide">
      <h2 class="place">Он&nbsp;развивается?</h2>
      <a class="copyright" href="https://v8.dev/blog/10-years" target="_blank" rel="noopener noreferrer"
        >10&nbsp;years</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">JIT</h2>
      <!-- <img src="./themes/arrival.webp" width="" height="" alt="Arrival" /> -->
      <a class="copyright">https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Статистика</h2>
      <img class="cover" src="./themes/tw/images/theory/stats.jpg" alt="Статистика" width="1195" height="1181" />
    </section>

    <section class="slide">
      <h2 class="shout">JNT (Just Noticeable Difference)</h2>
      <footer>
        <h2>Хороший алгоритм решения проблемы</h2>
        <ol>
          <li>воспроизвести проблему;</li>
          <li>локализовать ошибку;</li>
          <li>исправить ошибку;</li>
          <li>протестировать;</li>
          <li>избежать повторения в&nbsp;будущем;</li>
          <li>отдать тестировщику.</li>
        </ol>
        <h2>Алгоритм решения проблемы</h2>
        <ol>
          <li>подобрать решение;</li>
          <li>закоммитить;</li>
          <li>отдать тестировщику.</li>
        </ol>
        <p>де-факто</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">UX&nbsp;напрямую влияет на&nbsp;бизнес показатели</h2>
    </section>

    <section class="slide">
      <h2 class="shout">WebVitals&nbsp;/ CoreWebVitals</h2>
      <a href="https://web.dev/" class="copyright" target="_blank" rel="noopener noreferrer">Web Dev</a>
      <footer>
        <p>
          Web Vitals&nbsp;&mdash; это инициатива Google, цель которой&nbsp;&mdash; предоставить единое руководство
          по&nbsp;сигналам качества, необходимым для обеспечения хорошего взаимодействия с&nbsp;пользователем
          в&nbsp;Интернете.
        </p>
        <p>
          Core Web Vitals&nbsp;&mdash; это часть метрик Web Vitals, используемых для оценки веб-страниц
          и&nbsp;включенных во&nbsp;все инструменты Google.
        </p>
        <p>C&nbsp;2021 года Core Web Vitals учитываются при ранжировании</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <ul>
        <li>LCP (Largest Contentful Paint) <s>lazy</s> async/defer at&nbsp;third party</li>
        <li>CLS (Cumulative Layout Shift) (skeletons, images)</li>
        <li>INP (Interaction to&nbsp;Next Paint)</li>
        <li>TTFB</li>
        <li>SI</li>
        <li>FP</li>
        <li>FCP</li>
        <li><s>FID</s>&nbsp;TBT (remove Long Task, unused&nbsp;js)</li>
        <li>TTI</li>
      </ul>
      <footer>
        <p>preconnect&nbsp;/ dns-prefetch</p>
        <p>
          Длительная задача&nbsp;&mdash; это задача, выполнение которой занимает более 50&nbsp;мс. Это непрерывный
          период, когда основной поток пользовательского интерфейса занят в&nbsp;течение 50&nbsp;мс или дольше. Обычные
          примеры включают долго работающие обработчики событий, дорогие перекомпоновки и&nbsp;другие повторные рендеры,
          а&nbsp;также работу браузера между различными поворотами цикла событий, которая превышает 50&nbsp;мс.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Чертовски хорошо</h2>
      <a class="copyright" href="https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/"
        >https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/</a
      >
    </section>

    <section class="slide">
      <h2>Page Weight</h2>
      <a class="copyright" href="https://almanac.httparchive.org/en/2022/page-weight"
        >https://almanac.httparchive.org/en/2022/page-weight</a
      >
    </section>

    <section class="slide">
      <h2>Performance: measure() method</h2>
      <a class="copyright" href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure"
        >https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure</a
      >
    </section>

    <section class="slide">
      <h2>Performance: measure() method</h2>
      <a class="copyright" href="https://almanac.httparchive.org/en/2022/third-parties#performance-impact"
        >https://almanac.httparchive.org/en/2022/third-parties#performance-impact</a
      >
    </section>

    <section class="slide">
      <h2>LCP</h2>
      <p>Измеряет скорость отображения содержимого страницы</p>
      <p>Удалить блокирующий рендеринг</p>
      <p>Рендер на&nbsp;стороне сервера</p>
      <a class="copyright" href="https://v8.dev/blog/react-cliff">https://v8.dev/blog/react-cliff</a>
      <footer>
        <p>
          Для небольшого проекта это совсем не&nbsp;заметно, а&nbsp;вот в&nbsp;более крупном уже может вызывать видимую
          просадку в скорости работы.
        </p>
        <p>
          Big O&nbsp;&mdash; нотация, которая позволяет определить верхнюю границу скорости работы алгоритма. Как
          справедливо отметил один из&nbsp;комментаторов, это асимптотическая сложность, которая описывает верхнюю
          границу сложности алгоритма при увеличении размера входных данных, или&nbsp;то, как рост размера входных
          данных влияет на&nbsp;количество операций.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>INP</h2>
      <p>Измеряет задержку взаимодействия с&nbsp;пользователем</p>
      <p>разделить&nbsp;JS</p>
      <p>минимизируйте зменения DOM</p>
    </section>

    <section class="slide">
      <h2>CLS</h2>
      <p>Измеряет визуальную стабильность страницы</p>
      <p>Загрузка шрифтов (мжет вам не&nbsp;нужен шрифт)</p>
      <p>размеры изображений</p>
      <p>резерв места</p>
    </section>

    <section class="slide">
      <h2 class="shout">Счётчики vs&nbsp;PageSpeed</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
          function reCaptchaOnFocus() {
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">huperfine</h2>
      <a class="copyright" href="https://github.com/sharkdp/hyperfine">https://github.com/sharkdp/hyperfine</a>
    </section>

    <section class="slide">
      <h2 class="shout">WebVitals: SI</h2>
    </section>

    <section class="slide">
      <h2>Test CoreWebVitals</h2>
      <a href="https://www.debugbear.com/test/core-web-vitals">Test core-web-vitals</a>
    </section>

    <section class="slide">
      <h2>WebVitals: SI</h2>
      <figure>
        <figcaption>
          <p>
            Speed Index&nbsp;&mdash; индекс скорости. Измеряет насколько быстро контент визуально отображается
            в&nbsp;процессе загрузки страницы. Это вспомогательная метрика.
          </p>
        </figcaption>
      </figure>
      <a href="https://web.dev/speed-index/" class="copyright" target="_blank" rel="noopener noreferrer">Speed Index</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      Дорогая Консоль, дай мне список всех ресурсов, блокирующих рендеринг
      <pre>
        <code class="language-typescript">
          copy(window.performance.getEntriesByType('resource')
          .filter(entry => entry.renderBlockingStatus === 'blocking')
          .map(({name}) => name).join('\n')) $$('*').forEach(el => el.style.outline=`1px solid hsl(${
      el.tagName.split('').reduce((sum, c)=> sum+=c.charCodeAt(0), 0) % 360 },99%,50%)`)
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">https://treo.sh/</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        src="./themes/tw/pictures/memes/the-twilight-zone/1.jpg"
        width="1082"
        height="722"
        alt="The twilight zone 1"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        src="./themes/tw/pictures/memes/the-twilight-zone/2.jpg"
        width="1280"
        height="720"
        alt="The twilight zone 2"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        src="./themes/tw/pictures/memes/the-twilight-zone/3.jpg"
        width="1200"
        height="628"
        alt="The twilight zone 3"
      />
    </section>

    <section class="slide">
      <h2>Влияние Core Web Vitals</h2>
      <!-- https://web.dev/articles/css-web-vitals?hl=ru https://www.youtube.com/watch?v=kATRlMrtaaY
                https://web.dev/articles/remove-unused-code?hl=ru https://web.dev/articles/commonjs-larger-bundles?hl=ru
                https://alpinejs.dev/ -->
      <ul>
        <li>
          <a href="https://web.dev/yahoo-japan-news/" target="_blank" rel="noopener noreferrer">Yahoo! Japan</a>
          улучшила CLS, что привело к&nbsp;сокращению количества плохих страниц на&nbsp;98% и&nbsp;увеличению числа
          просмотров страниц за&nbsp;сеанс на&nbsp;15%.
        </li>
        <li>
          AliExpress улучшил CLS в&nbsp;10&nbsp;раз, а&nbsp;LCP в&nbsp;2&nbsp;раза, что привело к&nbsp;снижению
          показателя отказов на&nbsp;15%
        </li>
      </ul>
      <a href="https://web.dev/vitals-business-impact/" class="copyright" target="_blank" rel="noopener noreferrer"
        >The business impact of&nbsp;Core Web Vitals</a
      >
    </section>

    <section class="slide">
      <h2>Влияние</h2>
      <ul>
        <li class="next">
          Для
          <a
            href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales"
            target="_blank"
            rel="noopener noreferrer"
            >Amazon</a
          >
          каждые 100мс задержки обходятся в&nbsp;1% продаж.
        </li>
        <li class="next">
          <a href="https://www.walmart.com/" target="_blank" rel="noopener noreferrer"
            >walmart: 1&nbsp;секунда ускорения + 2%&nbsp;конверсии от&nbsp;400 млрд</a
          >
        </li>
        <li class="next">
          AliExpress сократил время загрузки на&nbsp;36%, увеличил количество заказов на&nbsp;10,5% и&nbsp;увеличил
          конверсию для новых клиентов на&nbsp;27%.
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="shout">Notion уменьшила задержку на&nbsp;20% с&nbsp;кэшированием</h2>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://blog.quastor.org/p/notion-decreased-latency-20-caching-40c7?_bhlid=9dc7c5eafdb7c1ace16ba521b74792a35e9807c6"
        >https://blog.quastor.org/p/notion-decreased-latency-20-caching-40c7?_bhlid=9dc7c5eafdb7c1ace16ba521b74792a35e9807c6</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Чем измерять?</h2>
      <footer>
        <p>Лабораторные</p>
        <ul>
          <li>Имитируются в&nbsp;лабораторных условиях</li>
          <li>Зависят от&nbsp;среды проверки</li>
          <li>Результаты от&nbsp;проверки к&nbsp;проверке могут отличаться</li>
        </ul>
        <p>Полевые</p>
        <ul>
          <li>Собираются с&nbsp;реальных пользователей</li>
          <li>Отличаются для разных пользователей</li>
          <li>Необходимо достаточное количество для анализа</li>
        </ul>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Дом света <span class="next">(Lighthouse)</span></h2>
    </section>

    <section class="slide">
      <h2 class="shout">Lighthouse Scoring Calculator</h2>
      <a
        href="https://googlechrome.github.io/lighthouse/scorecalc/#FCP=6000&SI=1000&FMP=4000&TTI=7300&FCI=6500&LCP=1000&TBT=0&CLS=0&device=mobile&version=10"
        >T</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">PageSpeed</h2>
      <a class="copyright" href="https://pagespeed.web.dev/" target="_blank" rel="noopener noreferrer">PageSpeed</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/tools/unlighthouse.jpg"
        alt="Unlighthouse"
        width="2160"
        height="1440"
      />
      <a class="copyright" href="https://unlighthouse.dev/" target="_blank" rel="noopener noreferrer">Unlighthouse</a>
    </section>

    <section class="slide">
      <h2 class="shout">DevTools</h2>
      <a class="copyright" href="https://www.youtube.com/watch?v=70XMVfGv2Q0" target="_blank" rel="noopener noreferrer"
        >Chrome DevTools&nbsp;&mdash; спрятанные полезности</a
      >
      <footer>
        <p>Тестируйте производительность в&nbsp;разных браузерах</p>
        <p>Запускайте функции по&nbsp;много раз</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/directed-by.jpg" alt="Directed by" width="1200" height="750" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/network.jpg"
        alt="Network"
        width="1921"
        height="1080"
      />
      <footer>
        <p>Кто уже попробовал с&nbsp;129 хрома новую вкладку?</p>
      </footer>
    </section>

    <section class="slide">
      <h2>использование памяти веб-страницы во&nbsp;время записи</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/perfomance-memory.jpg"
        alt="Perfomance memory"
        width="2154"
        height="1319"
      />
    </section>

    <section class="slide">
      <h2>Выделите области, которые перерисовывает движок браузера</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/rendering.jpg"
        alt="Rendering"
        width="2154"
        height="1081"
      />
    </section>

    <section class="slide">
      <h2 class="shout">console.table(performance.timing)</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/console/timing.jpg"
        alt="Timing"
        width="2154"
        height="1438"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/perfomance.jpg"
        alt="Perfomance"
        width="1921"
        height="1080"
      />
      <a
        class="copyright"
        href="https://github.com/iamakulov/devtools-perf-features"
        target="_blank"
        rel="noopener noreferrer"
        >(devtools-perf-features)</a
      >
      <footer>
        <p>
          Если вы&nbsp;профилируете в&nbsp;браузере, убедитесь, что вы&nbsp;используете чистый и&nbsp;пустой профиль
          браузера. Я&nbsp;даже использую для этого отдельный браузер. Если вы&nbsp;профилируете и&nbsp;у&nbsp;вас
          включены расширения браузера, они могут испортить измерения. React devtools в&nbsp;частности существенно
          повлияют на&nbsp;результаты, код рендеринга может выглядеть медленнее, чем он&nbsp;есть на&nbsp;самом деле
          в&nbsp;зеркале для ваших пользователей. Различные движки будут оптимизировать определенные шаблоны лучше или
          хуже других. Вам следует провести бенчмаркинг для движков, которые имеют отношение к&nbsp;вам,
          и&nbsp;расставить приоритеты, какой из&nbsp;них важнее. Вот реальный пример в&nbsp;Babel, где улучшение
          V8&nbsp;означает снижение производительности JSC. https://github.com/babel/babel/pull/16357 11.2 Сомневаетесь
          в&nbsp;своих результатах Если вы&nbsp;только что оптимизировали функцию, и&nbsp;теперь она работает в&nbsp;100
          раз быстрее, усомнитесь в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме
          производства, забросайте ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам
          факт наблюдения за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/dev-tools/stack.jpg" alt="Стек" width="1367" height="459" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/web-almanac/median-page-weight-by-content-type.jpg"
        alt="Median page"
        width="1200"
        height="742"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/1.svg" alt="Arrow 1" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/2.svg" alt="Arrow" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/3.svg" alt="Arrow" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/4.svg" alt="Arrow" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/5.svg" alt="Arrow" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/arrows/6.svg" alt="Arrow" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/ignition.svg" alt="ignition" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/liftoff.svg" alt="liftoff" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/main.svg" alt="main" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/orinoco.svg" alt="orinoco" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/turbofan.svg" alt="turbofan" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8/work.jpg" alt="work" width="2006" height="1448" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/engines/gecko.svg" alt="gecko" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/web-almanac/unused-js.jpg"
        alt="Unused js"
        width="1200"
        height="742"
      />
      <a class="copyright" href="https://almanac.httparchive.org/ru/2022/">httparchive</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
              const t0 = performance.now();
for (let i = 0; i < array.length; i++)
{
// код
}
const t1 = performance.now();
console.log(t1 - t0, 'milliseconds');

Chrome - 0.6350000001020817 ms
Firefox — 1 ms
        </code>
  </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/perfomance-insights.jpg"
        alt="Perfomance insights"
        width="2155"
        height="1440"
      />
      <a class="copyright"> https://doka.guide/js/performance/ </a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/dev-tools/memory.jpg" alt="Memory" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/console/memory.jpg"
        alt="Memory"
        width="928"
        height="183"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/console/navigator-connection.jpg"
        alt="Navigator connection"
        width="928"
        height="183"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/console/supported-entry-types.jpg"
        alt="Supported entry types"
        width="928"
        height="379"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/console/timing.jpg"
        alt="Timing"
        width="2154"
        height="1438"
      />
    </section>
    ;

    <section class="slide">
      <h2 class="shout">ReactDeveloperTools</h2>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
        >React Developer Tools</a
      >
    </section>

    <section class="slide">
      <h2>Statoscope</h2>
      <a class="copyright">https://github.com/statoscope/statoscope</a>
    </section>

    <section class="slide">
      <h2 class="shout">Мониторинг производительности</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Sentry</h2>
      <a class="copyright">https://docs.sentry.io/platforms/javascript/tracing/instrumentation/performance-metrics/</a>
    </section>

    <section class="slide">
      <h2>А&nbsp;чем будем мерить?</h2>
      <ul>
        <li class="next">DevTools выполняется во&nbsp;время простоя браузера&nbsp;&mdash; Perfomance API</li>
        <li class="next">
          <a target="_blank" rel="noopener noreferrer" href="https://browserbench.org/Speedometer3.0/"
            >https://browserbench.org/Speedometer3.0/</a
          >
        </li>
        <li class="next">
          сервисы (
          <a href="https://ui.perfetto.dev/" target="_blank" rel="noopener noreferrer">perfetto</a>)
        </li>
        <li class="next">
          расширения в&nbsp;IDE (
          <a
            target="_blank"
            rel="noopener noreferrer"
            href="https://marketplace.visualstudio.com/items?itemName=rbuckton.deoptexplorer-vscodeer-vscode"
            >deoptexplorer-vscode</a
          >)
        </li>
        <li class="next">
          нейтрализация временной разницы пакеты (
          <a target="_blank" rel="noopener noreferrer" href="https://www.npmjs.com/package/perfume.js">perfume</a>
          и&nbsp;т.&nbsp;д.)
        </li>
        <li class="next">
          <a href="" target="_blank" rel="noopener noreferrer">https://github.com/facebook/memlab</a>
        </li>
        <li>
          <a href="https://web.dev/articles/speed-v8?hl=ru" target="_blank" rel="noopener noreferrer"
            >https://web.dev/articles/speed-v8?hl=ru</a
          >
        </li>
        <li>
          <a href="https://jsbenchmark.com/" target="_blank" rel="noopener noreferrer">jsbenchmark</a>
        </li>
        <li>
          <a href="https://habr.com/ru/companies/oleg-bunin/articles/417459/" target="_blank" rel="noopener noreferrer"
            >Пост с&nbsp;хабра</a
          >
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2 class="shout">
        Web Perfomance&nbsp;&mdash; набор техник, которые позволяют улучшить производительность веб-приложений
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">
        Техники оптимизации
        <span class="next text-gray">the status quo</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">Сжатие размера изображений<span class="next text-gray">, без потери качества</span></h2>
    </section>

    <section class="slide">
      <h2 class="shout">
        Оптимизация шрифтов<span class="next text-gray">, где можно использовать только нужные символы</span>
      </h2>
    </section>

    <section class="slide">
      <h2 class="shout">Third Party Scripts</h2>
      <img class="next ml-4" src="./themes/tw/pictures/memes/party.jpg" alt="Party" width="56" height="56" />
      <footer>
        <p>грузить после load</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div>
        <img class="m-auto" src="./themes/tw/images/theory/tools/cdn.jpg" width="512" height="512" alt="CDN" />
      </div>
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img src="./themes/tw/images/theory/techniques/lazy-load.gif" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Tree shaking</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/theory/techniques/tree-shaking.jpg"
        width="1486"
        height="895"
        alt="Tree shaking"
      />
    </section>

    <section class="slide">
      <h2>Code splitting</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/theory/techniques/code-splitting.jpg"
        width="1600"
        height="967"
        alt="Code splitting"
      />
    </section>

    <section class="slide">
      <h2>🗜️ Minify code</h2>
      <img
        class="m-auto"
        src="./themes/tw/images/theory/techniques/minified.jpg"
        width="1857"
        height="841"
        alt="Minified"
      />
      <footer>
        <p>Пользователям - производительность</p>
        <p>поисковым системам - seo ranking</p>
        <p>бизнесу - конверсия</p>
        <p>
          Отсюда и&nbsp;взрыв разработки новых инструментов, которые являются, по&nbsp;большому счёту, упрощённой
          заменой существующих: Rolldown для Rollup, Oxlint для ESLint, Biome для Prettier и&nbsp;так далее. Однако
          работают эти инструменты быстрее не&nbsp;обязательно из-за того, что написаны на&nbsp;более быстром языке.
          Их&nbsp;скорость может объясняться тем, что: 1) их&nbsp;пишут с&nbsp;упором на&nbsp;производительность
          и&nbsp;2) поверхность API уже налажена, поэтому авторам не&nbsp;нужно тратить время на&nbsp;проработку общего
          дизайна. Чёрт возьми, да&nbsp;вам даже не&nbsp;требуется писать тесты! Просто используйте существующий набор
          от&nbsp;предыдущего инструмента.
        </p>
        <p>
          За&nbsp;свою карьеру я&nbsp;часто видел, как в&nbsp;случаях, когда переписывание&nbsp;А в&nbsp;B приводит
          к&nbsp;повышению скорости, автор этого ремейка заявляет, что&nbsp;B быстрее А.&nbsp;Тем не&nbsp;менее, как
          отметил Райан Карниато, ремейк зачастую быстрее, просто потому что это ремейк&nbsp;&mdash; при переписывании
          чего-то вы&nbsp;знаете больше, больше внимания уделяете производительности и&nbsp;так далее.
        </p>
        <p>
          Когда дело доходит до&nbsp;производительности веб-сайта, вы&nbsp;можете подумать о&nbsp;таких методах, как
          сжатие, оптимизация ресурсов или даже кэширование HTTP. Они действительно важны, и&nbsp;существует множество
          существующих ресурсов, охватывающих способы их&nbsp;исправления или внедрения. Однако некоторые менее
          обсуждаемые узкие места производительности могут серьезно повлиять на&nbsp;скорость веб-сайта. В&nbsp;этой
          статье мы&nbsp;обсудим три проблемы, которые часто возникают из-за неэффективных шаблонов JavaScript:
        </p>
        <p>
          Длительные задачи&nbsp;&mdash; операции JavaScript, которые монополизируют основной поток, что приводит
          к&nbsp;неотзывчивости пользовательских интерфейсов
        </p>
        <p>
          Большие размеры пакетов&nbsp;&mdash; код JavaScript слишком велик для быстрой загрузки, анализа
          и&nbsp;выполнения
        </p>
        <p>
          Проблемы гидратации&nbsp;&mdash; процесс присоединения функциональности JavaScript к&nbsp;HTML, отображаемому
          сервером
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
<code>
  const markerNameA = "example-marker-a"
const markerNameB = "example-marker-b"

// Run some nested timeouts, and create a PerformanceMark for each.
performance.mark(markerNameA);
setTimeout(function() {
performance.mark(markerNameB);
setTimeout(function() {

  // Create a variety of measurements.
  performance.measure("measure a to b", markerNameA, markerNameB);
  performance.measure("measure a to now", markerNameA);
  performance.measure("measure from navigation start to b", undefined, markerNameB);
  performance.measure("measure from the start of navigation to now");

  // Pull out all of the measurements.
  console.log(performance.getEntriesByType("measure"));

  // Finally, clean up the entries.
  performance.Marks();
  performance.Measures();
}, 1000);
}, 1000);

      console.time("answer time");
alert("Click to continue");
console.timeLog("answer time");
alert("Do a bunch of other stuff...");
console.timeEnd("answer time");
</code>
    </pre>
      <footer>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST&nbsp;&mdash; так, чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном
          уровне по&nbsp;мере его роста и&nbsp;выполнять такие операции, как поиск, как можно быстрее. Если
          вы&nbsp;только что оптимизировали функцию, и теперь она работает в&nbsp;100 раз быстрее, усомнитесь
          в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме производства, забросайте
          ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам факт наблюдения
          за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.
        </p>
        <p>
          Избегайте ненужных утверждений типов Утверждения типов следует использовать осторожно. Чрезмерное их
          использование может привести к&nbsp;ненужным проверкам типов, что может снизить производительность. Вместо
          этого позвольте TypeScript выводить типы, когда это возможно. let value: any = &laquo;Hello,
          TypeScript!&raquo;; let strLength: number = (value as&nbsp;string).length; // Avoid using &rsquo;as
          string&rsquo; if&nbsp;TypeScript can infer the type
        </p>
      </footer>
    </section>

    <section class="slide test">
      <div class="shout">
        <h2 class="text-left">Что такое<br /><span class="text-[82px]">производительность?</span></h2>
      </div>
      <footer>
        <p>
          Ощущаемая пользователем &laquo;производительность&raquo;&nbsp;&mdash; это единственная производительность,
          которая имеет значение. Пользователи взаимодействуют с&nbsp;системой с&nbsp;помощью ввода каких-то данных:
          прикосновений, движения и&nbsp;речи. В ответ, они получают реакцию, основанную на&nbsp;зрительном, тактильном
          или слуховом аппаратах. Производительность - это качество того, как система реагирует на&nbsp;действия
          пользователя.
        </p>
        <p>
          При прочих равных, код, оптимизированный для каких-то иных целей, кроме ощущаемой пользователем
          производительности (здесь и&nbsp;дальше UPP, user-perceived performance) всегда проигрывает коду, который
          оптимизирован для UPP. Упрощённо говоря, пользователи предпочитают отзывчивое и&nbsp;плавное приложение,
          которое обрабатывает 1,000 транзакций к&nbsp;базе данных в&nbsp;секунду грубому неотзывчивому приложению,
          которое обрабатывает 100,000,000 запросов в&nbsp;секунду. Конечно, это не&nbsp;означает, что другие метрики
          становятся ненужным, но&nbsp;первой вашей целью должна быть UPP.
        </p>
        <p>Следующие разделы укажут и&nbsp;объяснят некоторые метрики производительности:</p>
      </footer>
    </section>

    <section class="slide">
      <h2>📡 Подключение</h2>
      <footer>
        <p>
          Причина этому&nbsp;&mdash; в&nbsp;мобильных устройствах срабатывает задержка в&nbsp;несколько сотен
          миллисекунд между касанием экрана и&nbsp;запуском обработчика click. Из-за этого приложение может ощущаться
          медленным. Если вы&nbsp;будете тестировать ваше приложение на&nbsp;предмет работы с&nbsp;касаниями,
          вы&nbsp;не&nbsp;пожертвуете доступностью. Кроме того, существуют библиотеки, которые ускорят разработку.
          Например, Financial Times использует библиотеку Секрет быстрой загрузки требует двух вещей: UPP (ощущаемая
          пользователем скорость)&nbsp;&mdash; это единственное, что имеет значение; эта скорость зависит
          от&nbsp;критического пути рендеринга (Critical Rendering Path). Критический путь - это единственный
          и&nbsp;необходимый код, который должен запускать перечисленные выше события.
        </p>
        <p>Загрузка приложения может быть поделена на&nbsp;три этапа, которые влияют на&nbsp;UPP:</p>
        <p>
          Первая отрисовка. Момент, когда приложение загрузило достаточно данных и&nbsp;ресурсов, чтобы отрисовать
          первый - начальный&nbsp;&mdash; кадр
        </p>
        <p>
          Начало интерактивности&nbsp;&mdash; например, когда пользователю становится доступна возможность нажать
          кнопку, а приложение может ему ответить
        </p>
        <p>
          Полная загрузка&nbsp;&mdash; например, когда все пользовательские альбомы перечислены в&nbsp;музыкальном
          плеере
        </p>
        <p>
          Использование памяти&nbsp;&mdash; это отдельная ключевая метрика. В&nbsp;отличии от&nbsp;отзывчивости
          и&nbsp;частоты кадров, пользователи не&nbsp;могут напрямую почувствовать использование памяти,
          но&nbsp;её&nbsp;использование влияет на&nbsp;&laquo;состояние пользователя&raquo;.
        </p>
        <p>
          Последний показатель, который нужно упомянуть&nbsp;&mdash; это потребление энергии. Подобно использованию
          памяти, пользователь чувствует потребление энергии опосредованно, отмечая время, через которое устройство
          начинает изменять воспринимаемую пользователем производительность (UPP). Для минимизации отрицательных
          эффектов использования энергии, мы&nbsp;должны делать систему экономной.
        </p>
        <p>
          Для примера, вспомните, как работают мобильные устройства: вы&nbsp;можете включить режим энергосбережения,
          когда отключаются другие системы. Но&nbsp;есть и&nbsp;более жёсткий режим, который включается автоматически,
          когда заряд уменьшается до&nbsp;5%&nbsp;&mdash; система включает троттлинг процессора, замедляя выполнение
          всех инструкций.
        </p>
        <p>Всю оставшуюся часть статьи мы&nbsp;будем обсуждать производительность в&nbsp;свете этих показателей.</p>
      </footer>
    </section>

    <section class="slide">
      <h2>How I&nbsp;Created a&nbsp;3.78MB Docker Image for a&nbsp;JavaScript Service</h2>
      <a
        class="copyright"
        href="https://shenzilong.cn/record/How%20I%20Created%20a%203.78MB%20Docker%20Image%20for%20a%20JavaScript%20Service"
        >How I&nbsp;Created a&nbsp;3.78MB Docker Image for a&nbsp;JavaScript Service</a
      >
    </section>

    <section class="slide">
      <h2>📱 Клиент</h2>
      <footer>
        <p>Время важно</p>
        <p>
          Каждый раз, когда пользователь посещает вашу веб-страницу, он&nbsp;начинает гонку за&nbsp;получение контента
          как можно быстрее. Производительность является критическим фактором , который влияет на&nbsp;то, как
          посетители взаимодействуют с&nbsp;вашим сайтом. Некоторые могут подумать, что перемещение контента
          по&nbsp;всему миру приводит к&nbsp;значительной задержке, но&nbsp;на&nbsp;некоторое время скорость передачи
          данных в&nbsp;сети приблизилась к&nbsp;своим теоретическим пределам . Для сравнения, данные на&nbsp;Cloudflare
          могут преодолеть 11 000-километровое расстояние между Нью-Йорком и&nbsp;Лондоном примерно
          за&nbsp;76&nbsp;миллисекунд&nbsp;&mdash; быстрее, чем моргнуть глазом . Однако задержки в&nbsp;загрузке
          веб-страниц сохраняются из-за сложностей обработки запросов, ответов и&nbsp;конфигураций. В&nbsp;дополнение
          к&nbsp;продвижению достижений в&nbsp;установлении соединения , сжатии , оборудовании и&nbsp;программном
          обеспечении , мы&nbsp;создали новый способ сокращения задержки загрузки страницы, предвидя, как посетители
          будут взаимодействовать с&nbsp;данной веб-страницей.
        </p>
        <p>Я&nbsp;не&nbsp;буду говорить про оптимизацию сайта в&nbsp;целом, т.к. очень много</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
          {
            "compilerOptions": {
              "target": "ES2019",
              ...
            },
            ...
          }
        </code>
      </pre>
      <footer>
        <p>
          Если вы&nbsp;ориентируетесь на&nbsp;современные браузеры, вы&nbsp;можете выбрать &quot;ES2018&laquo;или
          &laquo;ES2019&raquo;, что может привести к&nbsp;более эффективному выводу, чем старые версии, такие как
          &laquo;ES5&raquo;.
        </p>
        <p>
          Сердцем движка V8&nbsp;являются Ignition и&nbsp;TurboFan. Ignition&nbsp;&mdash; это компонент, который
          помогает интерпретировать ваш байт-код. Как только движок получает AST, он&nbsp;отправляет это дерево
          в&nbsp;Ignition, который преобразует его в&nbsp;байт-код. Затем этот байт-код интерпретируется
          высокопроизводительным интерпретатором.
        </p>
        <p>
          Ignition имеет быстрое время запуска, а&nbsp;байт-код, который он&nbsp;производит, очень мал, поэтому
          V8&nbsp;использует его для выполнения кода при загрузке страницы. Ignition используется для редкого кода,
          потому что производительность имеет свою цену, а&nbsp;V8&nbsp;не хочет потреблять много памяти.
        </p>
        <p>
          TurboFan&nbsp;&mdash; это оптимизирующий компилятор, который компилирует ваш код в&nbsp;оптимизированный
          машинный язык. Он&nbsp;генерирует чрезвычайно быстрый машинный код. Он&nbsp;делает это с&nbsp;помощью
          предположений (мы&nbsp;вернемся к&nbsp;этому позже). Поскольку TurboFan генерирует оптимизированный машинный
          код, V8&nbsp;использует TurboFan для создания оптимизированной версии часто используемого кода.
        </p>
        <p>https://v8.github.io/tools/head/system-analyzer/index.html</p>
        <p>https://v8.github.io/tools/head/turbolizer/index.html</p>
        <p>https://v8.dev/docs/ignition</p>
        <p>https://v8.github.io/tools/head/heap-stats/index.html</p>
        <p>https://v8.github.io/tools/head/parse-processor.html</p>
        <p>https://v8.github.io/tools/head/heap-layout/index.html</p>
        <p>https://v8.github.io/tools/head/profview/index.html</p>
        <p>https://github.com/tinylibs/tinybench</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                      <code class="language-typescript">
                      {
            "compilerOptions": {
              "strict": true,
              ...
            },
            ...
          }
          </code>
          </pre>
      <footer>
        <p>
          Один из&nbsp;способов повысить производительность&nbsp;&mdash; включить strict режим в&nbsp;вашем
          tsconfig.json. Это заставляет TypeScript перехватывать больше ошибок во&nbsp;время компиляции, что, хотя это
          может показаться нелогичным, на самом деле может повысить производительность. Строго типизированный код может
          быть легче оптимизирован движками JavaScript, а&nbsp;раннее обнаружение ошибок также означает меньше времени,
          затрачиваемого на&nbsp;отладку. Это может быть полезно как для разработки, так и&nbsp;для производительности
          во&nbsp;время выполнения.
        </p>
        <p>профилирование в&nbsp;браузере</p>
        <p>
          Если вы&nbsp;профилируете в&nbsp;браузере, убедитесь, что вы&nbsp;используете чистый + пустой профиль
          браузера. Я&nbsp;даже использую для этого отдельный браузер. Если вы&nbsp;профилируете и&nbsp;у&nbsp;вас
          включены расширения браузера, они могут испортить измерения. React devtools в&nbsp;частности существенно
          повлияют на&nbsp;результаты, код рендеринга может выглядеть медленнее, чем он&nbsp;есть на&nbsp;самом деле для
          ваших пользователей.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
            <code class="language-typescript">
            По умолчанию TypeScript автоматически включает каждый @types пакет, который он находит в вашей node_modules папке, независимо от того, импортируете ли вы его. Это сделано для того, чтобы определенные вещи "просто работали" при использовании Node.js, Jasmine, Mocha, Chai и т. д., поскольку эти инструменты/пакеты не импортируются — они просто загружаются в глобальную среду.

            Иногда эта логика может замедлить время построения программы как в сценариях компиляции, так и в сценариях редактирования, и это может даже вызвать проблемы с несколькими глобальными пакетами с конфликтующими объявлениями, вызывая такие ошибки, как

            Duplicate identifier 'IteratorResult'.
            Duplicate identifier 'it'.
            Duplicate identifier 'define'.
            Duplicate identifier 'require'.
            В случаях, когда глобальный пакет не требуется, исправление так же просто, как указание пустого поля для параметра"types" в tsconfig.json/jsconfig.json

            // src/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Don't automatically include anything.
                   // Only include `@types` packages that we need to import.
                   "types" : []
               },
               "files": ["foo.ts"]
            }
            Если вам все еще нужны несколько глобальных пакетов, добавьте их в types поле.

            // tests/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Only include `@types/node` and `@types/mocha`.
                   "types" : ["node", "mocha"]
               },
               "files": ["foo.test.ts"]
            }
            </code>
            </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                    <code class="language-typescript">
            Добавление аннотаций типов, особенно возвращаемых типов, может сэкономить компилятору много работы. Отчасти это связано с тем, что именованные типы, как правило, более компактны, чем анонимные типы (которые компилятор может вывести), что сокращает время, затрачиваемое на чтение и запись файлов объявлений (например, для инкрементных сборок). Вывод типов очень удобен, поэтому нет необходимости делать это повсеместно — однако, это может быть полезно, если вы определили медленный раздел своего кода.

            - import { otherFunc } from "other";
            + import { otherFunc, OtherType } from "other";

            - export function func() {
            + export function func(): OtherType {
                  return otherFunc();
              }
            </code>
                  </pre>
    </section>

    <section class="slide">
      <h2 class="shout">🗳️ Кэширование</h2>
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://v8.dev/blog/code-caching-for-devs"
        >Code caching for devs</a
      >
      <footer>
        <p>BFCache</p>
        <p>
          Вторая категория отрывов в&nbsp;производительности связана с&nbsp;теми возможностями, которые браузеры
          предоставляют нам бесплатно, и&nbsp;тем, что мы&nbsp;редко думаем о&nbsp;кэшировании байткода
          и&nbsp;JIT-компиляции.
        </p>
        <p>
          Если при загрузке сайта второй или третий раз JS-код правильно кэширован, то&nbsp;браузеру не&nbsp;приходится
          больше парсить и&nbsp;компилировать исходный код в&nbsp;байткод. В&nbsp;таком случае он&nbsp;просто загружает
          последний напрямую с&nbsp;диска &mdash;&nbsp;это называется кэшированием байткода. Более того, если функция
          &laquo;горячая&raquo; (часто выполняется), то&nbsp;она дополнительно оптимизируется в&nbsp;машинный код. Так
          работает JIT-компиляция.
        </p>
        <p>
          Тем не&nbsp;менее, благодаря непревзойдённому Джойи Чунгу, в&nbsp;Node появилась функциональность
          &laquo;compile cache&raquo;. Теперь вы&nbsp;можете настроить переменную среды и&nbsp;сразу получить ускорение
          загрузки скриптов Node.js: export NODE_COMPILE_CACHE=~/.cache/nodejs-compile-cache
        </p>
        <p>https://github.com/nodejs/node/pull/52535</p>
      </footer>
    </section>

    <section class="slide">
      <h2>🤝 Объединить</h2>
      <footer>
        <p>
          В мире HTTP/1.1 мы могли извлекать только шесть ресурсов из заданного источника одновременно. Учитывая это
          ограничение, было выгодно иметь меньше файлов: если нам нужно было загрузить 18 файлов, это три отдельных
          фрагмента работы; если мы могли каким-то образом сократить это число до шести, это был бы только один
          отдельный фрагмент работы. Это привело к тяжелому объединению и конкатенации — зачем загружать три CSS-файла
          (половина нашего бюджета), если мы могли бы сжать их в один?
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Parallel DOM</h2>
      <a class="copyright" href="https://github.com/pdomdev/pdom">https://github.com/pdomdev/pdom</a>
    </section>

    <section class="slide">
      <h2 class="shout">Подключить CDN</h2>
    </section>

    <section class="slide">
      <h2>Доставка современного кода (tl;dr)</h2>
      <p class="next"><samp>modern.js</samp> и <samp>old.bundle.js</samp></p>
      <pre class="next">
        <code class="language-typescript">
          &lt;script type="module" src="modern.js"&gt;&lt;/script&gt;
          &lt;script no module src="old.bundle.js" defer&gt;&lt;/script&gt;
        </code>
      </pre>
      <a class="copyright" href="https://www.npmjs.com/package/size-limit">size limit</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
          // feature/index.js
          export * from "./user";
          export * from "./permissions";
          export * from "./actions";
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Загрузка только нужного вам кода</h2>
      <a class="copyright" href="https://www.npmjs.com/package/@cerner/duplicate-package-checker-webpack-plugin"
        >duplicate-package-checker-webpack-plugin</a
      >
      <a class="copyright" href="https://www.npmjs.com/package/dependency-cruiser"
        >https://www.npmjs.com/package/dependency-cruiser</a
      >
      <a href="https://www.npmjs.com/package/depcheck">https://www.npmjs.com/package/depcheck</a>
    </section>

    <section class="slide">
      <h2>node --cpu-prof $(which npm) run script</h2>
      <footer>
        <p>
          Большая часть времени тратится на загрузку всех модулей, составляющих npm cli. Время скрипта, который мы
          запускаем, меркнет в сравнении. Мы видим кучу файлов, которые кажутся необходимыми только при выполнении
          определенных условий. Примером этого может служить код для форматирования сообщений об ошибках, который
          требуется только при возникновении ошибки.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">no(po)lyfill</h2>
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://github.com/SukkaW/nolyfill"
        >https://github.com/SukkaW/nolyfill</a
      >
    </section>

    <section class="slide">
      <h2 class="" style="color: white">Анимации</h2>
      <ul>
        <li class="next">вынести на отдельный слой</li>
        <li class="next">не допускать перестройку макета</li>
        <li class="next">использовать CSS</li>
        <li class="next">использовать will-change <span class="next">(точечно)</span></li>
        <li class="next">RequestAnimationFrame</li>
      </ul>
      <div class="cover width height animated-gradient"></div>
    </section>

    <section class="slide">
      <h2 class="shout">Перфоманс CSS-селекторов</h2>
      <a class="copyright" href="https://web.dev/blog/at-property-performance" target="_blank" rel="noopener noreferrer"
        >https://web.dev/blog/at-property-performance</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Этого бывает мало...</h2>
    </section>

    <section class="slide">
      <h2 class="cover !left-0 mt-[24px] -translate-y-[50%] pl-[100px] text-left">
        <span class="text-gray">Акт 2</span> <br />Практика
      </h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <p>
        So if you work on a project which uses barrel files extensively, there is a free optimization you can apply that
        makes many tasks 60-80% faster: Get rid of all barrel files.
      </p>
      <p>
        Процентные результаты представляют собой количество операций, выполненных в&nbsp;течение 1&nbsp;с, деленное на
        количество операций в&nbsp;случае с&nbsp;наивысшей оценкой. Чем выше, тем лучше.
      </p>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                <code class="language-typescript">
                  const team = "webpractik";
                </code>
              </pre>
      <table class="mt-5">
        <thead>
          <tr class="next">
            <th>Token</th>
            <th>Token type</th>
          </tr>
        </thead>
        <tbody>
          <tr class="next">
            <td>const</td>
            <td>
              <i>Keyword</i>
            </td>
          </tr>
          <tr class="next">
            <td>num</td>
            <td>
              <i>Identifer</i>
            </td>
          </tr>
          <tr class="next">
            <td>=</td>
            <td>
              <i>Operator</i>
            </td>
          </tr>
          <tr class="next">
            <td>webpractik</td>
            <td>
              <i>String</i>
            </td>
          </tr>
        </tbody>
      </table>
      <footer>
        <p>
          Прежде чем разобрать код в&nbsp;абстрактное синтаксическое дерево, мы&nbsp;сначала преобразуем его
          в&nbsp;токены. Это преобразование происходит в&nbsp;лексическом анализе. Сканер потребляет поток символов
          Unicode, объединяет его в&nbsp;токены и&nbsp;удаляет все проблемы, переводы строк, комментарий. Эти токены
          ключевые слова токены. С&nbsp;помощью парсера V8&nbsp;токены преобразуются в&nbsp;абстрактное дерево
          и&nbsp;проверка синтаксиса языка
        </p>
        https://nolanlawson.com/2024/09/18/improving-rendering-performance-with-css-content-visibility/
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/butterfly.jpg" alt="Butterfly" width="500" height="500" />
      <a class="copyright" href="https://yandex.ru/q/science/2504230657/">https://yandex.ru/q/science/2504230657/</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <p>
        Одно из&nbsp;когнитивных искажений, проявляющееся в&nbsp;тенденции людей недооценивать последствия бездействия
        в&nbsp;сравнении с&nbsp;действием с&nbsp;аналогичным результатом. Люди более ответственно относятся к&nbsp;своим
        действиям, чем к&nbsp;бездействию.
      </p>
      <p>
        Эмпирический психофизиологический закон, заключающийся в&nbsp;том, что интенсивность ощущения чего-либо прямо
        пропорциональна логарифму интенсивности раздражителя. Иллюстрируется так: люстра, в&nbsp;которой восемь
        лампочек, кажется настолько&nbsp;же ярче люстры из&nbsp;четырёх лампочек, насколько люстра из&nbsp;четырёх
        лампочек ярче люстры из&nbsp;двух лампочек. То&nbsp;есть количество лампочек должно увеличиваться
        в&nbsp;одинаковое число раз, чтобы казалось, что прирост яркости постоянен. И&nbsp;наоборот, если абсолютный
        прирост яркости (разница в&nbsp;яркости &laquo;после&raquo; и&nbsp;&laquo;до&raquo;) постоянен, то будет
        казаться, что абсолютный прирост уменьшается по&nbsp;мере роста самого значения яркости. Например, если добавить
        одну лампочку к&nbsp;люстре из&nbsp;двух лампочек, то&nbsp;кажущийся прирост в&nbsp;яркости будет значительным.
        Если&nbsp;же добавить одну лампочку к&nbsp;люстре из&nbsp;12&nbsp;лампочек, то&nbsp;прирост яркости практически
        незаметен.
      </p>
      <p>
        Также известно как &laquo;эффект негатива&raquo;. Склонность, согласно которой одинаково интенсивные негативные
        явления (неприятные мысли, эмоции или социальные взаимодействия), имеют гораздо большее влияние
        на&nbsp;психологическое состояние человека, чем нейтральные или позитивные явления той&nbsp;же интенсивности.
        Иными словами, какое-либо позитивное событие повлияет на&nbsp;поведение человека гораздо меньше, чем негативное
        событие такой&nbsp;же силы.
      </p>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <a class="place" href="https://bloomberg.github.io/ts-blank-space/">ts-blank-space</a>
    </section>

    <section class="slide relative">
      <h2 class="shout">Benchmarking</h2>
      <p class="next absolute">Самый важный, но&nbsp;и&nbsp;сложный</p>
      <p class="next absolute">Начало кода</p>
      <p class="next absolute">Сомневаетесь в&nbsp;своих результатах</p>
      <footer>
        <p>
          Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют большую часть
          времени выполнения. Если вы&nbsp;тратите время на&nbsp;оптимизацию чего-либо еще, кроме верхней части,
          вы&nbsp;тратите время впустую.
        </p>
        <p>
          Если вы&nbsp;только что оптимизировали функцию, и&nbsp;теперь она работает в&nbsp;100 раз быстрее, усомнитесь
          в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме производства, забросайте
          ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам факт наблюдения
          за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Используйте оценку</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Производительность&nbsp;&mdash; это восприятие</h2>
    </section>

    <section class="slide">
      <h2>Чтобы пользователи не&nbsp;уходили</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <div class="highlight-blocks">
        <div class="highlight"></div>
        <div class="highlight"></div>
        <div class="highlight"></div>
        <div class="highlight"></div>
        <div class="highlight"></div>
      </div>
      <footer>
        <p>
          Стоимость взаимодействия — это сумма усилий (умственных и физических), которые пользователи должны приложить
          при взаимодействии с цифровым продуктом для достижения своих целей. В идеале мы хотели бы, чтобы пользователи
          заходили на сайт и немедленно находили ответ, который они ищут. Это означало бы нулевую стоимость
          взаимодействия и было бы святым Граалем юзабилити как поля. zero interaction cost
        </p>
      </footer>
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <iframe
        class="absolute left-1/2 top-1/2 my-2 -translate-x-1/2 -translate-y-1/2 rounded-sm"
        title="Vanilla js"
        width="700"
        height="700"
        id="iframe-vanilla-js"
      ></iframe>
      <div class="con">
        <button class="brutalist-button" type="button" id="upload-iframe">
          <span class="button-text">
            <span>Нажми на&nbsp;меня</span>
          </span>
        </button>
      </div>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          const uploadIframe = document.querySelector('#upload-iframe');
          const iframeVanillaJs = document.querySelector('#iframe-vanilla-js');

          uploadIframe.addEventListener('click', function () {
            iframeVanillaJs.src = 'http://vanilla-js.com';
            iframeVanillaJs.classList.add('z-10');
          });
        });
      </script>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/everywhere.jpg" alt="Everywhere" width="1580" height="1188" />
    </section>

    <section class="slide relative">
      <h2 class="shout">JavaScript <span class="next">(клин клином)</span></h2>
      <p
        class="next absolute translate-x-[200px] translate-y-[80px] rotate-[30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;React!
      </p>
      <p
        class="next absolute translate-x-[100px] translate-y-[400px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Vue!
      </p>
      <p
        class="next absolute translate-x-[400px] translate-y-[400px] rotate-[30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Angular!
      </p>
      <p
        class="next absolute translate-x-[500px] translate-y-[100px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;Solid!
      </p>

      <p
        class="next absolute translate-x-[500px] translate-y-[100px] rotate-[-30deg] rounded-[4px] bg-white px-2 !text-black"
      >
        Но&nbsp;я&nbsp;пишу на&nbsp;jQuery!
        <img
          class="next"
          src="./themes/tw/images/theory/tools/jquery-book.jpg"
          alt="jquery Book"
          width="547"
          height="705"
        />
      </p>
      <footer>
        <p>А&nbsp;ещё мы&nbsp;выбираем фреймворки как next.js, где многое для оптимизации из&nbsp;коробки</p>
        <p>На&nbsp;выходе всё равно js</p>
        <p>https://www.schiener.io/2024-03-03/react-closures</p>
        <p>https://www.schiener.io/2024-05-29/react-query-leaks</p>
        <p>https://github.com/CSS-Next/css-next/issues/105</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                <code class="language-typescript">
                  const startTime = Date.now();

                  doTask();

                  console.log(`Длительность выполнения: ${Date.now() - startTime} ms`);
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                <code class="language-typescript">
                  // Создание метки
                  performance.mark('task-start');

                  // Выполнение функции
                  doTask();

                  // Завершение метки
                  performance.mark('task-end');

                  // Создание измерения
                  performance.measure('task', 'task-start', 'task-end');

                  // Получение результатов
                  const perfEntries = performance.getEntriesByName('task');

                  console.log(perfEntries[0].duration);
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                <code class="language-typescript">
                  import { performance } from "node:perf_hooks";

                  console.log(performance.now());
                </code>
              </pre>
      <a class="copyright" href="https://nodejs.org/api/perf_hooks.html" target="_blank" rel="noopener noreferrer"
        >perf_hooks</a
      >
    </section>

    <section class="slide">
      <h2 class="shout"><span>===</span> <br />Сравнение строк</h2>
      <footer>
        <p>
          Javascript позволяет легко скрыть реальную стоимость сравнения строк. Если вам нужно сравнить строки в&nbsp;C,
          вы&nbsp;бы использовали функцию strcmp(a, b). Javascript использует ===вместо этого , поэтому
          вы&nbsp;не&nbsp;видите strcmp. Но&nbsp;он&nbsp;есть, и&nbsp;сравнение строк обычно (но&nbsp;не&nbsp;всегда)
          требует сравнения каждого символа в&nbsp;строке с&nbsp;символами в&nbsp;другой строке; сравнение
          строк&nbsp;&mdash; это O(n). Один из&nbsp;распространенных шаблонов JavaScript, которого следует
          избегать,&nbsp;&mdash; это строки как перечисления. Но&nbsp;с&nbsp;появлением TypeScript этого должно быть
          легко избежать, поскольку перечисления по&nbsp;умолчанию являются целыми числами.
        </p>
        <p>
          Как видите, разница может быть существенной. Разница не&nbsp;обязательно связана со&nbsp;strcmp стоимостью,
          поскольку движки иногда могут использовать пул строк и&nbsp;сравнивать по&nbsp;ссылке, но&nbsp;она также
          связана с&nbsp;тем, что целые числа обычно передаются по&nbsp;значению в&nbsp;движках&nbsp;JS, тогда как
          строки всегда передаются как указатели, а&nbsp;доступ к&nbsp;памяти является дорогостоящим (см. раздел 5).
          В&nbsp;коде с&nbsp;большим количеством строк это может иметь огромное влияние. В&nbsp;качестве примера
          из&nbsp;реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в&nbsp;2&nbsp;раза быстрее
          *, просто заменив строковые константы числами. *К&nbsp;сожалению, он&nbsp;не&nbsp;был объединен, но&nbsp;таков
          принцип работы с&nbsp;открытым исходным кодом.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
                <code class="language-typescript">
                  // #1
                  enum Position {
                    TOP    = 'TOP',
                    BOTTOM = 'BOTTOM',
                  }

                  // #2
                  enum Position {
                    TOP,    // = 0
                    BOTTOM, // = 1
                  }
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
                <code class="language-typescript">
                  let _ = 0;

                  for (let i = 0; i < 1000000; i++) {
                    let current = i % 2 === 0 ? Position.TOP : Position.BOTTOM;

                    if (current === Position.TOP) {
                      _ += 1;
                    }
                  }
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="string" percentage="50"></custom-scale>
        <custom-scale name="int" percentage="95"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">
        <span>△ ▢</span> <br />
        Избегайте разных форм
      </h2>
      <footer>
        <p>
          Движки Javascript пытаются оптимизировать код, предполагая, что объекты имеют определенную форму, и&nbsp;что
          функции будут получать объекты той&nbsp;же формы. Это позволяет им&nbsp;хранить ключи формы один раз для всех
          объектов этой формы, а&nbsp;значения&nbsp;&mdash; в&nbsp;отдельном плоском массиве. Чтобы представить это
          в&nbsp;javascript:
        </p>
        <p>
          Я&nbsp;использовал слово &laquo;форма&raquo; для описания этой концепции, но&nbsp;имейте в&nbsp;виду, что
          вы&nbsp;также можете встретить термины &laquo;скрытый класс&raquo; или &laquo;карта&raquo; для
          ее&nbsp;описания, в&nbsp;зависимости от&nbsp;движка.
        </p>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
        <p>
          Движки обычно могут кодировать целые числа как значения. Например, V8&nbsp;представляет значения
          в&nbsp;32&nbsp;битах, причем целые числа представляют собой компактные значения Smi (SMall Integer),
          но&nbsp;числа с&nbsp;плавающей точкой и&nbsp;большие целые числа передаются как указатели, как строки
          и&nbsp;объекты. JSC использует 64-битное кодирование, двойное тестирование , чтобы передавать все числа
          по&nbsp;значению, как это делает SpiderMonkey, а&nbsp;остальное передается как указатели.
        </p>
        <p>https://github.com/facebook/react/pull/28569</p>
        <p>
          Что, черт возьми, мне с&nbsp;этим делать? Легче сказать, чем сделать, но: создайте все свои объекты
          с&nbsp;одинаковой формой . Даже что-то столь тривиальное, как написание свойств компонента React в&nbsp;другом
          порядке, может вызвать это . Например, вот простые случаи, которые я&nbsp;нашел в&nbsp;кодовой базе React,
          но&nbsp;у&nbsp;них уже был случай с&nbsp;гораздо более сильным влиянием той&nbsp;же проблемы несколько лет
          назад, потому что они инициализировали объект целым числом, а&nbsp;затем сохраняли число с&nbsp;плавающей
          точкой. Да, изменение типа также меняет форму. Да, есть целые и&nbsp;плавающие типы, скрытые за&nbsp;number.
          Разберитесь с&nbsp;этим.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
                <code class="language-typescript">
                  // Вводные
                  const objects = [
                    {
                      name: 'Анатолий',
                      age: 36,
                    },
                    {
                      name: 'Иннокентий',
                      age: 42
                    },
                  ];
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place w-[90%]">
              <code class="language-typescript">
                  const shape = [
                    { name: 'name', type: 'string' },
                    { name: 'age',  type: 'integer' },
                  ];

                  const objects = [
                    ['Анатолий', 36],
                    ['Иннокентий', 42],
                  ];
              </code>
            </pre>
      <footer>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                <code class="language-typescript">
                  function add(a, b) {
                    return {
                      x: a.x + b.x,
                      y: a.y + b.y
                    }
                  }
                </code>
              </pre>
      <footer>
        <p>
          Например, если во&nbsp;время выполнения следующая функция получает два объекта с&nbsp;формой { x: number, y:
          number }, движок предположит, что будущие объекты будут иметь такую ​​же форму, и&nbsp;сгенерирует машинный
          код, оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не&nbsp;с&nbsp;формой, { x, y }а с&nbsp;формой { y, x }, движку нужно будет
          отменить свое предположение, и&nbsp;функция внезапно станет значительно медленнее. Я&nbsp;собираюсь ограничить
          свое объяснение здесь, потому что вам следует прочитать превосходный пост от&nbsp;mraleph, если вы&nbsp;хотите
          больше подробностей, но&nbsp;я&nbsp;собираюсь подчеркнуть, что&nbsp;V8, в&nbsp;частности, имеет 3&nbsp;режима
          для доступа, которые являются: мономорфный (1&nbsp;форма), полиморфный (2-4&nbsp;формы) и&nbsp;мегаморфный
          (5+&nbsp;форм). Допустим, вы&nbsp;действительно хотите оставаться мономорфным, потому что замедление
          радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                <code class="language-typescript">
                  // Вводные
                  let _ = 0;

                  // Monomorphic
                  const o1 = { a: 1, b: _, c: _, d: _ };
                  const o2 = { a: 1, b: _, c: _, d: _ };
                  const o3 = { a: 1, b: _, c: _, d: _ };
                  const o4 = { a: 1, b: _, c: _, d: _ };

                  // Polymorphic
                  const o1 = { a: 1, b: _, c: _, d: _ };
                  const o2 = { a: 1, b: _, c: _, d: _ };
                  const o3 = { a: 1, b: _, c: _, d: _ };
                  const o4 = { a: 1, b: _, c: _, d: _ };
                </code>
              </pre>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html"
        >monomorphism</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                <code class="language-typescript">
                  // Вводные
                  let _ = 0;

                  // Megamorphic
                  const o1 = { a: 1, b: _, c: _, d: _ };
                  const o2 = { b: _, a: 1, c: _, d: _ };
                  const o3 = { b: _, c: _, a: 1, d: _ };
                  const o4 = { b: _, c: _, d: _, a: 1 };
                </code>
              </pre>
      <a
        class="copyright"
        target="_blank"
        rel="noopener noreferrer"
        href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html"
        >monomorphism</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                <code class="language-typescript">
                  function add(a1, b1) {
                    return a1.a + a1.b + a1.c + a1.d +
                           b1.a + b1.b + b1.c + b1.d;
                  }

                  let result = 0;

                  for (let i = 0; i < 1000000; i++) {
                    result += add(o1, o2);
                    result += add(o3, o4);
                  }
                </code>
              </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="megamorphic" percentage="4"></custom-scale>
        <custom-scale name="polymorphic" percentage="13"></custom-scale>
        <custom-scale name="monomorphism" percentage="100"></custom-scale>
      </div>
    </section>
    <section class="slide">
      <div class="shout flex flex-col items-center">
        <h2>
          <span>[...] {...}</span> <br />
          Избегайте методов<br />массивов/объектов
        </h2>
      </div>
      <footer>
        <p>нет, вы&nbsp;не&nbsp;зря сдавали или будете сдавть компитишн про методы массивов</p>
      </footer>
    </section>

    <section class="slide relative">
      <h2 class="sr-only">Test</h2>
      <img
        class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%]"
        src="./themes/tw/images/practice/skills-team/1.jpg"
        alt="Skills team 1"
        width="392"
        height="137"
      />
      <img
        class="next translate-x-[450px] translate-y-[150px] rotate-[30deg]"
        src="./themes/tw/images/practice/skills-team/2.jpg"
        alt="Skills team 2"
        width="356"
        height="123"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                  <code class="language-typescript">
                    // Вводные
                    const numbers = Array.from({ length: 10_000 }).map(() => Math.random());

                    // 1. functional
                    const result =
                      numbers.map(n => Math.round(n * 10))
                             .filter(n => n % 2 === 0)
                             .reduce((a, n) => a + n, 0);

                    // 2. imperative
                    let result = 0;

                    for (let i = 0; i < numbers.length; i++) {
                      let n = Math.round(numbers[i] * 10);
                      if (n % 2 !== 0) continue;

                      result = result + n;
                    }
                  </code>
                </pre>
      <footer>
        <p>
          Я&nbsp;люблю функциональное программирование так&nbsp;же, как и&nbsp;все остальные, но&nbsp;если
          вы&nbsp;не&nbsp;работаете с&nbsp;Haskell/OCaml/Rust, где функциональный код компилируется в&nbsp;эффективный
          машинный код, то&nbsp;функциональное программирование всегда будет медленнее императивного.
        </p>
        <p>Проблема с&nbsp;этими методами заключается в&nbsp;следующем:</p>
        <p>
          Им&nbsp;нужно сделать полную копию массива, и&nbsp;эти копии позже должны быть освобождены сборщиком мусора.
          Мы&nbsp;более подробно рассмотрим вопросы ввода-вывода памяти в&nbsp;разделе 5.
        </p>
        <p>
          Они выполняют цикл&nbsp;N раз для&nbsp;N операций, тогда как for цикл допускает выполнение цикла один раз.
        </p>
        <p>
          Методы объектов, такие как Object.values(), Object.keys()и Object.entries()страдают от&nbsp;похожих проблем,
          так как они также выделяют больше данных, а&nbsp;доступ к&nbsp;памяти является корнем всех проблем
          с&nbsp;производительностью. Нет, правда, я&nbsp;клянусь, я&nbsp;покажу вам в&nbsp;разделе 5.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="функциональный" percentage="36"></custom-scale>
        <custom-scale name="императивный" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">AI&nbsp;assistance panel</h2>
      <a href="https://developer.chrome.com/docs/devtools/ai-assistance?hl=ru"
        >https://developer.chrome.com/docs/devtools/ai-assistance?hl=ru</a
      >
      <footer>
        <p>важно для проекта важно для впс</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="next" src="./themes/tw/images/theory/tools/vite.svg" alt="vite" width="32" height="32" />
      <img class="next" src="./themes/tw/images/theory/tools/brunch.svg" alt="brunch" width="256" height="256" />
      <img class="next" src="./themes/tw/images/theory/tools/rolldown.svg" alt="rolldown" width="300" height="300" />
      <img class="next" src="./themes/tw/images/theory/tools/rollup.svg" alt="rollup" width="16" height="16" />
      <img class="next" src="./themes/tw/images/theory/tools/rsbuild.svg" alt="rsbuild" width="16" height="16" />
      <img class="next" src="./themes/tw/images/theory/tools/webpack.svg" alt="Webpack" width="16" height="16" />
    </section>

    <section class="slide">
      <h2>Analyzing Notion app performance</h2>
      <a href="https://3perf.com/blog/notion/">https://3perf.com/blog/notion/</a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <a href="https://github.com/iamakulov/awesome-webpack-perf">https://github.com/iamakulov/awesome-webpack-perf</a>
    </section>

    <section class="slide">
      <h2>Custom DevTools</h2>
      <a class="copyright" href="https://github.com/coryhouse/react-switchboard?tab=readme-ov-file"
        >https://github.com/coryhouse/react-switchboard?tab=readme-ov-file</a
      >
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="!m-0">Используйте eval</h2>
        <picture class="ml-2">
          <source srcset="./themes/tw/pictures/emoji/evil.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/evil.gif" alt="😈" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>
          Некоторые шаблоны javascript трудно оптимизировать для движков, и&nbsp;с&nbsp;помощью использования eval() или
          его производных вы&nbsp;можете заставить эти шаблоны исчезнуть. В&nbsp;этом примере мы&nbsp;можем наблюдать,
          как использование eval()позволяет избежать затрат на&nbsp;создание объекта с&nbsp;динамическим ключом объекта:
        </p>
        <p>
          Другим хорошим вариантом использования eval может быть компиляция функции предиката фильтра, где вы
          отбрасываете ветви, которые, как вы&nbsp;знаете, никогда не&nbsp;будут выполнены. В&nbsp;общем, любая функция,
          которая будет запущена в&nbsp;очень горячем цикле, является хорошим кандидатом для такого рода оптимизации.
        </p>
        <p>
          Очевидно, что обычные предупреждения eval()применимы: не&nbsp;доверяйте пользовательскому вводу, очищайте все,
          что передается в&nbsp;eval()&rsquo;d-код, и&nbsp;не&nbsp;создавайте никаких возможностей XSS. Также обратите
          внимание, что некоторые среды не&nbsp;разрешают доступ к&nbsp;eval(), например, страницы браузера с&nbsp;CSP.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // С&nbsp;eval
                    const key = "requestId";
                    const values = Array.from({ length: 100_000 }).fill(42);

                    function createMessages(key, values) {
                      const messages = []
                      for (let i = 0; i < values.length; i++) {
                        messages.push({ [key]: values[i] })
                      }
                      return messages
                    }

                    createMessages(key, values);
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                  <code class="language-typescript">
                    // Без eval
                    const key = "requestId";
                    const values = Array.from({ length: 100_000 }).fill(42)

                    function createMessages(key, values) {
                      const messages = [];
                      const createMessage = new Function('value',
                        `return { ${JSON.stringify(key)}: value }`
                      )
                      for (let i = 0; i < values.length; i++) {
                        messages.push(createMessage(values[i]))
                      }
                      return messages
                    }

                    createMessages(key, values)
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Используйте строки <span class="next text-gray">, осторожно</span></h2>
      <footer>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST (https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)&nbsp;&mdash; так,
          чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном уровне по&nbsp;мере его роста
          и&nbsp;выполнять такие операции, как поиск, как можно быстрее.
        </p>
        <p>
          Мы&nbsp;уже видели выше, что строки дороже, чем кажутся. Ну, у&nbsp;меня тут есть своего рода ситуация
          хороших/плохих новостей, которую я&nbsp;объявлю в&nbsp;единственном логическом порядке (сначала плохие, потом
          хорошие): строки сложнее, чем кажутся, но&nbsp;их&nbsp;также можно довольно эффективно использовать.
        </p>
        <p>
          Строковые операции являются основной частью JavaScript из-за его контекста. Чтобы оптимизировать код,
          насыщенный строками, движки должны были быть креативными. Под этим я&nbsp;подразумеваю, что они должны были
          представлять String объект с&nbsp;помощью множественного строкового представления в&nbsp;C++,
          в&nbsp;зависимости от&nbsp;варианта использования. Есть два общих случая, о&nbsp;которых вам следует
          беспокоиться, поскольку они справедливы для&nbsp;V8 (наиболее распространенного движка на&nbsp;сегодняшний
          день), а&nbsp;также, как правило, и&nbsp;для других движков.
        </p>
        <p>
          Но&nbsp;вот в&nbsp;чем проблема: как только вам нужно начать мутировать эти байты, в&nbsp;этот момент
          вы&nbsp;начинаете платить за&nbsp;копирование. Допустим, мы&nbsp;возвращаемся к&nbsp;нашему String классу
          и&nbsp;пытаемся добавить .trimEnd метод:
        </p>
        <p>Что, черт возьми, мне с&nbsp;этим делать?</p>
        <p>
          В&nbsp;общем, старайтесь избегать мутаций как можно дольше.trim() . Это включает такие методы , как
          .replace(), и&nbsp;т.&nbsp;д. Подумайте, как можно избежать этих методов. В&nbsp;некоторых движках шаблоны
          строк также могут быть медленнее, чем +. В&nbsp;V8&nbsp;на данный момент это так, но&nbsp;может не&nbsp;быть
          в&nbsp;будущем, поэтому, как всегда, бенчмарк.
        </p>
        <p>
          Примечание SlicedString выше: следует отметить, что если в&nbsp;памяти находится небольшая подстрока очень
          большой строки,это может бытьне позволяйте сборщику мусора собирать большую строку! Если вы&nbsp;обрабатываете
          большие тексты и&nbsp;извлекаете из&nbsp;них маленькие строки, вы&nbsp;можете допустить утечку большого объема
          памяти.
        </p>
        <p>
          Решение здесь&nbsp;&mdash; использовать методы мутации в&nbsp;наших интересах. Если мы&nbsp;используем один
          из&nbsp;них на&nbsp;small, это приведет к&nbsp;принудительному копированию, и&nbsp;старый указатель
          на&nbsp;largeбудет потерян:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const classNames = ['primary', 'selected', 'active', 'medium']
                    // 1. mutation
                    const result =
                      classNames
                        .map(c => `button--${c}`)
                        .join(' ')
                    // 2. concatenation
                    const result =
                      classNames
                        .map(c => 'button--' + c)
                        .reduce((acc, c) => acc + ' ' + c, '')
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const large = Array.from({ length: 10_000 }).map(() => 'string').join('')
                    const small = large.slice(0, 50)
                    //  ^ will keep `large` alive
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // replace a token that doesn't exist
                    const small = small.replace('#'.repeat(small.length + 1), '')
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="">
        <custom-scale name="mutation" percentage="37"></custom-scale>
        <custom-scale name="concatenation" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Косвенность</h2>
      <footer>
        <p>
          Еще одним местом, где можно искать выгоды от&nbsp;оптимизации, является любой источник косвенности,
          из&nbsp;которых я&nbsp;вижу 3&nbsp;основных источника:
        </p>
        <p>
          Тест proxy на&nbsp;V8&nbsp;сейчас особенно жесток. В&nbsp;последний раз, когда я&nbsp;проверял, объекты proxy
          всегда откатывались от&nbsp;JIT к&nbsp;интерпретатору, судя по&nbsp;этим результатам, это все еще может быть
          так.
        </p>
        <p>
          Я&nbsp;также хотел продемонстрировать доступ к&nbsp;глубоко вложенному объекту по&nbsp;сравнению с&nbsp;прямым
          доступом, но&nbsp;движки очень хорошо оптимизируют доступ к&nbsp;удаленным объектам с&nbsp;помощью анализа
          выхода, когда есть горячий цикл и&nbsp;постоянный объект. Я&nbsp;вставил немного косвенности, чтобы
          предотвратить это
        </p>
        <a
          target="_blank"
          rel="noopener noreferrer"
          href="https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be"
          >https://www.youtube.com/watch?t=1055&amp;v=KiWEWLwQ3oI&amp;feature=youtu.be</a
        >
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const point = new Proxy({ x: 10, y: 20 }, { get: (t, k) => t[k] })

                    for (let _ = 0, i = 0; i < 100_000; i++) { _ += point.x }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const point = { x: 10, y: 20 }
                    const x = point.x

                    for (let _ = 0, i = 0; i < 100_000; i++) { _ += x }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div class="">
        <custom-scale name="proxy" percentage="2"></custom-scale>
        <custom-scale name="direct" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const a = { state: { center: { point: { x: 10, y: 20 } } } }
                    const b = { state: { center: { point: { x: 10, y: 20 } } } }
                    const get = (i) => i % 2 ? a : b

                    let result = 0
                    for (let i = 0; i < 100_000; i++) {
                      result = result + get(i).state.center.point.x }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // 2. direct access
                    const a = { x: 10, y: 20 }.x
                    const b = { x: 10, y: 20 }.x
                    const get = (i) => i % 2 ? a : b

                    let result = 0
                    for (let i = 0; i < 100_000; i++) {
                      result = result + get(i) }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="nested" percentage="42"></custom-scale>
        <custom-scale name="direct" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте промахов кэша</h2>
      <footer>
        <p>
          Этот момент требует некоторых низкоуровневых знаний, но&nbsp;имеет последствия даже в&nbsp;javascript, поэтому
          я&nbsp;объясню. С&nbsp;точки зрения&nbsp;ЦП, извлечение памяти из&nbsp;ОЗУ происходит медленно. Для ускорения
          используются в&nbsp;основном две оптимизации.
        </p>
        <p>
          5.1 Предварительная выборка Первый&nbsp;&mdash; предварительная выборка: она заранее извлекает больше памяти
          в&nbsp;надежде, что это именно та&nbsp;память, которая вас интересует. Она всегда предполагает, что если
          вы&nbsp;запросите один адрес памяти, вас будет интересовать область памяти, которая идет сразу за&nbsp;ним.
          Поэтому последовательный доступ к&nbsp;данным&nbsp;&mdash; это ключ. В&nbsp;следующем примере мы&nbsp;можем
          наблюдать влияние доступа к&nbsp;памяти в&nbsp;случайном порядке.
        </p>
        <p>
          Этот аспект, вероятно, сложнее всего реализовать на&nbsp;практике, поскольку javascript не&nbsp;имеет способа
          размещения объектов в&nbsp;памяти, но&nbsp;вы&nbsp;можете использовать это знание в&nbsp;своих интересах, как
          в&nbsp;примере выше, например, для работы с&nbsp;данными перед их&nbsp;переупорядочением или сортировкой.
          Вы&nbsp;не&nbsp;можете предполагать, что объекты, созданные последовательно, останутся в&nbsp;том&nbsp;же
          месте через некоторое время, потому что сборщик мусора может переместить&nbsp;их. Есть одно исключение
          из&nbsp;этого, и&nbsp;это массивы чисел, предпочтительно TypedArray экземпляры:
        </p>
        <p>
          Безжалостно устраняйте все данные или выделения памяти , которые можно устранить. Чем меньше ваш набор данных,
          тем быстрее будет работать ваша программа. Ввод-вывод памяти является узким местом для&nbsp;95% программ.
          Другой хорошей стратегией может быть разделение вашей работы на&nbsp;части и&nbsp;обеспечение работы
          с&nbsp;небольшим набором данных за&nbsp;раз.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // setup:
                    const K = 1024
                    const length = 1 * K * K

                    // Theses points are created one after the other, so they are allocated
                    // sequentially in memory.
                    const points = new Array(length)
                    for (let i = 0; i < points.length; i++) {
                      points[i] = { x: 42, y: 0 }
                    }

                    // This array contains the *same data* as above, but shuffled randomly.
                    const shuffledPoints = shuffle(points.slice())
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // 1. sequential
                    let _ = 0
                    for (let i = 0; i < points.length; i++) { _ += points[i].x }

                    // 2. random
                    let _ = 0
                    for (let i = 0; i < shuffledPoints.length; i++) { _ += shuffledPoints[i].x }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="sequential" percentage="100"></custom-scale>
        <custom-scale name="random" percentage="26"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте крупных предметов</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    const USERS_LENGTH = 100_000
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // setup:
                    const USERS_LENGTH = 1_000;

                    // setup:
                    const byId = {}
                    Array.from({ length: USERS_LENGTH }).forEach((_, id) => {
                      byId[id] = { id, name: 'John'}
                    })

                    let _ = 0

                    // 1. [] access
                    Object.keys(byId).forEach(id => { _ += byId[id].id })

                    // 2. direct access
                    Object.values(byId).forEach(user => { _ += user.id })
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="[]" percentage="43"></custom-scale>
        <custom-scale name="direct" percentage="100"></custom-scale>
      </div>
      <footer>
        <p>
          Как показано выше, избегайте частой индексации в&nbsp;больших объектах. Предпочитайте заранее превратить
          объект в&nbsp;массив. Организация данных для получения идентификатора в&nbsp;модели может помочь, так как
          вы&nbsp;можете использовать Object.values()и не&nbsp;обращаться к&nbsp;карте ключей, чтобы получить
          идентификатор.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Специализация</h2>
      <footer>
        <p>
          Одной из&nbsp;важных концепций оптимизации производительности является специализация : адаптация вашей логики
          для соответствия ограничениям вашего конкретного варианта использования. Обычно это означает выяснение того,
          какие условия, скорее всего, будут верны для вашего случая, и&nbsp;кодирование для этих условий. Допустим,
          мы&nbsp;торговец, которому иногда нужно добавлять теги в&nbsp;список продуктов. Мы&nbsp;знаем по&nbsp;опыту,
          что наши теги обычно пустые. Зная эту информацию, мы&nbsp;можем специализировать нашу функцию для этого случая
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // 1. not specialized
                    for (let i = 0; i < 100; i++) {
                      productsToString(descriptions, someTags)
                      productsToString(descriptions, noTags)
                      productsToString(descriptions, noTags)
                      productsToString(descriptions, noTags)
                      productsToString(descriptions, noTags)
                    }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre class="place">
                  <code class="language-typescript">
                    // 2. specialized
                    for (let i = 0; i < 100; i++) {
                      productsToStringSpecialized(descriptions, someTags)
                      productsToStringSpecialized(descriptions, noTags)
                      productsToStringSpecialized(descriptions, noTags)
                      productsToStringSpecialized(descriptions, noTags)
                      productsToStringSpecialized(descriptions, noTags)
                    }
                  </code>
                </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                            <code class="language-typescript">
                              const descriptions = ['apples', 'oranges', 'bananas', 'seven']
                    const someTags = {
                      apples: '::promotion::',
                    }
                    const noTags = {}

                    // Turn the products into a string, with their tags if applicable
                    function productsToString(description, tags) {
                      let result = ''
                      description.forEach(product => {
                        result += product
                        if (tags[product]) result += tags[product]
                        result += ', '
                      })
                      return result
                    }
                            </code>
                          </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                            <code class="language-typescript">
                              // Specialize it now
                              function productsToStringSpecialized(description, tags) {
                                // We know that `tags` is likely to be empty, so we check
                                // once ahead of time, and then we can remove the `if` check
                                // from the inner loop
                                if (isEmpty(tags)) {
                                  let result = ''
                                  description.forEach(product => {
                                    result += product + ', '
                                  })
                                  return result
                                } else {
                                  let result = ''
                                  description.forEach(product => {
                                    result += product
                                    if (tags[product]) result += tags[product]
                                    result += ', '
                                  })
                                  return result
                                }
                              }
                              function isEmpty(o) { for (let _ in o) { return false } return true }
                            </code>
                          </pre>
      <footer>
        <p>
          Этот тип оптимизации может дать вам умеренные улучшения, но&nbsp;они будут накапливаться. Они являются хорошим
          дополнением к&nbsp;более важным оптимизациям, таким как формы и&nbsp;ввод-вывод памяти. Но&nbsp;учтите, что
          специализация может обернуться против вас, если ваши условия изменятся, поэтому будьте осторожны,
          применяя&nbsp;ее.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Бесплатных функций в&nbsp;программных продуктах не&nbsp;бывает</h2>
      <footer>
        <p>
          Бесплатных&quot; функций в&nbsp;программных продуктах просто не&nbsp;бывает. Если рассматривать материальную
          сторону, то&nbsp;любые ненужные, но&nbsp;фактически реализованные &laquo;фичи&raquo; оплачиваются либо
          Заказчиком (в&nbsp;бюджет закладываются расходы на&nbsp;те&nbsp;функции, которые не&nbsp;нужны), либо
          Исполнителем из&nbsp;прибыли по&nbsp;проекту. И&nbsp;тот, и&nbsp;другой варианты с&nbsp;точки зрения бизнеса
          неверны. Если&nbsp;же говорить о&nbsp;нематериальных затратах, то&nbsp;любые &laquo;бонусные&raquo;
          возможности усложняют сопровождение, увеличивают вероятность ошибок и&nbsp;усложняют взаимодействие
          с&nbsp;продуктом,&nbsp;&mdash; между объёмом кодовой базы и&nbsp;описанными характеристиками есть прямая
          зависимость. Больше написанного кода&nbsp;&mdash; труднее сопровождать и&nbsp;выше вероятность появления
          &laquo;багов&raquo;.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Структуры данных</h2>
      <footer>
        <p>
          Я&nbsp;не&nbsp;буду вдаваться в&nbsp;подробности о&nbsp;структурах данных, так как они требуют отдельного
          поста. Но&nbsp;имейте в&nbsp;виду, что использование некорректных структур данных для вашего варианта
          использования может иметь большее влияние, чем любая из&nbsp;оптимизаций выше.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                              <code class="language-typescript">
                                // setup:
                      const userIds = Array.from({ length: 1_000 }).map((_, i) => i)
                      const adminIdsArray = userIds.slice(0, 10)
                      const adminIdsSet = new Set(adminIdsArray)
                      // 1. Array
                      let _ = 0
                      for (let i = 0; i < userIds.length; i++) {
                        if (adminIdsArray.includes(userIds[i])) { _ += 1 }
                      }
                      // 2. Set
                      let _ = 0
                      for (let i = 0; i < userIds.length; i++) {
                        if (adminIdsSet.has(userIds[i])) { _ += 1 }
                      }
                              </code>
                            </pre>
      <footer>
        <p>
          Но&nbsp;для быстрого примера давайте сравним, как Array.includes работает функция against Set.has для
          небольшого списка
        </p>
        <p>
          Я&nbsp;оставил этот раздел напоследок по&nbsp;одной причине: мне нужно было завоевать доверие с&nbsp;помощью
          забавных разделов выше. Теперь, когда у&nbsp;меня (надеюсь) это есть, позвольте мне сказать вам, что
          бенчмаркинг&nbsp;&mdash; самая важная часть оптимизации. Он&nbsp;не&nbsp;только самый важный,
          но&nbsp;и&nbsp;сложный . Даже после 20&nbsp;лет опыта я&nbsp;все еще иногда создаю бенчмарки, которые
          несовершенны, или неправильно использую инструменты профилирования. Поэтому, что&nbsp;бы
          вы&nbsp;ни&nbsp;делали, пожалуйста, приложите максимум усилий для правильного бенчмаркинга . 11.0 Начните
          с&nbsp;самого верха Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют
          большую часть времени выполнения. Если вы&nbsp;тратите время на&nbsp;оптимизацию чего-либо еще, кроме верхней
          части, вы&nbsp;тратите время впустую.&nbsp;11.1 Избегайте микро-бенчмарков Запустите свой код в&nbsp;режиме
          производства и&nbsp;основывайте свои оптимизации на&nbsp;этих наблюдениях. Движки JS&nbsp;очень сложны
          и&nbsp;часто ведут себя по-разному в&nbsp;микро-бенчмарках, чем в&nbsp;реальных сценариях. Например, возьмем
          этот микро-бенчмарк:
        </p>
        <p>https://darksi.de/d.sea-of-nodes/</p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="array" percentage="32"></custom-scale>
        <custom-scale name="set" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте работы</h2>
      <footer>
        <p>
          Это может показаться очевидным, но&nbsp;это должно быть здесь, потому что не&nbsp;может быть другого первого
          шага к&nbsp;оптимизации: если вы&nbsp;пытаетесь оптимизировать, вы&nbsp;должны сначала рассмотреть возможность
          избегания работы. Это включает в&nbsp;себя такие концепции, как мемоизация, лень и&nbsp;инкрементальные
          вычисления. Это будет применяться по-разному в&nbsp;зависимости от&nbsp;контекста. В&nbsp;React, например, это
          будет означать применение memo()и useMemo()других применимых примитивов.
        </p>
        <p>
          Я&nbsp;часто чувствую, что код javascript в&nbsp;целом работает гораздо медленнее, чем мог&nbsp;бы, просто
          потому, что он&nbsp;не&nbsp;оптимизирован должным образом. Вот сводка распространенных методов оптимизации,
          которые я&nbsp;нашел полезными. Обратите внимание, что компромиссом для производительности часто является
          читаемость, поэтому вопрос о&nbsp;том, когда выбирать между производительностью и&nbsp;читаемостью, остается
          на&nbsp;усмотрение читателя. Я&nbsp;также отмечу, что разговор об&nbsp;оптимизации обязательно требует
          разговора о&nbsp;бенчмаркинге. Микрооптимизация функции в&nbsp;течение нескольких часов, чтобы она работала
          в&nbsp;100 раз быстрее, бессмысленна, если функция изначально представляла лишь часть фактического общего
          времени выполнения. Если вы&nbsp;оптимизируете, первым и&nbsp;самым важным шагом является бенчмаркинг.
          Я&nbsp;рассмотрю эту тему в&nbsp;последующих пунктах. Также имейте в&nbsp;виду, что микробенчмарки часто имеют
          недостатки, и&nbsp;это может включать&nbsp;те, что представлены здесь. Я&nbsp;сделал все возможное, чтобы
          избежать этих ловушек, но&nbsp;не&nbsp;применяйте слепо ни&nbsp;один из&nbsp;пунктов, представленных здесь,
          без бенчмаркинга.
        </p>
        <p>
          Я&nbsp;включил примеры запуска для всех случаев, где это возможно. По&nbsp;умолчанию они показывают
          результаты, которые я&nbsp;получил на&nbsp;своей машине (brave 122&nbsp;на archlinux), но&nbsp;вы&nbsp;можете
          запустить их&nbsp;самостоятельно. Как&nbsp;бы мне ни&nbsp;было неприятно это говорить, Firefox немного отстал
          в&nbsp;плане оптимизации и&nbsp;на&nbsp;данный момент представляет собой очень малую часть трафика , поэтому
          я&nbsp;не&nbsp;рекомендую использовать результаты, которые вы&nbsp;получите на&nbsp;Firefox, в&nbsp;качестве
          полезных индикаторов.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">
        &rsquo;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&laquo;&rsquo;
      </h2>
      <footer>
        <p>
          мобильные браузеры будут ждать около 300&nbsp;мс с&nbsp;момента нажатия кнопки, чтобы запустить событие click.
          Причина этого в&nbsp;том, что браузер ждет, чтобы увидеть, действительно&nbsp;ли вы&nbsp;выполняете двойное
          нажатие
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">В&nbsp;чём разница между типом и&nbsp;интерфейсом?</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Что быстрее типы или интерфейсы?</h2>
      <footer>
        <p>Предпочитайте интерфейсы пересечениям</p>
        <p>Отношения типов между интерфейсами кешируется, в&nbsp;отличие от&nbsp;типов пересения.</p>
        <p>
          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как
          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют
          самобалансирующиеся BST (https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree)&nbsp;&mdash; так,
          чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном уровне по&nbsp;мере его роста
          и&nbsp;выполнять такие операции, как поиск, как можно быстрее.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/ts/perfomance.jpg"
        width="1001"
        height="996"
        alt="Perfomance"
      />
    </section>

    <section class="slide">
      <h2 class="shout">Как найти неиспользуемые типы?</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/diagram.jpg" alt="Diagram" width="1221" height="658" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/numbers.jpg" alt="Numbers" width="1920" height="1080" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/stats.jpg" alt="Stats" width="1195" height="1181" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/v8-js-wasm.jpg" alt="V8 js wasm" width="842" height="517" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/www.jpg" alt="WWW" width="1280" height="730" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/tools/autocannon.jpg"
        alt="Autocannon"
        width="2401"
        height="601"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/browser.jpg" alt="Browser" width="2060" height="1160" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/deno-v2.jpg" alt="Deno v2" width="1280" height="720" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/png2jpg.zip" alt="png2jpg" width="1921" height="1080" />
    </section>

    <section class="slide">
      <h2>Использование аннотирования типов</h2>
      <pre>
                    <code class="language-typescript">
                    - import { otherFunc } from "other";
                    + import { otherFunc, otherType } from "other";

                    - export function func() {
                    + export function func(): otherType {
                          return otherFunc();
                      }
                  </code>
                </pre>
      <footer>
        <p>
          Добавление аннотирования типов, особенно для возвращаемых значений, может сэкономить компилятору кучу работы.
          Отчасти потому, что именованные типы обычно компактнее анонимных (которые компилятор может приводить), что
          уменьшает время на&nbsp;чтение и&nbsp;запись объявляющих файлов (например, для инкрементальных сборок).
          Приведение типов очень удобно, так что нет нужды делать это универсально. Но&nbsp;бывает полезно попробовать,
          когда находишь в&nbsp;своём коде медленные фрагменты.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">d.ts</h2>
      <footer>
        <p>
          Анализ .d.ts файлов происходит намного быстрее, поскольку они содержат только биты, необходимые для проверки
          типов по&nbsp;сравнению с&nbsp;обычным .ts файлом. .d.tsФайл не&nbsp;содержит тел функций или других вещей,
          только определения типов, необходимые для использования модуля.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
          // Input: add.ts
const SOME_NUMBER = 10;
export function quickMath(a: number, b: number) {
	return a + b + SOME_NUMBER;
}

// Output: add.d.ts, contains only the bits needed for type checking
export function quickMath(a: number, b: number): number;
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Контроль за&nbsp;добавлением @types</h2>
      <pre>
                          <code class="language-typescript">
                            // src/tsconfig.json
                              {
                                 "compilerOptions": {
                                     // ...

                                     // Don't automatically include anything.
                                     // Only include `@types` packages that we need to import.
                                     "types" : []
                                 },
                                 "files": ["foo.ts"]
                              }

                              // tests/tsconfig.json
                              {
                                 "compilerOptions": {
                                     // ...

                                     // Only include `@types/node` and `@types/mocha`.
                                     "types" : ["node", "mocha"]
                                 },
                                 "files": ["foo.test.ts"]
                              }
                          </code>
                        </pre>
      <footer>
        <p>
          По&nbsp;умолчанию TypeScript автоматически добавляет все найденные в&nbsp;папке node_modules пакеты @types,
          вне зависимости от&nbsp;того, импортировали вы&nbsp;их&nbsp;или нет. Это сделано для того, чтобы определённые
          функции &laquo;просто работали&raquo; при использовании Node.js, Jasmine, Mocha, Chai и&nbsp;т.&nbsp;д., так
          как эти инструменты/пакеты не&nbsp;импортируются, а&nbsp;загружаются в&nbsp;глобальное окружение. Иногда эта
          логика может замедлять компиляцию и&nbsp;редактирование программы. И&nbsp;даже приводить к&nbsp;конфликтам
          объявлений в&nbsp;многочисленных глобальных пакетах, которые вызывают подобные ошибки:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/ts/type-interface.jpg"
        width="1074"
        height="309"
        alt="Type or interface"
      />
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Code Run</h2>
        <img
          class="next ml-4"
          src="./themes/tw/images/practice/companies/yandex.svg"
          alt="Логотип Яндекс"
          width="56"
          height="56"
        />
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/code-run/format.jpg"
        alt="Формат ввода"
        width="1002"
        height="438"
      />
      <footer>
        <p>Её&nbsp;величество Сортировка Сортировка&nbsp;&mdash; один из&nbsp;самых фундаментальных алгоритмов</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/code-run/restrictions.jpg"
        alt="Формат ввода"
        width="1039"
        height="202"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/projects/skolkovo-map.jpg"
        alt="Skolkovo"
        width="1907"
        height="846"
      />
      <footer>
        <p>
          Для тех, кто заметил, что «мономорфный» также связан с моим постом о производительности: да, наличие
          мономорфного значения не только улучшает читаемость, но и значительно повышает производительность
        </p>
        <p>
          Я слишком часто вижу, как люди используют по умолчанию null/ undefinedкак способ показать, что значение еще не
          установлено. Но действительно ли вам нужно пустое значение? Пример. type Dimension = { width: number, height:
          number } // This is our component's dimensions. It's // calculated on the first render, so we don't have // a
          value for it yet. Let it be null for now. let rootDimensions = null as Dimension | null Это может быть не
          сразу очевидно, но последствием выбора nullпустого значения является то, что оно осуждает каждый последующий
          раздел кода, который rootDimensionsдобавляет проверки на null и значения по умолчанию: let sidebarWidth =
          (rootDimensions?.width ?? 0) * 0.20 // ^^^^^^^^^^^^ // This is going to be repeated *each* time rootDimensions
          is used. В то время как инициализация измерений мономорфным значением исключает необходимость последующих
          проверок на нуль: const EMPTY_DIMENSIONS = { width: 0, height: 0 } as Dimension let rootDimensions =
          EMPTY_DIMENSIONS // no more | null needed!
        </p>
        <p>
          Жадные алгоритмы (https://htmlacademy.ru/blog/js/algorithm) — это подход к решению задач оптимизации,
          в котором мы делаем лучший выбор на каждом шаге, надеясь, что это приведёт к лучшему решению в итоге. Это
          простые для понимания алгоритмы, которые ещё и быстро работают.
        </p>
        <p>
          Алгоритм — это набор инструкций для решения какой-то задачи. Всё, что мы делаем: готовим утром кофе, идём
          на работу, пишем код — это исполнение определённых алгоритмов.
        </p>
        <p>
          "peerDependencies": { - "react": "^16.8 ^17.0 ^18.0", + "react": "^16.8 ^17.0 ^18.0 || ^19.0", - "react-dom":
          "^16.8 ^17.0 ^18.0" + "react-dom": "^16.8 ^17.0 ^18.0 || ^19.0" },
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlsList="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/cube.mp4" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlslist="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/dont.mp4" type="video/mp4" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlslist="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/maestro-dent.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlslist="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/doubleb.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlslist="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/greencof.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <video controls muted preload="metadata" controlslist="nodownload nofullscreen noremoteplayback" poster="">
        <source src="./themes/tw/video/msc.webm" type="video/webm" />
      </video>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <figure class="place">
        <blockquote>
          <p>Самая опасная фраза: &laquo;Мы&nbsp;всегда так делали&raquo;</p>
        </blockquote>
        <figcaption>
          Мэтью А. Титмус&nbsp;&mdash; из&nbsp;некой книги серии O&rsquo;Reilly <span class="next">Грейс Хоппер</span>
        </figcaption>
      </figure>
      <footer>
        <p>
          Эта фраза обычно указывает на&nbsp;то, что приверженность статус-кво или продолжение действий без изменений
          может привести к&nbsp;проблемам или неэффективности. В&nbsp;мире программирования это может относиться
          к&nbsp;анти паттернам или устаревшим подходам, которые могут привести к&nbsp;ошибкам или сложностям
          в&nbsp;будущем
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
            Один полезный вывод заключается в том, что в настоящее время blocking=render это может вызвать одно из следующих
  событий:

  '<script src async></script>'
  '<script src defer></script>'
  '<script src type="module"></script>'
  '<script type="module"></script>'
        </code>
      </pre>
      <footer>
        <p>
          Техника проста: поскольку изображения обычно являются более тяжелыми и&nbsp;медленными ресурсами, и&nbsp;они
          не блокируют рендеринг, мы&nbsp;должны попытаться дать пользователям что-то, на&nbsp;что они могут смотреть,
          пока они ждут получения изображения. Решение? Покажите им&nbsp;низкокачественный заполнитель изображения, или
          LQIP
        </p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>The Release Radar</h2>
        📡
      </div>
    </section>

    <section class="slide">
      <h2>Когда?</h2>
      <ul>
        <li>прилетит задача</li>
        <li>при код ревью</li>
        <li>https://github.com/facebook/react/pull/28569</li>
      </ul>
      <footer>
        <p>
          Мы&nbsp;большие поклонники TypeScript и&nbsp;используем его уже много лет в&nbsp;наших собственных проектах,
          а&nbsp;также создали глубокую интеграцию с&nbsp;TypeScript для Wallaby и&nbsp;Quokka. В&nbsp;нашей предыдущей
          записи в&nbsp;блоге мы&nbsp;рассмотрели важность оптимизации ваших тестов для более быстрого выполнения .
          В&nbsp;этой записи в&nbsp;блоге мы&nbsp;немного углубимся и&nbsp;выясним, как TypeScript иногда может быть
          серьезным виновником замедления цикла обратной связи по&nbsp;тестированию, и&nbsp;предоставим несколько
          вариантов того, что вы&nbsp;можете с&nbsp;этим сделать.
        </p>
        <p>
          Одной из&nbsp;лучших особенностей TypeScript является&nbsp;то, что это строго типизированный язык, что
          означает, что он&nbsp;может помочь вам обнаружить ошибки на&nbsp;ранней стадии и&nbsp;предотвратить случайное
          использование неправильных типов. В&nbsp;контексте запуска ваших тестов это не&nbsp;обязательно плохо.
          В&nbsp;контексте запуска ваших тестов, когда вы&nbsp;находитесь в&nbsp;редакторе и&nbsp;можете сразу увидеть
          ошибки типов, это пустая трата времени обработки; ваш редактор выполняет работу по&nbsp;предоставлению ошибок
          типов, а&nbsp;теперь то&nbsp;же самое делает и&nbsp;ваш тестовый исполнитель. Кроме того, обратная связь
          от&nbsp;проверки типов редактора намного быстрее (поскольку он&nbsp;не&nbsp;запускает ваши тесты)
          и&nbsp;намного более эргономична (прямо рядом с&nbsp;вашим кодом и&nbsp;в&nbsp;представлениях проблем,
          а&nbsp;не&nbsp;сообщается как ошибки теста). К&nbsp;сожалению, время обработки, необходимое для выполнения
          этой проверки типов, иногда очень дорого, что означает, что при использовании Wallaby вы&nbsp;действительно
          можете выиграть от&nbsp;оптимизации того, как TypeScript компилируется при запуске ваших тестов.
        </p>
        <p>
          Прежде чем начать, давайте углубимся в&nbsp;архитектуру Wallaby, чтобы понять, когда происходит компиляция
          TypeScript. Wallaby использует несколько рабочих процессов для параллельного запуска ваших тестов, тогда как
          компиляция TypeScript ограничена одним процессом. Для большинства фреймворков тестирования, которые
          поддерживает Wallaby, компиляция из&nbsp;TypeScript в&nbsp;JavaScript происходит в&nbsp;одном процессе,
          до&nbsp;того, как какие-либо из&nbsp;ваших тестов будут запущены параллельно. Для Jest поведение немного
          отличается; Wallaby создает несколько рабочих процессов, а&nbsp;в&nbsp;каждом рабочем процессе Jest создает
          отдельный экземпляр компилятора TypeScript и&nbsp;снова компилирует весь ваш проект. Это досадное ограничение
          Jest, которое означает, что одна и&nbsp;та&nbsp;же работа выполняется несколько раз, что может привести
          к&nbsp;большому объему обработки.
        </p>
        <p>
          А&nbsp;теперь самое интересное... не&nbsp;все так мрачно и&nbsp;безнадежно. Есть несколько простых вещей,
          которые вы&nbsp;можете сделать, чтобы оптимизировать TypeScript при запуске тестов. Для начала давайте получим
          базовый показатель того, сколько времени требуется TypeScript для запуска в&nbsp;проекте среднего размера.
        </p>
        <p>
          У&nbsp;нас есть внутренний проект TypeScript с&nbsp;примерно 22&nbsp;000 строк кода, распределенных
          по&nbsp;135&nbsp;файлам. Используя встроенный компилятор TypeScript ( tsc13.37 seconds ), для компиляции
          проекта в&nbsp;среднем требуется .
        </p>
        <p>
          Первое, что мы&nbsp;можем рассмотреть для повышения производительности,&nbsp;&mdash; это пропустить проверку
          типов между другими файлами, установив isolatedModules параметр компилятора на&nbsp;true. Это снижает среднее
          время компиляции до&nbsp;9.09&nbsp;seconds, 32%сокращение времени (неплохо для быстрого изменения настроек).
          Есть некоторые функции TypeScript, которые не&nbsp;работают с&nbsp;этой настройкой, о&nbsp;которых вам,
          возможно, будет интересно почитать . По&nbsp;нашему опыту, большинство проектов не&nbsp;используют эти
          функции, но&nbsp;ваш может быть другим. Мы&nbsp;решили не&nbsp;использовать эти функции, чтобы получить выгоду
          от&nbsp;более быстрого цикла обратной связи.
        </p>
        <p>
          Существуют и&nbsp;другие способы компиляции файлов TypeScript, аналогичные тем, что делает встроенный
          компилятор TypeScript с&nbsp;isolatedModules опцией компилятора, установленной на&nbsp;true.
          Babel&nbsp;&mdash; популярный инструмент для компиляции TypeScript в&nbsp;JavaScript. Он&nbsp;намного быстрее
          компилятора TypeScript, поскольку он&nbsp;фактически просто отбрасывает информацию о&nbsp;типе TypeScript.
          Среднее время компиляции нашего проекта с&nbsp;помощью babel составляет 2.26&nbsp;seconds.
          Это&nbsp;83%сокращение времени по&nbsp;сравнению с&nbsp;TypeScript 13.37&nbsp;seconds. В&nbsp;зависимости
          от&nbsp;используемых вами функций TypeScript вам может потребоваться настроить babel для использования
          нескольких дополнительных плагинов. Возможно, вам захочется узнать больше о&nbsp;настройке Babel для
          компиляции TypeScript в&nbsp;документации по&nbsp;TypeScript .
        </p>
        <p>
          Мы&nbsp;уже добились значительного улучшения времени, необходимого для компиляции наших тестов,
          но&nbsp;мы&nbsp;еще не&nbsp;закончили. Есть еще один метод, который мы&nbsp;можем использовать для компиляции
          TypeScript, swc . Среднее время компиляции нашего проекта swc составляет 0.461&nbsp;seconds.
          Это&nbsp;96%сокращение времени, которое изначально требовалось нам для компиляции с&nbsp;TypeScript.
          У&nbsp;нас были некоторые проблемы с&nbsp;использованием swc, и&nbsp;хотя сейчас он&nbsp;работает
          с&nbsp;нашими проектами, изначально у&nbsp;нас были проблемы при использовании более ранних версий node. На
          сайте https://swc.rs утверждается, что: &quot; он&nbsp;в&nbsp;20&nbsp;раз быстрее, чем babel на&nbsp;одном
          потоке, и&nbsp;в&nbsp;70&nbsp;раз быстрее на&nbsp;4-ядерном бенчмарке &laquo;. Это определенно стоит
          проверить.
        </p>
        <p>
          Итак, что мы&nbsp;делаем для наших проектов? Мы&nbsp;настраиваем наши собственные проекты для использования
          swc там, где это возможно, а&nbsp;когда это невозможно, мы&nbsp;используем babel при запуске наших тестов как
          из&nbsp;Wallaby, так и&nbsp;из&nbsp;командной строки&nbsp;/ служб непрерывной интеграции (CI). Наши npm script
          sи&nbsp;CI задачи включают шаг для первой компиляции с&nbsp;использованием, tsc чтобы мы&nbsp;не&nbsp;упустили
          ошибки типов. Исходный код для наших производственных сборок tsc также использует.
        </p>
        <p>
          Также стоит упомянуть, что для небольших проектов (или проектов, которые вы&nbsp;не&nbsp;ожидаете сильного
          роста) встроенный компилятор TypeScript будет вполне хорош. Для более крупных проектов (например, больших
          моно-репозиториев, которые разделяют типы между проектами) вы&nbsp;увидите гораздо больший прирост
          производительности, чем мы&nbsp;получили при использовании babel или swc.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Поесть пиццы</h2>
      <footer>
        <p>
          0.1 секунда&nbsp;&mdash; это тот gap, который позволяет пользователю осознать, что именно его клик мышки, удар
          по&nbsp;клавиатуре побудил эти изменения в&nbsp;приложении\интерфейсе.
        </p>
        <p>
          Кажется, у&nbsp;всех было то&nbsp;неловкое чувство, когда ты&nbsp;сочиняешь письмо\код\любой другой текст,
          а&nbsp;интерфейс &laquo;за&nbsp;тобой не&nbsp;успевает&raquo;. Ты&nbsp;уже пишешь второе слово,
          а&nbsp;на&nbsp;экране всё еще песочные часы (если мы&nbsp;про windows) и&nbsp;еле-еле набирается первое.
          Аналогично и&nbsp;с&nbsp;кликами на&nbsp;кнопки. Я&nbsp;хочу, чтобы интерфейс мне подсказывал, мол,
          &laquo;окей, я&nbsp;тебя услышал, ща&nbsp;все будет&raquo;.
        </p>
        <p>
          Движок&nbsp;&mdash; это ядро любого браузера. Он&nbsp;представлен в&nbsp;виде скрипта и&nbsp;отвечает
          за&nbsp;преобразование кода Web-продукта в&nbsp;динамическое изображение, которое отображается на&nbsp;экране
          устройства пользователя. Различия в движках базируются на&nbsp;том, что они имеют разные алгоритмы обработки
          кода. А&nbsp;ещё в&nbsp;них использованы отличные друг от&nbsp;друга принципы реализации стандартов web.
          Сейчас актуальны движки Blink, WebKit и&nbsp;Quantum (Gecko), а такие как Trident, EdgeHTML и&nbsp;Presto уже
          ушли в&nbsp;прошлое. Ниже мы&nbsp;рассмотрим основные движки и&nbsp;разберём, как их особенности влияют
          на&nbsp;тестирование. слово производительеость мгновение бескрайних просторов вселенной помнится мгновенной
          красотой // Что, черт возьми, мне с&nbsp;этим делать page tsx pretty_git_log() { git log &mdash;graph
          &mdash;pretty=&quot;tformat:$FORMAT&quot; $*&nbsp;| column -t -s &rsquo;{&rsquo;&nbsp;| less -XRS
          &mdash;quit-if-one-screen } rendererSettings: { preserveAspectRatio: &laquo;xMidYMid slice&raquo; } фром
          литерал оптимизация архитектуры люблю когда быстро грузится тренд как быстро отвечает бекенд запросы
          к&nbsp;БД&nbsp;Lab vs&nbsp;RUM Real User Monitoring Chrome Ux&nbsp;report git config &mdash;global
          pack.usePathWalk true Оптимизация архитектуры поогнозирование inp ask question ai&nbsp;typescript answer
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
        <code class="language-typescript">
          Объединение через push
for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {
const result = [];
for (let i = 0; i < arr1.length; i++) {
result.push(arr1[i]);
}
for (let i = 0; i < arr2.length; i++) {
result.push(arr2[i]);
}
}
Объединение через индексы
for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {
const result = Array(ARRAY_SIZE_SMALL * 2);
for (let i = 0; i < arr1.length; i++) {
result[i] = arr1[i];
}
for (let i = 0; i < arr2.length; i++) {
result[i + ARRAY_SIZE_SMALL] = arr2[i];
}
}
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <ul>
        <li>node &mdash;inspect-brk</li>
        <li>chrome://inspect</li>
        <li><a href="https://perf.link">perf.link</a></li>
        <li>https://npmgraph.js.org/</li>
        <li>eslint-plugin-depend</li>
      </ul>
    </section>

    <section class="slide">
      <h2>Всё познается в&nbsp;сравнении</h2>
      <img class="cover" src="./themes/tw/pictures/memes/statham.jpg" alt="Ограничения" width="640" height="760" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/companies/yandex.svg"
        alt="Формат ввода"
        width="1002"
        height="438"
      />
    </section>

    <section class="slide">
      <h2 class="shout">Lessons learned from 222,557 font file subsets?</h2>
      <a href="https://www.phpied.com/lessons-learned-from-222557-font-file-subsets/">
        https://www.phpied.com/lessons-learned-from-222557-font-file-subsets/
      </a>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/companies/yandex.svg"
        alt="Формат ввода"
        width="1002"
        height="438"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/npm/debounce.jpg" alt="debounce" width="428" height="330" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/npm/throttle.jpg" alt="throttle" width="428" height="330" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/npm/critical.jpg" alt="critical" width="428" height="330" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/npm/perfume.jpg" alt="perfume" width="428" height="330" />
    </section>

    <section class="slide">
      <h2 class="shout">How Bun supports V8&nbsp;APIs without using&nbsp;V8 (part&nbsp;1)</h2>
      https://bun.sh/blog/how-bun-supports-v8-apis-without-using-v8-part-1
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <pre>
                    <code class="language-typescript">
            module.exports = function(N, staff, K) {
              staff.sort((a, b) => b - a);

              let sum = 0;

              for (let = 0; i < Math.min(K, N); i++) {
                sum += staff[i];
              }

              return sum;
            }
                    </code>
                  </pre>
    </section>

    <section class="slide">
      <h2 class="sr-only">Sort</h2>
      <div class="column two">
        <pre>
                    <code class="language-typescript">
                      module.exports = function(N, staff, K) {
                        let count = new Array(26).fill(0);
                        let maxGrade = 0;
                        let keyboardsUsed = 0;
                        ley grade = 25;

                        for (let i = 0; i < N; i++) {
                          count[staff[i]]++;
                        }

                        while (keyboardUsed < K) {
                          if (count[grade] > 0) {
                            maxGrade += grade;
                            count[grade]--;
                            keyboardUsed++;
                          } else {
                            grade--;
                          }
                        }


                        return maxGrade;
                      }
                    </code>
                  </pre>
      </div>
    </section>

    <section class="slide">
      <h2 class="cover !left-0 mt-[24px] -translate-y-[50%] pl-[100px] text-left">
        <span class="text-gray">Акт&nbsp;3.</span> <br />Выводы
      </h2>
      <footer>
        <ul>
          <li>делайте замеры</li>
          <li>начаните с&nbsp;малого</li>
          <li>перфоманс это навсегда</li>
        </ul>
      </footer>
    </section>

    <section class="slide">
      <h2 class="cover">Что хотим/хотят от&nbsp;нашего кода?</h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Mem</h2>
      <img class="cover" src="./themes/tw/pictures/memes/klitschko.jpg" alt="klitschko" width="525" height="340" />
    </section>

    <section class="slide">
      <h2 class="shout">perfomance<span class="next text-red">!important</span></h2>
    </section>

    <section class="slide">
      <h2 class="sr-only">Wiki</h2>
      <img class="cover" src="./themes/tw/images/preview/wiki.jpg" alt="Wiki" width="880" height="249" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/pizza.jpg" alt="pizza" width="226" height="223" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/oldman.jpg" alt="oldman" width="1200" height="750" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/no.jpg" alt="No" width="1280" height="1280" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/perfume.jpg" alt="perfume" width="262" height="351" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/languages/java.svg" alt="java" width="234" height="428" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/separation.jpg" alt="separation" width="1018" height="651" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/emberjs.jpg" alt="emberjs" width="724" height="944" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/eslint.jpg" alt="eslint" width="1024" height="1024" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/hero.svg" alt="hero" width="353" height="353" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/tools/hyperscript.jpg"
        alt="hyperscript"
        width="577"
        height="105"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/tools/lighthouse.svg"
        alt="lighthouse"
        width="2500"
        height="2500"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/tools/size-limit.svg" alt="size-limit" width="16" height="16" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/emoji/rocket.gif" alt="rocket" width="512" height="512" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/emoji/rocket.webp" alt="rocket" width="512" height="512" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/theory/tools/node-vs-bun.jpg"
        alt="Node vs bun"
        width="1280"
        height="720"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/cat.jpg" alt="Cat" width="1080" height="765" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/madman.jpg" alt="Madman" width="1280" height="576" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/devs.jpg" alt="Devs" width="1500" height="844" />
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://www.kinopoisk.ru/film/723959/sr/1/"
        >https://www.kinopoisk.ru/film/723959/sr/1/</a
      >
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/silicon-valley.jpg"
        alt="Silicon valley"
        width="480"
        height="270"
      />
      <a class="copyright" target="_blank" rel="noopener noreferrer" href="https://www.kinopoisk.ru/series/1137249">
        https://www.kinopoisk.ru/series/1137249/?utm_referrer=yandex.ru
      </a>
    </section>

    <section class="slide">
      <div class="shout">
        <h2>Долголетие</h2>
      </div>
      <footer>
        <p>Прежде чем перейдем к&nbsp;практике</p>
        <p>Хотим чтобы код долгоиграющим</p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Эффективность</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/battery.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/battery.gif" alt="🔋" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>Хотим чтобы код был эффективным</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/practice/web-vitals/CLS.jpg" alt="CLS" width="2154" height="1081" />
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Чтобы не&nbsp;прилетали баги</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/air.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/air.gif" alt="🛫" width="56" height="56" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">20% усилий <span class="next">= 80% результата</span></h2>
    </section>

    <section class="slide">
      <div>
        <picture>
          <source srcset="./themes/tw/pictures/emoji/eyes.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/eyes.gif" alt="👀" width="32" height="32" />
        </picture>
        <h2 class="shout">Заметно <span class="next">!== значимо</span></h2>
      </div>
    </section>

    <section class="slide">
      <div>
        <picture>
          <source srcset="./themes/tw/pictures/emoji/diamond.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/diamond.gif" alt="💎" width="32" height="32" />
        </picture>
        <h2 class="shout">Ваша система&nbsp;&mdash; это ответственность надолго</h2>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/conclusions/ux-core.jpg" alt="UX core" width="1913" height="914" />
      <a class="copyright" href="https://keepsimple.io/ru/uxcore/" target="_blank" rel="noopener noreferrer"
        >UX&nbsp;Core</a
      >
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Спасибо за&nbsp;внимание!</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/pictures/emoji/finish.webp" type="image/webp" />
          <img src="./themes/tw/pictures/emoji/finish.gif" alt="🏁" width="72" height="72" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/conclusions/qr-code-presentation.svg"
        alt="Qr code presentation"
        width="400"
        height="400"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/oop/encapsulation.jpg"
        alt="Инкапсуляция"
        width="1184"
        height="1141"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/oop/inheritance.jpg"
        alt="Наследование"
        width="1183"
        height="1133"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/pictures/memes/oop/polymorphism.jpg"
        alt="Полиморфизм"
        width="1183"
        height="1137"
      />
    </section>

    <section class="slide">
      <h2>Найдите самые дорогие селекторы CSS</h2>
      <img
        class="cover"
        src="./themes/tw/images/practice/dev-tools/find-expensive-selectors.jpg"
        alt="Qr code form"
        width="1300"
        height="810"
      />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/pictures/memes/cooper.jpg" alt="Купер" width="968" height="544" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/theory/o.jpg" alt="o" width="1280" height="1008" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/preview/heads.jpg" alt="heads" width="1181" height="1126" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img class="cover" src="./themes/tw/images/practice/tools/bundle.jpg" alt="bundle" width="1921" height="997" />
    </section>

    <section class="slide">
      <h2 class="sr-only">Test</h2>
      <img
        class="cover"
        src="./themes/tw/images/conclusions/qr-code-form.svg"
        alt="Qr code form"
        width="400"
        height="400"
      />
      <footer>
        <p>
          Big O&nbsp;&mdash; нотация, которая позволяет определить верхнюю границу скорости работы алгоритма. Как
          справедливо отметил один из&nbsp;комментаторов, это асимптотическая сложность, которая описывает верхнюю
          границу сложности алгоритма при увеличении размера входных данных, или&nbsp;то, как рост размера входных
          данных влияет на&nbsp;количество операций.
        </p>
        <p>
          Многие шаблоны, которые делают ваш код более гибким, полагаются на&nbsp;виртуальную диспетчеризацию,
          интерфейсы, указатели, сообщения и&nbsp;другие механизмы , которые все имеют по&nbsp;крайней мере некоторые
          затраты времени выполнения.
        </p>
        <p>
          Здесь есть спектр гибкости. Когда вы&nbsp;пишете код для вызова конкретного метода в&nbsp;некотором классе, вы
          фиксируете этот класс во&nbsp;время создания&nbsp;&mdash; вы&nbsp;жестко запрограммировали, какой класс
          вы&nbsp;вызываете. Когда вы проходите через виртуальный метод или интерфейс, класс, который вызывается,
          неизвестен до&nbsp;времени выполнения . Это гораздо более гибко, но&nbsp;подразумевает некоторые накладные
          расходы во&nbsp;время выполнения. Метапрограммирование шаблонов находится где-то посередине. Там
          вы&nbsp;принимаете решение о&nbsp;том, какой класс вызывать, во&nbsp;время компиляции , когда создается
          экземпляр шаблона.
        </p>
        <p>
          Отсюда следует одно неочевидное заключение: хорошо спроектированная система не&nbsp;заботится
          об&nbsp;увеличении свободной памяти. Память&nbsp;&mdash; это ресурс, а&nbsp;свободная память&nbsp;&mdash;
          неиспользуемый ресурс. Наоборот, хорошо спроектированная система использует достаточно много памяти, чтобы
          обеспечить такое состояние, когда пользователь не&nbsp;чувствует изменений в&nbsp;производительности.
        </p>
        <p>
          Но&nbsp;производительность&nbsp;&mdash; это все о&nbsp;предположениях. Практика оптимизации процветает
          на&nbsp;конкретных ограничениях. Можем&nbsp;ли мы&nbsp;с&nbsp;уверенностью предположить, что у&nbsp;нас
          никогда не&nbsp;будет больше 256&nbsp;врагов? Отлично, мы&nbsp;можем упаковать идентификатор в&nbsp;один байт.
          Мы&nbsp;будем вызывать здесь только метод для одного конкретного типа? Хорошо, мы&nbsp;можем статически
          диспетчеризировать или встроить его. Все&nbsp;ли сущности будут одного класса? Отлично, мы можем создать
          из&nbsp;них хороший непрерывный массив . (https://gameprogrammingpatterns.com/data-locality.html) Но это
          не&nbsp;значит, что гибкость плоха! Она позволяет нам быстро менять игру, а&nbsp;скорость разработки абсолютно
          необходима для получения интересного опыта. Никто, даже Уилл Райт, не&nbsp;может придумать сбалансированный
          игровой дизайн на&nbsp;бумаге. Он&nbsp;требует итераций и&nbsp;экспериментов. Чем быстрее вы&nbsp;сможете
          опробовать идеи и&nbsp;увидеть, как они себя чувствуют, тем больше вы&nbsp;сможете попробовать и&nbsp;тем
          больше вероятность найти что-то отличное. Даже после того, как вы&nbsp;нашли правильную механику, вам нужно
          много времени для настройки. Небольшой дисбаланс может испортить удовольствие от&nbsp;игры. Здесь нет простого
          ответа. Сделать программу более гибкой, чтобы вы&nbsp;могли быстрее создавать прототипы, будет иметь некоторые
          потери производительности. Аналогично, оптимизация вашего кода сделает его менее гибким. Однако мой опыт
          показывает, что легче сделать веселую игру быстрой, чем сделать быструю игру веселой. Один
          из&nbsp;компромиссов&nbsp;&mdash; сохранять код гибким, пока дизайн не&nbsp;устоятся, а&nbsp;затем вырвать
          часть абстракции позже, чтобы улучшить производительность.
        </p>
      </footer>
    </section>

    <section class="slide relative">
      <div class="shout flex flex-col items-center">
        <div class="dots relative h-[46px] w-[52px] text-white before:animate-jump"></div>
        <h2>Вопросы</h2>
      </div>
    </section>

    <script src="node_modules/@shower/core/dist/shower.js"></script>
    <!-- Copyright © 2024 Yours Truly, Famous Inc. -->

    <script src="./themes/tw/libs/highlight/highlight.min.js"></script>
    <script src="./themes/tw/libs/highlight/init.js"></script>
    <script src="./themes/tw/libs/custom-scale.js"></script>
  </body>
</html>
