<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Семь раз отмерь, один раз оптимизируй</title>
    <link rel="stylesheet" href="./themes/ribbon/styles/styles.css" />
    <link rel="stylesheet" href="./bundled/main.css" />
    <meta name="description" content="Презентация по TailwindCSS" />
    <link rel="icon" href="./themes/tw/images/logo.png" type="image/svg+xml" />
  </head>
  <body class="shower list scrollbar bg-green">
    <header class="caption">
      <h1>Семь раз отмерь, один раз оптимизируй</h1>
      <p class="mt-2">
        <i>Денис Русаков</i>
      </p>
    </header>

    <section class="slide p-0">
      <div class="flex h-full flex-col items-center justify-end">
        <img class="!my-10" src="./themes/tw/images/logo.png" width="250" height="250" alt="Перо" />
        <div class="text-center">
          <h2 class="!my-[20px] text-5xl">Семь раз отмерь, один раз оптимизируй</h2>
          <p class="text-md italic leading-6">
            <i class="text-gray">Денис Русаков</i>
          </p>
        </div>
      </div>
      <footer>
        <p>Всем привет</p>
        <p>На слайде изображено перо жар птицы</p>
      </footer>
    </section>

    <section class="slide">
      <div class="mt-[70px] flex flex-col items-center justify-center opacity-90">
        <div class="-mx-8 flex items-start justify-center gap-8">
          <img class="rounded-sm" src="./themes/tw/pictures/o-reilly/1.jpg" width="200" height="200" alt="Книга 1" />
          <img class="rounded-sm" src="./themes/tw/pictures/o-reilly/2.jpg" width="200" height="200" alt="Книга 2" />
          <img class="rounded-sm" src="./themes/tw/pictures/o-reilly/3.jpg" width="200" height="200" alt="Книга 3" />
        </div>
        <img
          class="mt-8 rounded-sm"
          src="./themes/tw/pictures/o-reilly/logo.svg"
          width="400"
          height="200"
          alt="Логотип O'Reilly"
        />
        <a target="_blank" rel="noopener noreferrer" class="copyright" href="https://www.oreilly.com/">oreilly</a>
      </div>
    </section>

    <section class="slide">
      <img class="cover rounded-md" src="./themes/tw/pictures/bird.jpg" width="500" height="250" alt="Жар птица" />
      <footer>
        <p>Птица из новой Гвинеии</p>
        <p>
          Сказание о необычной пташке зародилось еще в стародавние времена. Наши предки тогда верили в Перуна – бога
          грома и справедливости. Иногда он являлся в образе Жар-птицы. По другим легендам, она была символом бессмертия
          и богатства, поэтому добыть себе перо из ее хвоста считалось настоящим счастьем.
        </p>
        <p>Перо - это производительность, которую нам иногда необходимо достичь/поймать?</p>
      </footer>
    </section>

    <!-- <section class="slide">
      Если вы только что оптимизировали функцию, и теперь она работает в 100 раз быстрее, усомнитесь в ней. Попробуйте
      опровергнуть свои результаты, попробуйте ее в режиме производства, забросайте ее всякой всячиной. Аналогично,
      усомнитесь и в своих инструментах. Сам факт наблюдения за бенчмарком с помощью devtools может изменить ее
      поведение.
    </section> -->

    <section class="slide group">
      <h2>Какой план?</h2>
      <img
        class="next float-right translate-x-[70px] translate-y-[200px] group-has-[#first-item.active]:hidden"
        src="./themes/tw/images/memes/plan.jpg"
        width="300"
        alt="183"
        aria-hidden="true"
      />
      <ol>
        <li class="next" id="first-item">Теория</li>
        <li class="next">
          Практика
          <span class="next">(набор приемов/советов)</span>
        </li>
      </ol>
      <footer>
        <p>В теории подведу через некоторые истории и кейсы к сути темы</p>
        V8 — движок с открытым исходным кодом, написан на C++, его разработкой занимается Google.
        <p>Rhino — этот движок с открытым кодом поддерживает Mozilla Foundation, он полностью написан на Java.</p>
        <p>
          SpiderMonkey — это самый первый из появившихся JS-движков, который в прошлом применялся в браузере Netscape
          Navigator, а сегодня — в Firefox.
        </p>
        <p>
          JavaScriptCore — ещё один движок с открытым кодом, известный как Nitro и разрабатываемый Apple для браузера
        </p>
        <p>
          Safari. KJS — JS-движок KDE, который разработал Гарри Портен для браузера Konqueror, входящего в проект KDE.
        </p>
        <p>Chakra (JScript9) — движок для Internet Explorer. Chakra (JavaScript) — движок для Microsoft Edge.</p>
        <p>
          Nashorn — движок с открытым кодом, являющийся частью OpenJDK, которым занимается Oracle. JerryScript —
          легковесный движок для интернета вещей.
        </p>
      </footer>
    </section>

    <section class="slide with-title">
      <h2 class="cover text-left"><span class="text-gray">Глава 1.</span><br />Теория</h2>
    </section>

    <section class="slide">
      <h2>React Developer Tools</h2>
      <a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en">https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en</a>
    </section>

    <section class="slide">
      <pre>
const markerNameA = "example-marker-a"
const markerNameB = "example-marker-b"

// Run some nested timeouts, and create a PerformanceMark for each.
performance.mark(markerNameA);
setTimeout(function() {
  performance.mark(markerNameB);
  setTimeout(function() {

    // Create a variety of measurements.
    performance.measure("measure a to b", markerNameA, markerNameB);
    performance.measure("measure a to now", markerNameA);
    performance.measure("measure from navigation start to b", undefined, markerNameB);
    performance.measure("measure from the start of navigation to now");

    // Pull out all of the measurements.
    console.log(performance.getEntriesByType("measure"));

    // Finally, clean up the entries.
    performance.clearMarks();
    performance.clearMeasures();
  }, 1000);
}, 1000);

        console.time("answer time");
alert("Click to continue");
console.timeLog("answer time");
alert("Do a bunch of other stuff...");
console.timeEnd("answer time");

        https://www.telerik.com/blogs/measuring-performance-javascript-performance-api

        https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure

        https://docs.sentry.io/platforms/javascript/tracing/instrumentation/performance-metrics/

https://support.speedcurve.com/docs/javascript-performance

https://betterstack.com/community/guides/scaling-nodejs/performance-apis/
      </pre>
    </section>

    <!-- <section class="slide">
      <img class="cover rounded-md" src="./themes/tw/pictures/aviasales.jpg" alt="" width="400" height="400" />
    </section> -->

    <section class="slide">
      <p class="cover">Движок JS — специализированная программа, обрабатывающая JS, в частности, в браузерах.</p>
      <!-- <a target="_blank" rel="noopener noreferrer" href="">https://v8.dev/blog/react-cliff</a> -->
      <footer>
        Почему был создан движок V8? Движок с открытым кодом V8 был создан компанией Google, он написан на C++. Движок
        используется в браузере Google Chrome. Кроме того, что отличает V8 от других движков, он применяется в
        популярной серверной среде Node.js.
      </footer>
    </section>

    <section class="slide">
      <h2>Какие движки уже существуют?</h2>
      <ul>
        <li class="next">SpiderMonkey</li>
        <li class="next">Chakra</li>
        <li class="next">Nitro</li>
        <li class="next">V8</li>
      </ul>
      <footer>
        О двух компиляторах, которые использовались в V8 Внутреннее устройство V8 изменилось с выходом версии 5.9,
        которая появилась совсем недавно. До этого же он использовал два компилятора: full-codegen — простой и очень
        быстрый компилятор, который выдаёт сравнительно медленный машинный код. Crankshaft — более сложный
        оптимизирующий JIT-компилятор, который генерирует хорошо оптимизированный код. Внутри движка используются
        несколько потоков: Главный поток, который занимается тем, что от него можно ожидать: читает исходный JS-код,
        компилирует его и выполняет. Поток компиляции, который занимается оптимизацией кода в то время, когда
        выполняется главный поток. Поток профилировщика, который сообщает системе о том, в каких методах программа
        тратит больше всего времени, как результат, Crankshaft может эти методы оптимизировать. Несколько потоков,
        которые поддерживают механизм сборки мусора. При первом исполнении JS-кода V8 задействует компилятор
        full-codegen, который напрямую, без каких-либо дополнительных трансформаций, транслирует разобранный им
        JavaScript-код в машинный код. Это позволяет очень быстро приступить к выполнению машинного кода. Обратите
        внимание на то, что V8 не использует промежуточное представление программы в виде байт-кода, таким образом,
        устраняя необходимость в интерпретаторе. После того, как код какое-то время поработает, поток профилировщика
        соберёт достаточно данных для того, чтобы система могла понять, какие методы нужно оптимизировать. Далее, в
        другом потоке, начинается оптимизация с помощью Crankshaft. Он преобразует абстрактное синтаксическое дерево
        JavaScript в высокоуровневое представление, использующее модель единственного статического присваивания (static
        single-assignment, SSA). Это представление называется Hydrogen. Затем Crankshaft пытается оптимизировать граф
        потока управления Hydrogen. Большинство оптимизаций выполняется на этом уровне.
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="m-0">Что такое <i>V8</i> ?</h2>
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f440/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f440/512.gif" alt="👀" width="44" height="44" />
        </picture>
      </div>
      <footer>
        <p>
          В движке V8 нет интерпретатров, но существует 2 типа компиляторов - общий и оптимизирующий. Это привод к тмоу,
          что JS всегда копилируется и заускается так же как и машинный код. Означает ли это, что код работает быстро?
          Нет, Сама по себе компиляция не ускоряет работу кода. Она позволяет избежать накалыднх расходов, вызваных
          работй интерпертаора, но неоптимизированный код убедт рабоатт медленно.
        </p>
        <p>Через скрытые классы V8 идентифицирует обьектыю</p>
        <p>
          когда вы создаете новый обьект движок создаст для него новый скрытый класс. Затем если вы измените тот же
          обьект добавив новое свойцство мезанизм создаст новый скрытый класс со всеми свойствам из предыдщуего клкасс и
          включит новое свойство
        </p>
        <p>Мономофризм что у обьектов одинакоыве ключи без олтичий</p>
        <p>Мегаморфизм тут обьекты совершенно разные и их нельзя сравнивать</p>
        <p>Полиморфизм у обьектов общая струкутура но меняются небольшие отличия</p>
      </footer>

      <!-- <h2>
        прилетали баги

        <pre>
          const obj = { name: 'Test' }

          const objClassId = ['name', 1]

          const obj = {...objClassId, 'Test'}

          obj.name

          obj[getProp(obj[0], name)]

          механизмы оптимизации выполнения js
        </pre>
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6ec/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6ec/512.gif" alt="🛬" width="32" height="32" />
        </picture>
      </h2> -->
      <!-- <picture>
        <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f680/512.webp" type="image/webp" />
        <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f680/512.gif" alt="🚀" width="32" height="32" />
      </picture> -->
    </section>

    <section class="slide">
      <img src="./themes/tw/pictures/theory/v8/codeium.png" width="" height="" alt="" />
    </section>

    <section class="slide">
      <h2 class="shout">Долголетие</h2>
      <footer>
        <p>Прежде чем перейдем к практике</p>
        <p>Хотим чтобы код долгоиграющим</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">
        Эффективность
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f50b/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f50b/512.gif" alt="🔋" width="32" height="32" />
        </picture>
      </h2>
      <footer>
        <p>Хотим чтобы код был эффективным</p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        const t0 = performance.now();
for (let i = 0; i < array.length; i++) 
{
  // какой-то код
}
const t1 = performance.now();
console.log(t1 - t0, 'milliseconds');

  В Chrome после выполнения этого кода можно получить примерно такой результат:

0.6350000001020817 "milliseconds"

В Firefox — такой:

1 milliseconds

Метод console.time()

  Запускайте функции по много раз

Тестируйте производительность в разных браузерах

https://doka.guide/js/performance/

https://purpleschool.ru/knowledge-base/article/performance

кейс cell-trade
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">
        Чтобы не прилетали баги
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6eb/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6eb/512.gif" alt="🛫" width="32" height="32" />
        </picture>
      </h2>
    </section>

    <!-- <section class="slide">
      <h2>А чем будем мерить?</h2>
      <ul>
        <li class="next">JS <span class="next">(клин клином)</span></li>
        <li class="next">
          DevTools
          <a class="" href="https://www.youtube.com/watch?v=70XMVfGv2Q0" target="_blank" rel="noopener noreferrer"></a>
          <a
            class="next"
            href="https://github.com/iamakulov/devtools-perf-features"
            target="_blank"
            rel="noopener noreferrer"
            >(devtools-perf-features)</a
          >
        </li>
        <li class="next">
          сервисы (<a href="https://ui.perfetto.dev/" target="_blank" rel="noopener noreferrer">perfetto</a>)
        </li>
        <li class="next">
          расширения в IDE (<a
            target="_blank"
            rel="noopener noreferrer"
            href="https://marketplace.visualstudio.com/items?itemName=rbuckton.deoptexplorer-vscodeer-vscode"
            >deoptexplorer-vscode</a
          >)
        </li>
        <li class="next">
          пакеты (<a target="_blank" rel="noopener noreferrer" href="https://www.npmjs.com/package/perfume.js"
            >perfume</a
          >
          и т. д.)
        </li>
        <li class="next">https://github.com/facebook/memlab</li>
        <li>
          <a href="https://web.dev/articles/speed-v8?hl=ru" target="_blank" rel="noopener noreferrer"
            >https://web.dev/articles/speed-v8?hl=ru</a
          >
        </li>
        <li><a href="https://jsbenchmark.com/" target="_blank" rel="noopener noreferrer">jsbenchmark</a></li>
        <li>
          <a href="https://habr.com/ru/companies/oleg-bunin/articles/417459/" target="_blank" rel="noopener noreferrer"
            >Пост с хабра</a
          >
        </li>
      </ul>
    </section> -->

    <section class="slide with-title">
      <h2 class="cover text-left"><span class="text-gray">Глава 2.</span><br />Практика</h2>
    </section>

    <!-- <section class="slide">
      <h2>Алгоритмы</h2>
      <ul>
        <li>
          выбрать метрики, которыми можно можно охарактериозовать "степень оптимальности" нашего сайта или приложения
        </li>
        <li>найти код сильене всего ухудшающий метрики</li>
        <li>внести изменния в код</li>
        <li>измерить новые значения</li>
        <li>повторить</li>
      </ul>
    </section> -->

    <section class="slide">
      <h2 class="">Сравнение строк</h2>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/pictures/theory/enum/1.svg" width="1000" height="500" alt="" />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/pictures/theory/enum/2.svg" width="1000" height="500" alt="" />
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте разных форм</h2>
      <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html>https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html</a>
      <footer>
        <p>
          Движки Javascript пытаются оптимизировать код, предполагая, что объекты имеют определенную форму, и что
          функции будут получать объекты той же формы. Это позволяет им хранить ключи формы один раз для всех объектов
          этой формы, а значения — в отдельном плоском массиве. Чтобы представить это в javascript:
        </p>
        <p>
          Я использовал слово «форма» для описания этой концепции, но имейте в виду, что вы также можете встретить
          термины «скрытый класс» или «карта» для ее описания, в зависимости от движка.
        </p>
        <p>
          Например, если во время выполнения следующая функция получает два объекта с формой { x: number, y: number },
          движок предположит, что будущие объекты будут иметь такую ​​же форму, и сгенерирует машинный код,
          оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не с формой, { x, y }а с формой { y, x }, движку нужно будет отменить свое
          предположение, и функция внезапно станет значительно медленнее. Я собираюсь ограничить свое объяснение здесь,
          потому что вам следует прочитать превосходный пост от mraleph, если вы хотите больше подробностей, но я
          собираюсь подчеркнуть, что V8, в частности, имеет 3 режима для доступа, которые являются: мономорфный (1
          форма), полиморфный (2-4 формы) и мегаморфный (5+ форм). Допустим, вы действительно хотите оставаться
          мономорфным, потому что замедление радикально:
        </p>
        <p>
          Движки обычно могут кодировать целые числа как значения. Например, V8 представляет значения в 32 битах, причем
          целые числа представляют собой компактные значения Smi (SMall Integer), но числа с плавающей точкой и большие
          целые числа передаются как указатели, как строки и объекты. JSC использует 64-битное кодирование, двойное
          тегирование , чтобы передавать все числа по значению, как это делает SpiderMonkey, а остальное передается как
          указатели.
        </p>
      </footer>
    </section>

    <section class="slide">
      <img src="./themes/tw/pictures/theory/shapes/1.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <img src="./themes/tw/pictures/theory/shapes/2.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <img src="./themes/tw/pictures/theory/shapes/3.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <scale d="100" />
      <scale d="13" />
      <scale d="4" />
    </section>

    <section class="slide">
      <h2 class="shout">[ ] { } <br /><br />Избегайте методов<br />массивов/объектов</h2>
      <img src="" alt="" width="" height="" />
      <footer>
        <p>нет, вы не зря сдавали или будете сдавть компитишн про методы массивов</p>
      </footer>
    </section>

    <section class="slide">
      <img src="./themes/tw/pictures/theory/array-objects/1.svg" alt="" width="" height="" />
      <footer>
        <p>
          Я люблю функциональное программирование так же, как и все остальные, но если вы не работаете с
          Haskell/OCaml/Rust, где функциональный код компилируется в эффективный машинный код, то функциональное
          программирование всегда будет медленнее императивного.
        </p>
        <p>Проблема с этими методами заключается в следующем:</p>
        <p>
          Им нужно сделать полную копию массива, и эти копии позже должны быть освобождены сборщиком мусора. Мы более
          подробно рассмотрим вопросы ввода-вывода памяти в разделе 5.
        </p>
        <p>Они выполняют цикл N раз для N операций, тогда как for цикл допускает выполнение цикла один раз.</p>
        <p>
          Методы объектов, такие как Object.values(), Object.keys()и Object.entries()страдают от похожих проблем, так
          как они также выделяют больше данных, а доступ к памяти является корнем всех проблем с производительностью.
          Нет, правда, я клянусь, я покажу вам в разделе 5.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <scale name="Функциональный подход" percentage="36" />
      <scale name="Императивный подход" percentage="100" />
    </section>

    <!-- <section class="slide">20% усилий -> 80% результата</section> -->

    <!-- <section class="slide">
      производительность - это не математика
      <a href="https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/" target="_blank" rel="noopener noreferrer"
        >Видео с Rutube</a
      >
      <a href="https://v8.dev/blog/react-cliff" target="_blank" rel="noopener noreferrer"
        >https://v8.dev/blog/react-cliff</a
      >
      <a href="https://almanac.httparchive.org/en/2022/page-weight" target="_blank" rel="noopener noreferrer"
        >https://almanac.httparchive.org/en/2022/page-weight</a
      >
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">JNT (Just Noticeable Difference)</h2>
    </section> -->

    <!-- <section class="slide">
      <p>да кому оно надо</p>
      <footer>
        <p>бизнесу</p>
      </footer>
    </section> -->
    <!-- <section>заметно !== значимо</section> -->

    <section class="slide">
      <h2 class="shout text-center">
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f608/512.webp" type="image/webp" />
          <img
            src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f608/512.gif"
            alt="😈"
            width="72"
            height="72"
          /> </picture
        ><br />Используйте eval
      </h2>
      <footer>
        <p>
          Некоторые шаблоны javascript трудно оптимизировать для движков, и с помощью использования eval()или его
          производных вы можете заставить эти шаблоны исчезнуть. В этом примере мы можем наблюдать, как использование
          eval()позволяет избежать затрат на создание объекта с динамическим ключом объекта:
        </p>
        <p>
          Другим хорошим вариантом использования evalможет быть компиляция функции предиката фильтра, где вы
          отбрасываете ветви, которые, как вы знаете, никогда не будут выполнены. В общем, любая функция, которая будет
          запущена в очень горячем цикле, является хорошим кандидатом для такого рода оптимизации.
        </p>
        <p>
          Очевидно, что обычные предупреждения eval()применимы: не доверяйте пользовательскому вводу, очищайте все, что
          передается в eval()'d-код, и не создавайте никаких возможностей XSS. Также обратите внимание, что некоторые
          среды не разрешают доступ к eval(), например, страницы браузера с CSP.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>С eval</h2>
      <img src="./themes/tw/pictures/theory/eval/1.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <h2>Без eval</h2>
      <img src="./themes/tw/pictures/theory/eval/2.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <h2 class="shout">Используйте строки, осторожно</h2>
      <footer>
        <p>
          Мы уже видели выше, что строки дороже, чем кажутся. Ну, у меня тут есть своего рода ситуация хороших/плохих
          новостей, которую я объявлю в единственном логическом порядке (сначала плохие, потом хорошие): строки сложнее,
          чем кажутся, но их также можно довольно эффективно использовать.
        </p>
        <p>
          Строковые операции являются основной частью JavaScript из-за его контекста. Чтобы оптимизировать код,
          насыщенный строками, движки должны были быть креативными. Под этим я подразумеваю, что они должны были
          представлять Stringобъект с помощью множественного строкового представления в C++, в зависимости от варианта
          использования. Есть два общих случая, о которых вам следует беспокоиться, поскольку они справедливы для V8
          (наиболее распространенного движка на сегодняшний день), а также, как правило, и для других движков.
        </p>
        <p>
          Но вот в чем проблема: как только вам нужно начать мутировать эти байты, в этот момент вы начинаете платить за
          копирование. Допустим, мы возвращаемся к нашему Stringклассу и пытаемся добавить .trimEndметод:
        </p>
        <p>Что, черт возьми, мне с этим делать?</p>
        <p>
          В общем, старайтесь избегать мутаций как можно дольше.trim() . Это включает такие методы , как .replace(), и
          т. д. Подумайте, как можно избежать этих методов. В некоторых движках шаблоны строк также могут быть
          медленнее, чем +. В V8 на данный момент это так, но может не быть в будущем, поэтому, как всегда, бенчмарк.
        </p>
        <p>
          Примечание SlicedStringвыше: следует отметить, что если в памяти находится небольшая подстрока очень большой
          строки,это может бытьне позволяйте сборщику мусора собирать большую строку! Если вы обрабатываете большие
          тексты и извлекаете из них маленькие строки, вы можете допустить утечку большого объема памяти.
        </p>
        <p>
          Решение здесь — использовать методы мутации в наших интересах. Если мы используем один из них на small, это
          приведет к принудительному копированию, и старый указатель на largeбудет потерян:
        </p>
      </footer>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/pictures/theory/strings/1.svg" width="700" height="350" alt="Codeium V8" />
    </section>

    <section class="slide">
      <scale p="37" />
      <scale p="100" />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/pictures/theory/strings/2.svg" width="700" height="350" alt="Codeium V8" />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/strings/3.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <!-- <section class="slide">
      <h2>Бонус</h2>
      <p>Что быстрее типы или интерфейсы</p>
    </section>

    <section class="slide">
      <h2>по данным синоптикам</h2>
      <footer>
        <p>тема производительности большая</p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      Деоптимизиация код сгенерированный оптимизирующим компилятором, не всегода оказывается быстрее
    </section>
    <section class="slide">
      <h2>Восприятие времени</h2>
      <ul>
        <li>< 100 мс. мгновеннл</li>
        <li>< 1 с. ок</li>

        <li>> 2 c оке</li>

        <li>Больше - теряет фокус внимнаия</li>
      </ul>
    </section>

    <section class="slide">
      <h2>работает - не трогай</h2>
      <h2>не работает - трогай</h2>
      <h2>плохо работает - трогай</h2>
    </section> -->
    <!--
    <section>
      <h2>Walmart</h2>
      1 с. увелчиения - конверися + 2% (от 400 млрд)
    </section>

    <section class="slide relative">
      <img class="cover" src="./themes/tw/images/codeium-v8.png" width="700" height="350" alt="Codeium V8" />
      <img
        class="next translate-x-[600px] translate-y-[340px]"
        src="./themes/tw/images/memes/Ilon.jpg"
        width="300"
        height="150"
        alt="Мем Ilon"
      />
      <a class="copyright" href="https://codeium.com/live/general" target="_blank" rel="noopener noreferrer">codeium</a>
      <footer>
        Процентные результаты представляют собой количество операций, выполненных в течение 1 с, деленное на количество
        операций в случае с наивысшей оценкой. Чем выше, тем лучше.
      </footer>
      <footer>
        Как видите, разница может быть существенной. Разница не обязательно связана со стоимостью, strcmpпоскольку
        движки иногда могут использовать пул строк и сравнивать по ссылке, но она также связана с тем, что целые числа
        обычно передаются по значению в движках JS, тогда как строки всегда передаются как указатели, а доступ к памяти
        является дорогостоящим (см. раздел 5). В коде с большим количеством строк это может иметь огромное влияние. В
        качестве примера из реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в 2 раза быстрее
        *, просто заменив строковые константы числами.
      </footer>
      <footer>
        0. Избегать работы Это может показаться очевидным, но это должно быть здесь, потому что не может быть другого
        первого шага к оптимизации: если вы пытаетесь оптимизировать, вы должны сначала рассмотреть возможность
        избегания работы. Это включает в себя такие концепции, как мемоизация, лень и инкрементальные вычисления. Это
        будет применяться по-разному в зависимости от контекста. В React, например, это будет означать применение
        memo()и useMemo()других применимых примитивов.
      </footer>
      <footer>
        21 марта 2024 г. Оптимизация Javascript для развлечения и прибыли Я часто чувствую, что код javascript в целом
        работает гораздо медленнее, чем мог бы, просто потому, что он не оптимизирован должным образом. Вот сводка
        распространенных методов оптимизации, которые я нашел полезными. Обратите внимание, что компромиссом для
        производительности часто является читаемость, поэтому вопрос о том, когда выбирать между производительностью и
        читаемостью, остается на усмотрение читателя. Я также отмечу, что разговор об оптимизации обязательно требует
        разговора о бенчмаркинге. Микрооптимизация функции в течение нескольких часов, чтобы она работала в 100 раз
        быстрее, бессмысленна, если функция изначально представляла лишь часть фактического общего времени выполнения.
        Если вы оптимизируете, первым и самым важным шагом является бенчмаркинг. Я рассмотрю эту тему в последующих
        пунктах. Также имейте в виду, что микробенчмарки часто имеют недостатки, и это может включать те, что
        представлены здесь. Я сделал все возможное, чтобы избежать этих ловушек, но не применяйте слепо ни один из
        пунктов, представленных здесь, без бенчмаркинга. Я включил примеры запуска для всех случаев, где это возможно.
        По умолчанию они показывают результаты, которые я получил на своей машине (brave 122 на archlinux), но вы можете
        запустить их самостоятельно. Как бы мне ни было неприятно это говорить, Firefox немного отстал в плане
        оптимизации и на данный момент представляет собой очень малую часть трафика , поэтому я не рекомендую
        использовать результаты, которые вы получите на Firefox, в качестве полезных индикаторов.
      </footer>
    </section> -->

    <section class="slide">
      <h2 class="shout">Косвенность</h2>
      <footer>
        <p>
          Тест proxy на V8 сейчас особенно жесток. В последний раз, когда я проверял, объекты proxy всегда откатывались
          от JIT к интерпретатору, судя по этим результатам, это все еще может быть так.
        </p>
        <p>
          Я также хотел продемонстрировать доступ к глубоко вложенному объекту по сравнению с прямым доступом, но движки
          очень хорошо оптимизируют доступ к удаленным объектам с помощью анализа выхода, когда есть горячий цикл и
          постоянный объект. Я вставил немного косвенности, чтобы предотвратить это
        </p>
        <a hrfe="https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be"
          >https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be</a
        >
      </footer>
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/indirection/1.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/indirection/2.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <scale name="proxy" d="2">
      <scale name="direct" d="100">
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/indirection/3.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/indirection/4.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <scale name="nested" d="42">
      <scale name="direct" d="100">
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте промахов кэша</h2>
      <footer>
        <p>
          Этот момент требует некоторых низкоуровневых знаний, но имеет последствия даже в javascript, поэтому я
          объясню. С точки зрения ЦП, извлечение памяти из ОЗУ происходит медленно. Для ускорения используются в
          основном две оптимизации.
        </p>
        <p>
          5.1 Предварительная выборка Первый — предварительная выборка: она заранее извлекает больше памяти в надежде,
          что это именно та память, которая вас интересует. Она всегда предполагает, что если вы запросите один адрес
          памяти, вас будет интересовать область памяти, которая идет сразу за ним. Поэтому последовательный доступ к
          данным — это ключ. В следующем примере мы можем наблюдать влияние доступа к памяти в случайном порядке.
        </p>
        <p>
          Этот аспект, вероятно, сложнее всего реализовать на практике, поскольку javascript не имеет способа размещения
          объектов в памяти, но вы можете использовать это знание в своих интересах, как в примере выше, например, для
          работы с данными перед их переупорядочением или сортировкой. Вы не можете предполагать, что объекты, созданные
          последовательно, останутся в том же месте через некоторое время, потому что сборщик мусора может переместить
          их. Есть одно исключение из этого, и это массивы чисел, предпочтительно TypedArrayэкземпляры:
        </p>
      </footer>
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/cache/1.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/pictures/theory/cache//2.svg"
        width="700"
        height="350"
        alt="Codeiupictures"
      />
    </section>

    <section class="slide">
      <scale name="sequential" p="100" />
      <scale name="random" p="26" />
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте крупных предметов</h2>
    </section>

    <!-- TUT -->

    <!-- <section class="slide">
      <p>Используйте оценку</p>
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">Работа со строками</h2>

      мутация - 37 конкатенция - 100
      <footer></footer>
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/pictures/theory/strings/1.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/pictures/theory/strings/2.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/pictures/theory/strings/3.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">Специализация</h2>

      <footer>
        <p>
          Одной из важных концепций оптимизации производительности является специализация : адаптация вашей логики для
          соответствия ограничениям вашего конкретного варианта использования. Обычно это означает выяснение того, какие
          условия, скорее всего, будут верны для вашего случая, и кодирование для этих условий. Допустим, мы торговец,
          которому иногда нужно добавлять теги в список продуктов. Мы знаем по опыту, что наши теги обычно пустые. Зная
          эту информацию, мы можем специализировать нашу функцию для этого случая
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <h2>Специализация</h2>
      <img src="./themes/tw/pictures/theory/specialization/1.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Специализация</h2>
      <img src="./themes/tw/pictures/theory/specialization/2.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Специализация</h2>
      <img src="./themes/tw/pictures/theory/specialization/3.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Специализация</h2>
      <img src="./themes/tw/pictures/theory/specialization/4.svg" width="" height="" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">Структуры данных</h2>
      <footer>
        <p>
          Я не буду вдаваться в подробности о структурах данных, так как они требуют отдельного поста. Но имейте в виду,
          что использование некорректных структур данных для вашего варианта использования может иметь большее влияние,
          чем любая из оптимизаций выше.
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <h2>Структуры данных</h2>
      <img src="./themes/tw/pictures/theory/data-structures/1.svg" width="" height="" alt="" />
      <footer>
        <p>
          Но для быстрого примера давайте сравним, как Array.includes работает функция against Set.has для небольшого
          списка
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide relative">
      <h2 class="shout">Benchmarking</h2>
      <p class="absolute">Самый важный, но и сложный</p>
      <p class="absolute">Начало кода</p>
      <p class="absolute">Сомневаетесь в своих результатах</p>
      <footer>
        <p>
          Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют большую часть
          времени выполнения. Если вы тратите время на оптимизацию чего-либо еще, кроме верхней части, вы тратите время
          впустую.
        </p>
        <p>
          Если вы только что оптимизировали функцию, и теперь она работает в 100 раз быстрее, усомнитесь в ней.
          Попробуйте опровергнуть свои результаты, попробуйте ее в режиме производства, забросайте ее всякой всячиной.
          Аналогично, усомнитесь и в своих инструментах. Сам факт наблюдения за бенчмарком с помощью devtools может
          изменить ее поведение.
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">Профилирование и инструменты</h2>
      <footer>
        <p>
          Если вы профилируете в браузере, убедитесь, что вы используете чистый + пустой профиль браузера. Я даже
          использую для этого отдельный браузер. Если вы профилируете и у вас включены расширения браузера, они могут
          испортить измерения. React devtools в частности существенно повлияют на результаты, код рендеринга может
          выглядеть медленнее, чем он есть на самом деле для ваших пользователей.
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <footer>
        <p>
          Если вы профилируете в браузере, убедитесь, что вы используете чистый и пустой профиль браузера. Я даже
          использую для этого отдельный браузер. Если вы профилируете и у вас включены расширения браузера, они могут
          испортить измерения. React devtools в частности существенно повлияют на результаты, код рендеринга может
          выглядеть медленнее, чем он есть на самом делев зеркаледля ваших пользователей. Различные движки будут
          оптимизировать определенные шаблоны лучше или хуже других. Вам следует провести бенчмаркинг для движков,
          которые имеют отношение к вам, и расставить приоритеты, какой из них важнее. Вот реальный пример в Babel, где
          улучшение V8 означает снижение производительности JSC. https://github.com/babel/babel/pull/16357 11.2
          Сомневаетесь в своих результатах Если вы только что оптимизировали функцию, и теперь она работает в 100 раз
          быстрее, усомнитесь в ней. Попробуйте опровергнуть свои результаты, попробуйте ее в режиме производства,
          забросайте ее всякой всячиной. Аналогично, усомнитесь и в своих инструментах. Сам факт наблюдения за
          бенчмарком с помощью devtools может изменить ее поведение.
        </p>
      </footer>
    </section> -->

    <section class="slide">
      <h2>Когда?</h2>
      <ul>
        <li>прилетит задача</li>
        <li>при код ревью</li>
        <li>https://github.com/facebook/react/pull/28569</li>
      </ul>
    </section>

    <!-- <section class="slide">
      <figure class="cover">
        <blockquote>
          <p>
            V8 — это высокопроизводительный движок JS и WebAssembly от Google с открытым исходным кодом, написанный на
            C++. Он используется в Chrome и Node.js. Он реализует ECMAScript и WebAssembly и работает в системах
            Windows, macOS и Linux, использующих процессоры x64, IA-32 или ARM. V8 можно встроить в любое приложение
            C++.
          </p>
        </blockquote>
        <figcaption>Документация</figcaption>
      </figure>
      <a class="copyright" href="https://v8.dev/" target="_blank" rel="noopener noreferrer">v8</a>
    </section> -->

    <!-- <section class="slide">
      <a class="copyright" href="https://v8.dev/" target="_blank" rel="noopener noreferrer"
        >https://v8.dev/blog/10-years</a
      >
    </section> -->

    <!-- <section class="slide">
      <h2 class="!my-[20px]">Числа</h2>
      <img class="cover" src="./themes/tw/pictures/theory/enum/3.svg" width="1000" height="500" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Цель доклада</h2>

      <footer>
        <p>
          при подготовке к доклау я просмотерл множество презентаций и везде плюс минус один план - рассказать про v8
          как она работает что там есть как не писать js - поэтмоу поступим также
        </p>
      </footer>
    </section> -->
<!--
    <section class="slide">
      <h2 class="!my-[20px]">Результаты</h2>
      <div class="speed">
        <div></div>
        <div></div>
      </div>
      <style>
        .speed {
          display: flex;
          flex-direction: column;
          gap: 15px 0;

          div {
            background-color: #b3441e;
            border-radius: 15px;
            height: 50px;
            padding-left: 15px;
            color: #18404a;
            font-weight: bold;
            box-shadow: 2px 2px 2px #222;
          }

          div:first-child {
            width: 50%;

            &::before {
              content: 'Числа';
            }
          }

          div:last-child {
            width: 100%;

            &::before {
              content: 'Строки';
            }
          }
        }
      </style>
    </section> -->

    <!-- <section class="slide">
      <h2>Чертовски хорошо</h2>
    </section> -->

    <!-- <section class="slide">
      <figure class="cover">
        <blockquote>
          <p>Самая опасная фраза в нашем языке: «Мы всегда так делали»</p>
        </blockquote>
        <figcaption>Мэтью А. Титмус - из некой книги серии O'Reilly</figcaption>
        <figcaption class="next">Грейс Хоппер</figcaption>
      </figure>
      <footer>
        <p>
          Эта фраза обычно указывает на то, что приверженность статус-кво или продолжение действий без изменений может
          привести к проблемам или неэффективности. В мире программирования это может относиться к антипаттернам или
          устаревшим подходам, которые могут привести к ошибкам или сложностям в будущем.
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <div class="shout flex flex-row items-center justify-center">
        <h2>premature optimization - evil</h2>
        <picture class="ml-4">
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f608/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f608/512.gif" alt="😈" width="72" height="72" />
        </picture>
      </div>
    </section> -->

    <!-- <section class="slide">
      <iframe src="http://vanilla-js.com/"></iframe>
    </section> -->

    <!-- <section class="slide">
      <h2>Выводы</h2>
      <ol>
        <li class="next"></li>
      </ol>
      <footer>
        <p>поесть пиццы</p>
        <p>Спойлер: «Преждевременная оптимизация — корень всех бед», Дональд Кнут.</p>
        <p>
          0.1 секунда — это тот gap, который позволяет пользователю осознать, что именно его клик мышки, удар по
          клавиатуре побудил эти изменения в приложении\интерфейсе.
        </p>
        <p>
          Кажется, у всех было то неловкое чувство, когда ты сочиняешь письмо\код\любой другой текст, а интерфейс "за
          тобой не успевает". Ты уже пишешь второе слово, а на экране всё еще песочные часы (если мы про windows) и
          еле-еле набирается первое. Аналогично и с кликами на кнопки. Я хочу, чтобы интерфейс мне подсказывал, мол,
          "окей, я тебя услышал, ща все будет".
        </p>
      </footer>
    </section> -->

    <!-- <section class="slide">
      <ul>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?app=desktop&v=d6zk_BwBgXo"
            >https://www.youtube.com/watch?app=desktop&v=d6zk_BwBgXo</a
          >
        </li>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?app=desktop&v=Ybz6P-l9YHc"
            >https://www.youtube.com/watch?app=desktop&v=Ybz6P-l9YHc</a
          >
        </li>
        <li>https://youtu.be/g6gC3NYP6yo?si=v8xCAZLrGncVbhBM</li>
        <li>
          Хочу реакт!<a target="_blank" rel="noopener noreferrer" href="">
            https://www.youtube.com/watch?app=desktop&v=6FsmxjCAgeE</a
          >
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=KiWEWLwQ3oI&t=1055s"
            >https://www.youtube.com/watch?v=KiWEWLwQ3oI&t=1055s</a
          >
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=SNs61SwZbTI&t=288s"
            >https://www.youtube.com/watch?v=SNs61SwZbTI&t=288s</a
          >
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a>
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a>
        </li>
      </ul>
    </section> -->

    <section class="slide">
      <h2 class="shout">Простота и предсказуемость</h2>
      <footer>
        <p>Раньше веб был таким</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Производительность – это восприятие</h2>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Спасибо за внимание!</h2>
        <picture class="ml-4">
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f3c1/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f3c1/512.gif" alt="🏁" width="72" height="72" />
        </picture>
      </div>
    </section>

    <section class="slide relative">
      <h2 class="shout">
        <div class="dots-bars"></div>
        Вопросы</h2>

        <style>
          .dots-bars {
            width: 40px;
            height: 26px;
            --c: linear-gradient(currentColor 0 0);
            background:
              var(--c) 0 100%,
              var(--c) 50% 100%,
              var(--c) 100% 100%;
            background-size: 8px calc(100% - 4px);
            background-repeat: no-repeat;
            position: relative;
          }

          .dots-bars:before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            left: 0;
            top: 0;
            animation:
              db3-1 1.5s linear infinite alternate,
              db3-2 0.75s cubic-bezier(0, 200, 0.8, 200) infinite;
          }

          @keyframes db3-1 {
            100% {
              left: calc(100% - 8px);
            }
          }

          @keyframes db3-2 {
            100% {
              top: -0.1px;
            }
          }
        </style>
    </section>

    <div class="progress before:bg-orange"></div>

    <script src="./shower.min.js"></script>

    <script>
      function initScale() {
        class Scale extends HTMLElement {
          constructor() {
            super();
          }

          connectedCallback() {
            const shadow = this.attachShadow({ mode: 'open' });

            const scale = document.createElement('div');
            const style = document.createElement('style');

            scale.setAttribute('class', 'scale');

            style.textContent = `
              .scale {
                width: 100px;
                height: 50px;
                background-color: red;
                border-radius: 5px;

                &::after {
                  content: '${this.getAttribute('name')}';
                }

                &::before {
                  content: '${this.getAttribute('percentage')}';
                }
              }
            `;

            shadow.appendChild(style);
            shadow.appendChild(scale);
          }
        }

        customElements.define('scale', Scale);
      }

      initScale();
    </script>
  </body>
</html>
