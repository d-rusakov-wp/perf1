<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="description" content="Презентация по TailwindCSS" />

    <title>Семь раз отмерь, один раз оптимизируй</title>

    <link rel="icon" href="./themes/tw/images/logo.png" type="image/svg+xml" />
    <link rel="stylesheet" href="./themes/ribbon/styles/styles.css" />
    <link rel="stylesheet" href="./bundled/main.css" />
    <link rel="stylesheet" href="./libs/highlight/hybrid.min.css" />
  </head>
  <body class="shower list scrollbar bg-green">
    <header class="caption">
      <h1>Семь раз отмерь, один раз оптимизируй</h1>
      <p class="mt-2">
        <i>Денис Русаков</i>
      </p>
    </header>

    <section class="slide p-0">
      <div class="flex h-full flex-col items-center justify-end">
        <img class="!my-10" src="./themes/tw/images/logo.png" width="250" height="250" alt="Перо" />
        <div class="text-center">
          <h2 class="!my-[20px] text-5xl">Семь раз отмерь, один раз оптимизируй</h2>
          <p class="text-md italic leading-6">
            <i class="text-gray">Денис Русаков</i>
          </p>
        </div>
      </div>
      <footer>
        <p>Всем привет</p>
        <p>На слайде изображено перо жар птицы</p>
      </footer>
    </section>

    <section class="slide">
      <div class="mt-[70px] flex flex-col items-center justify-center opacity-90">
        <div class="-mx-8 flex items-start justify-center gap-8">
          <img src="./themes/tw/images/o-reilly/1.jpg" width="200" height="200" alt="Книга 1" />
          <img src="./themes/tw/images/o-reilly/2.jpg" width="200" height="200" alt="Книга 2" />
          <img src="./themes/tw/images/o-reilly/3.jpg" width="200" height="200" alt="Книга 3" />
        </div>
        <img class="mt-8" src="./themes/tw/images/o-reilly/logo.svg" width="400" height="200" alt="Логотип O'Reilly" />
        <a target="_blank" rel="noopener noreferrer" class="copyright" href="https://www.oreilly.com/">o'reilly</a>
      </div>
      <footer>
        <p>Многие на обложках находятся на грани вымирания</p>
      </footer>
    </section>

    <section class="slide">
      <img class="cover rounded-md" src="./themes/tw/images/bird.jpg" width="736" height="490" alt="Жар птица" />
      <footer>
        <p>Птица из новой Гвинеи</p>
        <p>
          Сказание о необычной пташке зародилось еще в стародавние времена. Наши предки тогда верили в Перуна – бога
          грома и справедливости. Иногда он являлся в образе Жар-птицы. По другим легендам, она была символом бессмертия
          и богатства, поэтому добыть себе перо из ее хвоста считалось настоящим счастьем
        </p>
        <p>Перо - это производительность, которую нам иногда необходимо достичь/поймать?</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="cover">Цель доклада</h2>
      <footer>
        <p>
          при подготовке к докладу я просмотрел множество презентаций и везде плюс минус один план - рассказать про v8
          как она работает, что там есть как не писать js - поэтому поступим также
        </p>
      </footer>
    </section>

    <section class="slide">
      <figure class="place w-[55%]">
        <blockquote class="flex items-start">
          <p>Преждевременная оптимизация — корень всех бед</p>
        </blockquote>
        <figcaption>Дональд Кнут</figcaption>
      </figure>
    </section>

    <section class="slide group">
      <h2>Какой план?</h2>
      <img
        class="next float-right translate-x-[70px] translate-y-[200px] group-has-[#first-item.active]:hidden"
        src="./themes/tw/images/memes/plan.jpg"
        width="300"
        alt="183"
        aria-hidden="true"
      />
      <ol>
        <li class="next" id="first-item">Теория</li>
        <li class="next">
          Практика
          <span class="next">(набор приемов/советов)</span>
        </li>
        <li class="next">Выводы</li>
      </ol>
      <footer>
        <p>В теории подведу через некоторые истории и кейсы к сути темы</p>
        <p>V8 — движок с открытым исходным кодом, написан на C++, его разработкой занимается Google.</p>
      </footer>
    </section>

    <section class="slide with-title">
      <h2 class="cover text-left"><span class="text-gray">Акт 1.</span><br />Теория</h2>
    </section>

    <section class="slide">
      <p class="place"><b>Движок JS</b> — специализированная программа, обрабатывающая JS, в частности, в браузерах.</p>
      <!-- <a target="_blank" rel="noopener noreferrer" href="">https://v8.dev/blog/react-cliff</a> -->
      <footer>
        <p>
          Почему был создан движок V8? Движок с открытым кодом V8 был создан компанией Google, он написан на C++. Движок
          используется в браузере Google Chrome. Кроме того, что отличает V8 от других движков, он применяется в
          популярной серверной среде Node.js.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Какие&nbsp;движки&nbsp;существуют?</h2>
      <ul class="">
        <li class="next flex items-center">
          V8
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next flex items-center">
          SpiderMonkey
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next flex items-center">
          Chakra / ChakraCore
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next flex items-center">
          Nitro
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next flex items-center">
          Rhino
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next flex items-center">
          JerryScript
          <img class="next ml-4" src="./themes/tw/images/browsers/chrome.svg" alt="" width="56" height="56" />
        </li>
        <li class="next">и другие</li>
      </ul>
      <footer>
        <p>V8 - это основной движок в Node.js, как и во всех Chrome Based браузерах</p>
        <p>
          Всеми нелюбимая Chakra, которая находится в Internet Explorer. Она даже работает не с JavaScript, а с Jscript
          — есть такое подмножество.
        </p>
        <p>Современные Chakra и ChakraCore, которые работают в Edge;</p>
        <p>SpiderMonkey в FireFox;</p>
        <p>
          JavaScriptCore в WebKit. Также он используется в React Native. Если у вас RN-приложение под Android, то оно
          так же исполняется на JavaScriptCore — движок идёт в комплекте с приложением.
        </p>
        <p>
          Rhino и Nashorn — это движки, которые используются в Java. С их помощью там тоже можно исполнять JavaScript
        </p>
        <p>JerryScript — для встраиваемых устройств;</p>
        <p>
          О двух компиляторах, которые использовались в V8 Внутреннее устройство V8 изменилось с выходом версии 5.9,
          которая появилась совсем недавно. До этого же он использовал два компилятора: full-codegen — простой и очень
          быстрый компилятор, который выдаёт сравнительно медленный машинный код. Crankshaft — более сложный
          оптимизирующий JIT-компилятор, который генерирует хорошо оптимизированный код. Внутри движка используются
          несколько потоков: Главный поток, который занимается тем, что от него можно ожидать: читает исходный JS-код,
          компилирует его и выполняет. Поток компиляции, который занимается оптимизацией кода в то время, когда
          выполняется главный поток. Поток профилировщика, который сообщает системе о том, в каких методах программа
          тратит больше всего времени, как результат, Crankshaft может эти методы оптимизировать. Несколько потоков,
          которые поддерживают механизм сборки мусора. При первом исполнении JS-кода V8 задействует компилятор
          full-codegen, который напрямую, без каких-либо дополнительных трансформаций, транслирует разобранный им
          JavaScript-код в машинный код. Это позволяет очень быстро приступить к выполнению машинного кода. Обратите
          внимание на то, что V8 не использует промежуточное представление программы в виде байт-кода, таким образом,
          устраняя необходимость в интерпретаторе. После того, как код какое-то время поработает, поток профилировщика
          соберёт достаточно данных для того, чтобы система могла понять, какие методы нужно оптимизировать. Далее, в
          другом потоке, начинается оптимизация с помощью Crankshaft. Он преобразует абстрактное синтаксическое дерево
          JavaScript в высокоуровневое представление, использующее модель единственного статического присваивания
          (static single-assignment, SSA). Это представление называется Hydrogen. Затем Crankshaft пытается
          оптимизировать граф потока управления Hydrogen. Большинство оптимизаций выполняется на этом уровне.
        </p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="m-0">Как устроен <i>V8</i> ?</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/images/emoji/eyes.webp" type="image/webp" />
          <img src="./themes/tw/images/emoji/eyes.gif" alt="👀" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>
          В движке V8 нет интерпретатров, но существует 2 типа компиляторов - общий и оптимизирующий. Это привод к тмоу,
          что JS всегда копилируется и заускается так же как и машинный код. Означает ли это, что код работает быстро?
          Нет, Сама по себе компиляция не ускоряет работу кода. Она позволяет избежать накалыднх расходов, вызваных
          работй интерпертаора, но неоптимизированный код убедт рабоатт медленно.
        </p>
        <p>Через скрытые классы V8 идентифицирует обьектыю</p>
        <p>
          когда вы создаете новый обьект движок создаст для него новый скрытый класс. Затем если вы измените тот же
          обьект добавив новое свойцство мезанизм создаст новый скрытый класс со всеми свойствам из предыдщуего клкасс и
          включит новое свойство
        </p>
        <p>Мономофризм что у обьектов одинакоыве ключи без олтичий</p>
        <p>Мегаморфизм тут обьекты совершенно разные и их нельзя сравнивать</p>
        <p>Полиморфизм у обьектов общая струкутура но меняются небольшие отличия</p>
      </footer>

      <!-- <h2>
        прилетали баги

        <pre>
          const obj = { name: 'Test' }

          const objClassId = ['name', 1]

          const obj = {...objClassId, 'Test'}

          obj.name

          obj[getProp(obj[0], name)]

          механизмы оптимизации выполнения js
        </pre>
        <picture>
          <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6ec/512.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6ec/512.gif" alt="🛬" width="32" height="32" />
        </picture>
      </h2> -->
      <!-- <picture>
        <source srcset="https://fonts.gstatic.com/s/e/notoemoji/latest/1f680/512.webp" type="image/webp" />
        <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f680/512.gif" alt="🚀" width="32" height="32" />
      </picture> -->
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/theory/codeium/1.png" width="989" height="316" alt="Codeium 1" />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/theory/codeium/2.jpg" width="989" height="316" alt="Codeium 2" />
    </section>

    <section class="slide">
      <h2 class="place">Он&nbsp;развивается?</h2>
      <a class="copyright" href="https://v8.dev/" target="_blank" rel="noopener noreferrer">10 years</a>
    </section>

    <section class="slide with-title">
      <h2 class="cover text-left"><span class="text-gray">Акт 2.</span><br />Практика</h2>
    </section>

    <section class="slide">
      <h2 class="cover">Чем измерять?</h2>
      <footer>
        <p>Необходимо ответить на вопрос</p>
        <p>Я не буду разбирать кейсы, а расскажу о возможностях и вы сами попробуете применить их на своих проектах</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Java Script <span class="next">(клин клином)</span></h2>
    </section>

    <section class="slide">
      <h2 class="shout">Но я пишу на React!</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Но я пишу на Vue!</h2>
    </section>

    <section class="slide clear relative">
      <iframe
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm"
        title="Vanilla js"
        width="700"
        height="700"
        id="iframe-vanilla-js"
      ></iframe>
      <button
        class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 rounded-sm bg-orange px-4 text-white transition-colors hover:bg-orange/80 hover:text-white"
        type="button"
        id="upload-iframe"
      >
        Нажми меня
      </button>
      <script>
        document.addEventListener('DOMContentLoaded', function () {
          const uploadIframe = document.querySelector('#upload-iframe');
          const iframeVanillaJs = document.querySelector('#iframe-vanilla-js');

          uploadIframe.addEventListener('click', function () {
            iframeVanillaJs.src = 'https://vanilla-js.com';
            iframeVanillaJs.classList.add('z-10');
          });
        });
      </script>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/memes/everywhere.jpg" alt="" width="1580" height="1188" />
    </section>

    <section class="slide">
      <h2 class="cover">Dev Tools</h2>
      <a class="copyright" href="https://www.youtube.com/watch?v=70XMVfGv2Q0" target="_blank" rel="noopener noreferrer"
        >Chrome DevTools — спрятанные полезности</a
      >
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/memes/directed-by.jpg" alt="" width="1200" height="750" />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/theory/dev-tools/network.png" alt="" width="1921" height="1080" />
      <footer>
        <p>Кто уже попробовал с 129 хрома новую вкладку?</p>
      </footer>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/theory/dev-tools/perfomance.png" alt="" width="1921" height="1080" />
      <a
        class="copyright"
        href="https://github.com/iamakulov/devtools-perf-features"
        target="_blank"
        rel="noopener noreferrer"
        >(devtools-perf-features)</a
      >
      <footer>
        <p>
          Если вы профилируете в браузере, убедитесь, что вы используете чистый и пустой профиль браузера. Я даже
          использую для этого отдельный браузер. Если вы профилируете и у вас включены расширения браузера, они могут
          испортить измерения. React devtools в частности существенно повлияют на результаты, код рендеринга может
          выглядеть медленнее, чем он есть на самом делев зеркаледля ваших пользователей. Различные движки будут
          оптимизировать определенные шаблоны лучше или хуже других. Вам следует провести бенчмаркинг для движков,
          которые имеют отношение к вам, и расставить приоритеты, какой из них важнее. Вот реальный пример в Babel, где
          улучшение V8 означает снижение производительности JSC. https://github.com/babel/babel/pull/16357 11.2
          Сомневаетесь в своих результатах Если вы только что оптимизировали функцию, и теперь она работает в 100 раз
          быстрее, усомнитесь в ней. Попробуйте опровергнуть свои результаты, попробуйте ее в режиме производства,
          забросайте ее всякой всячиной. Аналогично, усомнитесь и в своих инструментах. Сам факт наблюдения за
          бенчмарком с помощью devtools может изменить ее поведение.
        </p>
      </footer>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/theory/dev-tools/memory.png" alt="" width="1921" height="1080" />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/theory/dev-tools/perfomance-insights.png"
        alt=""
        width="1921"
        height="1080"
      />
    </section>

    <section class="slide">
      <h2 class="shout">React Developer Tools</h2>
      <a
        class="copyright"
        href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en"
        >React Developer Tools</a
      >
    </section>

    <section class="slide">
      <h2 class="shout">Техники оптимизации</h2>
    </section>

    <section class="slide">
      <h2>Lazy load</h2>
      <img class="cover" src="./themes/tw/images/techniques/lazy-load.gif" width="2000" height="860" alt="Lazy load" />
    </section>

    <section class="slide">
      <h2>Tree shaking</h2>
      <img
        class="cover"
        src="./themes/tw/images/techniques/tree-shaking.png"
        width="1486"
        height="895"
        alt="Tree shaking"
      />
    </section>

    <section class="slide">
      <h2>Minify code</h2>
      <img class="cover" src="./themes/tw/images/techniques/minified.png" width="1857" height="841" alt="Minified" />
    </section>

    <!-- <section class="slide">
      <h2>Алгоритмы</h2>
      <ul>
        <li>
          выбрать метрики, которыми можно можно охарактериозовать "степень оптимальности" нашего сайта или приложения
        </li>
        <li>найти код сильене всего ухудшающий метрики</li>
        <li>внести изменния в код</li>
        <li>измерить новые значения</li>
        <li>повторить</li>
      </ul>
    </section> -->

    <section class="slide">
      <h2 class="place">Этого бывает мало...</h2>
    </section>

    <section class="slide">
      <h2 class="shout"><span>===</span><br />Сравнение строк</h2>
      <footer>
        <p>
          Javascript позволяет легко скрыть реальную стоимость сравнения строк. Если вам нужно сравнить строки в C, вы
          бы использовали функцию strcmp(a, b). Javascript использует ===вместо этого , поэтому вы не видите strcmp. Но
          он есть, и сравнение строк обычно (но не всегда) требует сравнения каждого символа в строке с символами в
          другой строке; сравнение строк — это O(n). Один из распространенных шаблонов JavaScript, которого следует
          избегать, — это строки как перечисления. Но с появлением TypeScript этого должно быть легко избежать,
          поскольку перечисления по умолчанию являются целыми числами.
        </p>
        <p>
          Процентные результаты представляют собой количество операций, выполненных в течение 1 с, деленное на
          количество операций в случае с наивысшей оценкой. Чем выше, тем лучше.
        </p>
        <p>
          Как видите, разница может быть существенной. Разница не обязательно связана со strcmpстоимостью, поскольку
          движки иногда могут использовать пул строк и сравнивать по ссылке, но она также связана с тем, что целые числа
          обычно передаются по значению в движках JS, тогда как строки всегда передаются как указатели, а доступ к
          памяти является дорогостоящим (см. раздел 5). В коде с большим количеством строк это может иметь огромное
          влияние. В качестве примера из реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в 2
          раза быстрее *, просто заменив строковые константы числами. *К сожалению, он не был объединен, но таков
          принцип работы с открытым исходным кодом.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // #1
          enum Position {
            TOP    = 'TOP',
            BOTTOM = 'BOTTOM',
          }

          // #2
          enum Position {
            TOP,    // = 0
            BOTTOM, // = 1
          }
        </code>
      </pre>
      <!--      <img class="cover" src="./themes/tw/images/theory/enum/1.svg" width="1000" height="500" alt="" />-->
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          let _ = 0;

          for (let i = 0; i < 1000000; i++) {
            let current = i % 2 === 0 ? Position.TOP : Position.BOTTOM;

            if (current === Position.TOP) {
              _ += 1;
            }
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="string" percentage="50"></custom-scale>
        <custom-scale name="int" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте разных форм</h2>
      <footer>
        <p>
          Движки Javascript пытаются оптимизировать код, предполагая, что объекты имеют определенную форму, и что
          функции будут получать объекты той же формы. Это позволяет им хранить ключи формы один раз для всех объектов
          этой формы, а значения — в отдельном плоском массиве. Чтобы представить это в javascript:
        </p>
        <p>
          Я использовал слово «форма» для описания этой концепции, но имейте в виду, что вы также можете встретить
          термины «скрытый класс» или «карта» для ее описания, в зависимости от движка.
        </p>
        <p>
          Например, если во время выполнения следующая функция получает два объекта с формой { x: number, y: number },
          движок предположит, что будущие объекты будут иметь такую ​​же форму, и сгенерирует машинный код,
          оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не с формой, { x, y }а с формой { y, x }, движку нужно будет отменить свое
          предположение, и функция внезапно станет значительно медленнее. Я собираюсь ограничить свое объяснение здесь,
          потому что вам следует прочитать превосходный пост от mraleph, если вы хотите больше подробностей, но я
          собираюсь подчеркнуть, что V8, в частности, имеет 3 режима для доступа, которые являются: мономорфный (1
          форма), полиморфный (2-4 формы) и мегаморфный (5+ форм). Допустим, вы действительно хотите оставаться
          мономорфным, потому что замедление радикально:
        </p>
        <p>
          Движки обычно могут кодировать целые числа как значения. Например, V8 представляет значения в 32 битах, причем
          целые числа представляют собой компактные значения Smi (SMall Integer), но числа с плавающей точкой и большие
          целые числа передаются как указатели, как строки и объекты. JSC использует 64-битное кодирование, двойное
          тегирование , чтобы передавать все числа по значению, как это делает SpiderMonkey, а остальное передается как
          указатели.
        </p>
        <p>https://github.com/facebook/react/pull/28569</p>
        <p>
          Что, черт возьми, мне с этим делать? Легче сказать, чем сделать, но: создайте все свои объекты с одинаковой
          формой . Даже что-то столь тривиальное, как написание свойств компонента React в другом порядке, может вызвать
          это . Например, вот простые случаи, которые я нашел в кодовой базе React, но у них уже был случай с гораздо
          более сильным влиянием той же проблемы несколько лет назад, потому что они инициализировали объект целым
          числом, а затем сохраняли число с плавающей точкой. Да, изменение типа также меняет форму. Да, есть целые и
          плавающие типы, скрытые за number. Разберитесь с этим.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // Вводные
          const objects = [
            {
              name: 'Анатолий',
              age: 36,
            },
            {
              name: 'Иннокентий',
              age: 42
            },
          ];
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const shape = [
            { name: 'name', type: 'string' },
            { name: 'age',  type: 'integer' },
          ];

          const objects = [
            ['Анатолий', 36],
            ['Иннокентий', 42],
          ];
        </code>
      </pre>
      <footer>
        <p>
          Например, если во время выполнения следующая функция получает два объекта с формой { x: number, y: number },
          движок предположит, что будущие объекты будут иметь такую ​​же форму, и сгенерирует машинный код,
          оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не с формой, { x, y }а с формой { y, x }, движку нужно будет отменить свое
          предположение, и функция внезапно станет значительно медленнее. Я собираюсь ограничить свое объяснение здесь,
          потому что вам следует прочитать превосходный пост от mraleph, если вы хотите больше подробностей, но я
          собираюсь подчеркнуть, что V8, в частности, имеет 3 режима для доступа, которые являются: мономорфный (1
          форма), полиморфный (2-4 формы) и мегаморфный (5+ форм). Допустим, вы действительно хотите оставаться
          мономорфным, потому что замедление радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          function add(a, b) {
            return {
              x: a.x + b.x,
              y: a.y + b.y
            }
          }
        </code>
      </pre>
      <footer>
        <p>
          Например, если во время выполнения следующая функция получает два объекта с формой { x: number, y: number },
          движок предположит, что будущие объекты будут иметь такую ​​же форму, и сгенерирует машинный код,
          оптимизированный для этой формы.
        </p>
        <p>
          Если вместо этого передать объект не с формой, { x, y }а с формой { y, x }, движку нужно будет отменить свое
          предположение, и функция внезапно станет значительно медленнее. Я собираюсь ограничить свое объяснение здесь,
          потому что вам следует прочитать превосходный пост от mraleph, если вы хотите больше подробностей, но я
          собираюсь подчеркнуть, что V8, в частности, имеет 3 режима для доступа, которые являются: мономорфный (1
          форма), полиморфный (2-4 формы) и мегаморфный (5+ форм). Допустим, вы действительно хотите оставаться
          мономорфным, потому что замедление радикально:
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // Вводные
          let _ = 0;

          // Monomorphic
          const o1 = { a: 1, b: _, c: _, d: _ };
          const o2 = { a: 1, b: _, c: _, d: _ };
          const o3 = { a: 1, b: _, c: _, d: _ };
          const o4 = { a: 1, b: _, c: _, d: _ };

          // Polymorphic
          const o1 = { a: 1, b: _, c: _, d: _ };
          const o2 = { a: 1, b: _, c: _, d: _ };
          const o3 = { a: 1, b: _, c: _, d: _ };
          const o4 = { a: 1, b: _, c: _, d: _ };

          // Megamorphic
          const o1 = { a: 1, b: _, c: _, d: _ };
          const o2 = { b: _, a: 1, c: _, d: _ };
          const o3 = { b: _, c: _, a: 1, d: _ };
          const o4 = { b: _, c: _, d: _, a: 1 };
        </code>
      </pre>
      <a class="copyright" href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">monomorphism</a>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          function add(a1, b1) {
            return a1.a + a1.b + a1.c + a1.d +
                   b1.a + b1.b + b1.c + b1.d;
          }

          let result = 0;

          for (let i = 0; i < 1000000; i++) {
            result += add(o1, o2);
            result += add(o3, o4);
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div class="place w-[50%]">
        <custom-scale name="megamorphic" percentage="4"></custom-scale>
        <custom-scale name="polymorphic" percentage="13"></custom-scale>
        <custom-scale name="monomorphism" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <div class="place flex flex-col items-center">
        <div class="mb-4">[...] {...}</div>
        <h2>Избегайте методов<br />массивов/объектов</h2>
      </div>
      <footer>
        <p>нет, вы не зря сдавали или будете сдавть компитишн про методы массивов</p>
      </footer>
    </section>

    <section class="slide relative">
      <img
        class="absolute left-[50%] top-[50%] -translate-x-[50%] -translate-y-[50%]"
        src="./themes/tw/images/practice/skills-team/1.jpg"
        alt=""
        width="392"
        height="137"
      />
      <img
        class="next translate-x-[450px] translate-y-[150px] rotate-[30deg]"
        src="./themes/tw/images/practice/skills-team/2.jpg"
        alt=""
        width="356"
        height="123"
      />
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // Вводные
          const numbers = Array.from({ length: 10_000 }).map(() => Math.random());

          // 1. functional
          const result =
            numbers
              .map(n => Math.round(n * 10))
              .filter(n => n % 2 === 0)
              .reduce((a, n) => a + n, 0);

          // 2. imperative
          let result = 0;

          for (let i = 0; i < numbers.length; i++) {
            let n = Math.round(numbers[i] * 10);
            if (n % 2 !== 0) continue;

            result = result + n;
          }
        </code>
      </pre>
      <footer>
        <p>
          Я люблю функциональное программирование так же, как и все остальные, но если вы не работаете с
          Haskell/OCaml/Rust, где функциональный код компилируется в эффективный машинный код, то функциональное
          программирование всегда будет медленнее императивного.
        </p>
        <p>Проблема с этими методами заключается в следующем:</p>
        <p>
          Им нужно сделать полную копию массива, и эти копии позже должны быть освобождены сборщиком мусора. Мы более
          подробно рассмотрим вопросы ввода-вывода памяти в разделе 5.
        </p>
        <p>Они выполняют цикл N раз для N операций, тогда как for цикл допускает выполнение цикла один раз.</p>
        <p>
          Методы объектов, такие как Object.values(), Object.keys()и Object.entries()страдают от похожих проблем, так
          как они также выделяют больше данных, а доступ к памяти является корнем всех проблем с производительностью.
          Нет, правда, я клянусь, я покажу вам в разделе 5.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <div>
        <custom-scale name="Функциональный подход" percentage="36"></custom-scale>
        <custom-scale name="Императивный подход" percentage="100"></custom-scale>
      </div>
    </section>

    <!-- <section class="slide">
      производительность - это не математика
      <a href="https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/" target="_blank" rel="noopener noreferrer"
        >Видео с Rutube</a
      >
      <a href="https://v8.dev/blog/react-cliff" target="_blank" rel="noopener noreferrer"
        >https://v8.dev/blog/react-cliff</a
      >
      <a href="https://almanac.httparchive.org/en/2022/page-weight" target="_blank" rel="noopener noreferrer"
        >https://almanac.httparchive.org/en/2022/page-weight</a
      >
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">JNT (Just Noticeable Difference)</h2>
    </section> -->

    <!-- <section class="slide">
      <p>да кому оно надо</p>
      <footer>
        <p>бизнесу</p>
      </footer>
    </section> -->

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Используйте eval</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/images/emoji/evil.webp" type="image/webp" />
          <img src="./themes/tw/images/emoji/evil.gif" alt="😈" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>
          Некоторые шаблоны javascript трудно оптимизировать для движков, и с помощью использования eval()или его
          производных вы можете заставить эти шаблоны исчезнуть. В этом примере мы можем наблюдать, как использование
          eval()позволяет избежать затрат на создание объекта с динамическим ключом объекта:
        </p>
        <p>
          Другим хорошим вариантом использования evalможет быть компиляция функции предиката фильтра, где вы
          отбрасываете ветви, которые, как вы знаете, никогда не будут выполнены. В общем, любая функция, которая будет
          запущена в очень горячем цикле, является хорошим кандидатом для такого рода оптимизации.
        </p>
        <p>
          Очевидно, что обычные предупреждения eval()применимы: не доверяйте пользовательскому вводу, очищайте все, что
          передается в eval()'d-код, и не создавайте никаких возможностей XSS. Также обратите внимание, что некоторые
          среды не разрешают доступ к eval(), например, страницы браузера с CSP.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>С eval</h2>
      <pre>
        <code class="language-typescript">
          const key = "requestId";
          const values = Array.from({ length: 100_000 }).fill(42)

          function createMessages(key, values) {
            const messages = []
            for (let i = 0; i < values.length; i++) {
              messages.push({ [key]: values[i] })
            }
            return messages
          }

          createMessages(key, values)
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Без eval</h2>
      <pre>
        <code class="language-typescript">
          const key = "requestId";
          const values = Array.from({ length: 100_000 }).fill(42)

          function createMessages(key, values) {
            const messages = [];
            const createMessage = new Function('value',
              `return { ${JSON.stringify(key)}: value }`
            )
            for (let i = 0; i < values.length; i++) {
              messages.push(createMessage(values[i]))
            }
            return messages
          }

          createMessages(key, values)
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2 class="shout">Используйте строки, осторожно</h2>
      <footer>
        <p>
          Мы уже видели выше, что строки дороже, чем кажутся. Ну, у меня тут есть своего рода ситуация хороших/плохих
          новостей, которую я объявлю в единственном логическом порядке (сначала плохие, потом хорошие): строки сложнее,
          чем кажутся, но их также можно довольно эффективно использовать.
        </p>
        <p>
          Строковые операции являются основной частью JavaScript из-за его контекста. Чтобы оптимизировать код,
          насыщенный строками, движки должны были быть креативными. Под этим я подразумеваю, что они должны были
          представлять Stringобъект с помощью множественного строкового представления в C++, в зависимости от варианта
          использования. Есть два общих случая, о которых вам следует беспокоиться, поскольку они справедливы для V8
          (наиболее распространенного движка на сегодняшний день), а также, как правило, и для других движков.
        </p>
        <p>
          Но вот в чем проблема: как только вам нужно начать мутировать эти байты, в этот момент вы начинаете платить за
          копирование. Допустим, мы возвращаемся к нашему String классу и пытаемся добавить .trimEnd метод:
        </p>
        <p>Что, черт возьми, мне с этим делать?</p>
        <p>
          В общем, старайтесь избегать мутаций как можно дольше.trim() . Это включает такие методы , как .replace(), и
          т. д. Подумайте, как можно избежать этих методов. В некоторых движках шаблоны строк также могут быть
          медленнее, чем +. В V8 на данный момент это так, но может не быть в будущем, поэтому, как всегда, бенчмарк.
        </p>
        <p>
          Примечание SlicedString выше: следует отметить, что если в памяти находится небольшая подстрока очень большой
          строки,это может бытьне позволяйте сборщику мусора собирать большую строку! Если вы обрабатываете большие
          тексты и извлекаете из них маленькие строки, вы можете допустить утечку большого объема памяти.
        </p>
        <p>
          Решение здесь — использовать методы мутации в наших интересах. Если мы используем один из них на small, это
          приведет к принудительному копированию, и старый указатель на largeбудет потерян:
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const classNames = ['primary', 'selected', 'active', 'medium']
          // 1. mutation
          const result =
            classNames
              .map(c => `button--${c}`)
              .join(' ')
          // 2. concatenation
          const result =
            classNames
              .map(c => 'button--' + c)
              .reduce((acc, c) => acc + ' ' + c, '')
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const large = Array.from({ length: 10_000 }).map(() => 'string').join('')
          const small = large.slice(0, 50)
          //    ^ will keep `large` alive
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // replace a token that doesn't exist
          const small = small.replace('#'.repeat(small.length + 1), '')
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результат выполнения</h2>
      <custom-scale name="" percentage="37"></custom-scale>
      <custom-scale name="" percentage="100"></custom-scale>
    </section>

    <section class="slide">
      <h2>0. Избегать работы</h2>
      <footer>
        <p>
          Это может показаться очевидным, но это должно быть здесь, потому что не может быть другого первого шага к
          оптимизации: если вы пытаетесь оптимизировать, вы должны сначала рассмотреть возможность избегания работы. Это
          включает в себя такие концепции, как мемоизация, лень и инкрементальные вычисления. Это будет применяться
          по-разному в зависимости от контекста. В React, например, это будет означать применение memo()и
          useMemo()других применимых примитивов.
        </p>
        <p>
          Я часто чувствую, что код javascript в целом работает гораздо медленнее, чем мог бы, просто потому, что он не
          оптимизирован должным образом. Вот сводка распространенных методов оптимизации, которые я нашел полезными.
          Обратите внимание, что компромиссом для производительности часто является читаемость, поэтому вопрос о том,
          когда выбирать между производительностью и читаемостью, остается на усмотрение читателя. Я также отмечу, что
          разговор об оптимизации обязательно требует разговора о бенчмаркинге. Микрооптимизация функции в течение
          нескольких часов, чтобы она работала в 100 раз быстрее, бессмысленна, если функция изначально представляла
          лишь часть фактического общего времени выполнения. Если вы оптимизируете, первым и самым важным шагом является
          бенчмаркинг. Я рассмотрю эту тему в последующих пунктах. Также имейте в виду, что микробенчмарки часто имеют
          недостатки, и это может включать те, что представлены здесь. Я сделал все возможное, чтобы избежать этих
          ловушек, но не применяйте слепо ни один из пунктов, представленных здесь, без бенчмаркинга.
        </p>
        <p>
          Я включил примеры запуска для всех случаев, где это возможно. По умолчанию они показывают результаты, которые
          я получил на своей машине (brave 122 на archlinux), но вы можете запустить их самостоятельно. Как бы мне ни
          было неприятно это говорить, Firefox немного отстал в плане оптимизации и на данный момент представляет собой
          очень малую часть трафика , поэтому я не рекомендую использовать результаты, которые вы получите на Firefox, в
          качестве полезных индикаторов.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="place">TS</h2>
    </section>

    <section class="slide">
      <h2 class="shout">В чём разница между типом и интерфейсом?</h2>
    </section>

    <section class="slide">
      <h2 class="shout">Что быстрее типы или интерфейсы?</h2>
      <footer>
        <p>Предпочитайте интерфейсы пересечениям</p>
        <p>Отношения типов между интерфейсами кешируется, в отличие от типов пересения.</p>
      </footer>
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/practice/ts/perfomance.jpg"
        width="1001"
        height="996"
        alt="Perfomance"
      />
    </section>

    <section class="slide">
      <h2 class="place">Написание легкокомпилируемого кода</h2>
    </section>

    <section class="slide">
      <h2>Использование аннотирования типов</h2>
      <pre>
        <code class="language-typescript">
          - import { otherFunc } from "other";
          + import { otherFunc, otherType } from "other";

          - export function func() {
          + export function func(): otherType {
                return otherFunc();
            }
        </code>
      </pre>
      <footer>
        <p>
          Добавление аннотирования типов, особенно для возвращаемых значений, может сэкономить компилятору кучу работы.
          Отчасти потому, что именованные типы обычно компактнее анонимных (которые компилятор может приводить), что
          уменьшает время на чтение и запись объявляющих файлов (например, для инкрементальных сборок). Приведение типов
          очень удобно, так что нет нужды делать это универсально. Но бывает полезно попробовать, когда находишь в своём
          коде медленные фрагменты.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Как найти неиспользуемые типы</h2>

      <pre>
        <code class="language-typescript">
          const { createClient } = require('contentful')

          const CONTENTFUL_ACCESS_TOKEN = '...' // Insert your access token here
          const CONTENTFUL_SPACE_ID = '...' // Insert your space ID here

          const client = createClient({
              space: CONTENTFUL_SPACE_ID,
              accessToken: CONTENTFUL_ACCESS_TOKEN,
          })

          ;(async () => {
              const contentTypes = await client.getContentTypes().then((result) => result.items)

              for (const contentType of contentTypes) {
                  const entries = await client.getEntries({ content_type: contentType.sys.id }).then((result) => result.items)

                  console.log(entries.length, 'entries:', contentType.sys.id)
              }
          })()
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Сайт должен ассоциироваться с вашим бизнесом с первой секунды посещения.</h2>
      <p>
        Если в течение 10-15 секунд пользователь не покинул ваш сайт, то это почти успех. Главная страница — лицо вашей
        фирмы в интернете. Захватите внимание пользователя, удержите его и перенаправьте на нужные ему разделы.
        Эффективно работающая главная страница сайта является четвертой татуировкой для вашего ресурса.
      </p>
    </section>

    <section class="slide">
      <p>
        Постоянные улучшения Чтобы сайт не лежал мертвым грузом в сети интернет, а работал как один из ваших лучших
        сотрудников, необходимо время от времени производить анализ поведения пользователей и делать выводы, основываясь
        на этих данных, повышать конверсию (превращение обычного пользователя в лояльного клиента). Постоянные
        улучшения — 15 татуировка для вашего сайта.
      </p>
    </section>

    <section class="slide">
      Акцент на качество и доверие Доверие к вашей компании будет стимулировать посетителя вашего сайта к покупке.
      Поэтому очень важно заполучить его расположение. В этом поможет размещенная на сайте следующая информация:
      официальная отчетность о деятельности вашей организации, информация о партнерах, ссылки на приложения вашего
      ресурса, данные по количеству просмотров каждой из статей на сайте, возможность оставлять комментарии и отзывы
      на вашем сайте, удобное портфолио с вашими реальными работами, фото ваших сотрудников, ссылки на социальные сети
      и т.д. Также предоставьте клиентам все необходимые гарантии: продемонстрируйте свои награды, сертификаты качества
      продукции, грамоты и лицензии.
    </section>

    <section class="slide">
      <h2>Контроль за добавлением @types</h2>
      <pre>
        <code class="language-typescript">
          // src/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Don't automatically include anything.
                   // Only include `@types` packages that we need to import.
                   "types" : []
               },
               "files": ["foo.ts"]
            }

            // tests/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Only include `@types/node` and `@types/mocha`.
                   "types" : ["node", "mocha"]
               },
               "files": ["foo.test.ts"]
            }
        </code>
      </pre>
      <footer>
        <p>
          По умолчанию TypeScript автоматически добавляет все найденные в папке node_modules пакеты @types, вне
          зависимости от того, импортировали вы их или нет. Это сделано для того, чтобы определённые функции «просто
          работали» при использовании Node.js, Jasmine, Mocha, Chai и т. д., так как эти инструменты/пакеты не
          импортируются, а загружаются в глобальное окружение. Иногда эта логика может замедлять компиляцию и
          редактирование программы. И даже приводить к конфликтам объявлений в многочисленных глобальных пакетах,
          которые вызывают подобные ошибки:
        </p>
      </footer>
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/practice/ts/type-interface.jpg"
        width="1074"
        height="309"
        alt="Type or interface"
      />
    </section>

    <section class="slide">
      <p>
        Одно из когнитивных искажений, проявляющееся в тенденции людей недооценивать последствия бездействия в сравнении
        с действием с аналогичным результатом. Люди более ответственно относятся к своим действиям, чем к бездействию.
      </p>
      <p>
        Эмпирический психофизиологический закон, заключающийся в том, что интенсивность ощущения чего-либо прямо
        пропорциональна логарифму интенсивности раздражителя. Иллюстрируется так: люстра, в которой восемь лампочек,
        кажется настолько же ярче люстры из четырёх лампочек, насколько люстра из четырёх лампочек ярче люстры из двух
        лампочек. То есть количество лампочек должно увеличиваться в одинаковое число раз, чтобы казалось, что прирост
        яркости постоянен. И наоборот, если абсолютный прирост яркости (разница в яркости «после» и «до») постоянен, то
        будет казаться, что абсолютный прирост уменьшается по мере роста самого значения яркости. Например, если
        добавить одну лампочку к люстре из двух лампочек, то кажущийся прирост в яркости будет значительным. Если же
        добавить одну лампочку к люстре из 12 лампочек, то прирост яркости практически незаметен.
      </p>
      <p>
        Также известно как «эффект негатива». Склонность, согласно которой одинаково интенсивные негативные явления
        (неприятные мысли, эмоции или социальные взаимодействия), имеют гораздо большее влияние на психологическое
        состояние человека, чем нейтральные или позитивные явления той же интенсивности. Иными словами, какое-либо
        позитивное событие повлияет на поведение человека гораздо меньше, чем негативное событие такой же силы.
      </p>
    </section>

    <section class="slide">
      <h2>время важно</h2>
      <p>
        Каждый раз, когда пользователь посещает вашу веб-страницу, он начинает гонку за получение контента как можно
        быстрее. Производительность является критическим фактором , который влияет на то, как посетители взаимодействуют
        с вашим сайтом. Некоторые могут подумать, что перемещение контента по всему миру приводит к значительной
        задержке, но на некоторое время скорость передачи данных в сети приблизилась к своим теоретическим пределам .
        Для сравнения, данные на Cloudflare могут преодолеть 11 000-километровое расстояние между Нью-Йорком и Лондоном
        примерно за 76 миллисекунд — быстрее, чем моргнуть глазом . Однако задержки в загрузке веб-страниц сохраняются
        из-за сложностей обработки запросов, ответов и конфигураций. В дополнение к продвижению достижений в
        установлении соединения , сжатии , оборудовании и программном обеспечении , мы создали новый способ сокращения
        задержки загрузки страницы, предвидя, как посетители будут взаимодействовать с данной веб-страницей.
      </p>
      <footer>
        <p>Я не буду говорить про оптимизацию сайта в целом, т.к. очень много</p>
        <p>
          Если вы ориентируетесь на современные браузеры, вы можете выбрать "ES2018"или "ES2019", что может привести к
          более эффективному выводу, чем старые версии, такие как "ES5".
        </p>
        <pre>
{
  "compilerOptions": {
    "target": "ES2019",
    ...
  },
  ...
}
</pre
        >
        <p>
          Один из способов повысить производительность — включить strict режим в вашем tsconfig.json. Это заставляет
          TypeScript перехватывать больше ошибок во время компиляции, что, хотя это может показаться нелогичным, на
          самом деле может повысить производительность. Строго типизированный код может быть легче оптимизирован
          движками JavaScript, а раннее обнаружение ошибок также означает меньше времени, затрачиваемого на отладку. Это
          может быть полезно как для разработки, так и для производительности во время выполнения.
        </p>

        <pre>
            <code class="language-typescript">
            {
  "compilerOptions": {
    "strict": true,
    ...
  },
  ...
}
</code>
</pre>
        <pre>
<code class="language-typescript">
Цели транспиляции и полифиллы
Совместимость между браузерами имеет решающее значение для успеха любого веб-приложения. Различные браузеры имеют разный уровень поддержки функций ECMAScript, и TypeScript не обрабатывает эти несоответствия автоматически за вас. Если вы ориентируетесь на широкий спектр браузеров, включая старые версии, вам может потребоваться установить target более старую версию ECMAScript и использовать полифиллы, чтобы вручную добавить недостающие функции.

{
  "compilerOptions": {
    "target": "ES5",
    ...
  },
  ...
}
</code>
</pre>
        <pre>
<code class="language-typescript">
Использование lib опции компилятора
Опция компилятора lib в вашем tsconfig.json позволяет вам указать файлы библиотек, которые будут включены в компиляцию. Это особенно полезно для обеспечения совместимости, поскольку вы можете включить только те библиотеки, которые поддерживаются вашими целевыми браузерами. Например, если вашему приложению не требуется ES2019.Array, нет смысла включать его, так как это может привести к проблемам совместимости.

{
  "compilerOptions": {
    "lib": ["ES2015", "DOM"],
    ...
  },
  ...
}
</code>
</pre>
      </footer>
    </section>

    <section class="slide">
      <h2>Мотивация</h2>
      <footer>
        <p>парсинг Лексический анализ Синтаксический анализ</p>
        <p>
          Сердцем движка V8 являются Ignition и TurboFan. Ignition — это компонент, который помогает интерпретировать
          ваш байт-код. Как только движок получает AST, он отправляет это дерево в Ignition, который преобразует его в
          байт-код. Затем этот байт-код интерпретируется высокопроизводительным интерпретатором.
        </p>

        <p>
          Ignition имеет быстрое время запуска, а байт-код, который он производит, очень мал, поэтому V8 использует его
          для выполнения кода при загрузке страницы. Ignition используется для редкого кода, потому что
          производительность имеет свою цену, а V8 не хочет потреблять много памяти.
        </p>

        <p>
          TurboFan — это оптимизирующий компилятор, который компилирует ваш код в оптимизированный машинный язык. Он
          генерирует чрезвычайно быстрый машинный код. Он делает это с помощью предположений (мы вернемся к этому
          позже). Поскольку TurboFan генерирует оптимизированный машинный код, V8 использует TurboFan для создания
          оптимизированной версии часто используемого кода.
        </p>
        <p>https://v8.github.io/tools/head/system-analyzer/index.html</p>
        <p>https://v8.github.io/tools/head/turbolizer/index.html</p>
        <p>https://v8.dev/docs/ignition</p>
        <p>https://v8.github.io/tools/head/heap-stats/index.html</p>
        <p>https://v8.github.io/tools/head/parse-processor.html</p>
        <p>https://v8.github.io/tools/head/heap-layout/index.html</p>
        <p>https://v8.github.io/tools/head/profview/index.html</p>
        <p>https://github.com/tinylibs/tinybench</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Косвенность</h2>
      <footer>
        <p>
          Еще одним местом, где можно искать выгоды от оптимизации, является любой источник косвенности, из которых я
          вижу 3 основных источника:
        </p>
        <p>
          Тест proxy на V8 сейчас особенно жесток. В последний раз, когда я проверял, объекты proxy всегда откатывались
          от JIT к интерпретатору, судя по этим результатам, это все еще может быть так.
        </p>
        <p>
          Я также хотел продемонстрировать доступ к глубоко вложенному объекту по сравнению с прямым доступом, но движки
          очень хорошо оптимизируют доступ к удаленным объектам с помощью анализа выхода, когда есть горячий цикл и
          постоянный объект. Я вставил немного косвенности, чтобы предотвратить это
        </p>
        <a
          target="_blank"
          rel="noopener noreferrer"
          href="https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be"
          >https://www.youtube.com/watch?t=1055&v=KiWEWLwQ3oI&feature=youtu.be</a
        >
      </footer>
    </section>

    <section class="slide">
      <h2>https://bloomberg.github.io/ts-blank-space/</h2>
    </section>

    <section class="slide">
      <h2>https://nolanlawson.com/2024/09/18/improving-rendering-performance-with-css-content-visibility/</h2>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const point = new Proxy({ x: 10, y: 20 }, { get: (t, k) => t[k] })

for (let _ = 0, i = 0; i < 100_000; i++) { _ += point.x }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const point = { x: 10, y: 20 }
const x = point.x

for (let _ = 0, i = 0; i < 100_000; i++) { _ += x }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="proxy" d="2"></custom-scale>
        <custom-scale name="direct" d="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const a = { state: { center: { point: { x: 10, y: 20 } } } }
          const b = { state: { center: { point: { x: 10, y: 20 } } } }
          const get = (i) => i % 2 ? a : b

          let result = 0
          for (let i = 0; i < 100_000; i++) {
            result = result + get(i).state.center.point.x }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
        // 2. direct access
const a = { x: 10, y: 20 }.x
const b = { x: 10, y: 20 }.x
const get = (i) => i % 2 ? a : b

let result = 0
for (let i = 0; i < 100_000; i++) {
  result = result + get(i) }
        </code>
      </pre>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="nested" d="42"></custom-scale>
        <custom-scale name="direct" d="100"></custom-scale>
      </div>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте промахов кэша</h2>
      <footer>
        <p>
          Этот момент требует некоторых низкоуровневых знаний, но имеет последствия даже в javascript, поэтому я
          объясню. С точки зрения ЦП, извлечение памяти из ОЗУ происходит медленно. Для ускорения используются в
          основном две оптимизации.
        </p>
        <p>
          5.1 Предварительная выборка Первый — предварительная выборка: она заранее извлекает больше памяти в надежде,
          что это именно та память, которая вас интересует. Она всегда предполагает, что если вы запросите один адрес
          памяти, вас будет интересовать область памяти, которая идет сразу за ним. Поэтому последовательный доступ к
          данным — это ключ. В следующем примере мы можем наблюдать влияние доступа к памяти в случайном порядке.
        </p>
        <p>
          Этот аспект, вероятно, сложнее всего реализовать на практике, поскольку javascript не имеет способа размещения
          объектов в памяти, но вы можете использовать это знание в своих интересах, как в примере выше, например, для
          работы с данными перед их переупорядочением или сортировкой. Вы не можете предполагать, что объекты, созданные
          последовательно, останутся в том же месте через некоторое время, потому что сборщик мусора может переместить
          их. Есть одно исключение из этого, и это массивы чисел, предпочтительно TypedArray экземпляры:
        </p>
        <p>
          Безжалостно устраняйте все данные или выделения памяти , которые можно устранить. Чем меньше ваш набор данных,
          тем быстрее будет работать ваша программа. Ввод-вывод памяти является узким местом для 95% программ. Другой
          хорошей стратегией может быть разделение вашей работы на части и обеспечение работы с небольшим набором данных
          за раз.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // setup:
          const K = 1024
          const length = 1 * K * K

          // Theses points are created one after the other, so they are allocated
          // sequentially in memory.
          const points = new Array(length)
          for (let i = 0; i < points.length; i++) {
            points[i] = { x: 42, y: 0 }
          }

          // This array contains the *same data* as above, but shuffled randomly.
          const shuffledPoints = shuffle(points.slice())
        </code>
      </pre>
      <img class="cover" src="./themes/tw/images/theory/cache/1.svg" width="700" height="350" alt="Codeiupictures" />
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
// 1. sequential
let _ = 0
for (let i = 0; i < points.length; i++) { _ += points[i].x }

          // 2. random
let _ = 0
for (let i = 0; i < shuffledPoints.length; i++) { _ += shuffledPoints[i].x }
        </code>
      </pre>
    </section>

    <section class="slide">
      <custom-scale name="sequential" percentage="100"></custom-scale>
      <custom-scale name="random" percentage="26"></custom-scale>
    </section>

    <section class="slide">
      <h2 class="shout">Избегайте крупных предметов</h2>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // setup:
const USERS_LENGTH = 1_000;

          // setup:
const byId = {}
Array.from({ length: USERS_LENGTH }).forEach((_, id) => {
  byId[id] = { id, name: 'John'}
})
let _ = 0

          // 1. [] access
Object.keys(byId).forEach(id => { _ += byId[id].id })

          // 2. direct access
Object.values(byId).forEach(user => { _ += user.id })
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const USERS_LENGTH = 100_000
        </code>
      </pre>
    </section>

    <section class="slide">
      <custom-scale name="[]" percentage="43"></custom-scale>
      <custom-scale name="direct" percentage="100"></custom-scale>
      <footer>
        <p>
          Как показано выше, избегайте частой индексации в больших объектах. Предпочитайте заранее превратить объект в
          массив. Организация данных для получения идентификатора в модели может помочь, так как вы можете использовать
          Object.values()и не обращаться к карте ключей, чтобы получить идентификатор.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Используйте оценку</h2>
      <footer>
        <p>
          Некоторые шаблоны javascript трудно оптимизировать для движков, и с помощью eval()или его производных вы
          можете заставить эти шаблоны исчезнуть. В этом примере мы можем наблюдать, как использование eval()позволяет
          избежать затрат на создание объекта с динамическим ключом объекта:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Используйте струны осторожно</h2>
      <footer>
        <p>
          Мы уже видели выше, что строки дороже, чем кажутся. Ну, у меня тут есть своего рода ситуация хороших/плохих
          новостей, которую я объявлю в единственном логическом порядке (сначала плохие, потом хорошие): строки сложнее,
          чем кажутся, но их также можно довольно эффективно использовать.
        </p>
        <p>
          Строковые операции являются основной частью JavaScript из-за его контекста. Чтобы оптимизировать код,
          насыщенный строками, движки должны были быть креативными. Под этим я подразумеваю, что они должны были
          представлять String объект с помощью множественного строкового представления в C++, в зависимости от варианта
          использования. Есть два общих случая, о которых вам следует беспокоиться, поскольку они справедливы для V8
          (наиболее распространенного движка на сегодняшний день), а также, как правило, и для других движков.
        </p>
        <p>
          Во-первых, строки, объединенные с +не создают копию двух входных строк. Операция создает указатель на каждую
          подстроку. Если бы это было в typescript, это было бы что-то вроде этого:
        </p>
        <p>
          Во-вторых, срезы строк также не должны создавать копии: они могут просто указывать на диапазон в другой
          строке. Продолжим пример выше:
        </p>
        <p>
          Но вот в чем проблема: как только вам нужно начать мутировать эти байты, в этот момент вы начинаете платить за
          копирование. Допустим, мы возвращаемся к нашему String классу и пытаемся добавить .trimEnd метод:
        </p>
        <p>
          Давайте перейдем к примеру, в котором мы сравним использование операций, использующих мутацию, с
          использованием только конкатенации:
        </p>
        <p>
          В общем, старайтесь избегать мутаций как можно дольше.trim() . Это включает такие методы , как .replace(), и
          т. д. Подумайте, как можно избежать этих методов. В некоторых движках шаблоны строк также могут быть
          медленнее, чем +. В V8 на данный момент это так, но может измениться в будущем, поэтому, как всегда, бенчмарк.
          Примечание SlicedStringвыше: следует отметить, что если в памяти находится небольшая подстрока очень большой
          строки,это может бытьне позволяйте сборщику мусора собирать большую строку! Если вы обрабатываете большие
          тексты и извлекаете из них маленькие строки, вы можете допустить утечку большого объема памяти.
        </p>
        <p>
          Решение здесь — использовать методы мутации в наших интересах. Если мы используем один из них на small, это
          приведет к принудительному копированию, и старый указатель на largeбудет потерян:
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Специализация</h2>

      <footer>
        <p>
          Одной из важных концепций оптимизации производительности является специализация : адаптация вашей логики для
          соответствия ограничениям вашего конкретного варианта использования. Обычно это означает выяснение того, какие
          условия, скорее всего, будут верны для вашего случая, и кодирование для этих условий. Допустим, мы торговец,
          которому иногда нужно добавлять теги в список продуктов. Мы знаем по опыту, что наши теги обычно пустые. Зная
          эту информацию, мы можем специализировать нашу функцию для этого случая
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // 1. not specialized
          for (let i = 0; i < 100; i++) {
            productsToString(descriptions, someTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
            productsToString(descriptions, noTags)
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // 2. specialized
          for (let i = 0; i < 100; i++) {
            productsToStringSpecialized(descriptions, someTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
            productsToStringSpecialized(descriptions, noTags)
          }
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          const descriptions = ['apples', 'oranges', 'bananas', 'seven']
const someTags = {
  apples: '::promotion::',
}
const noTags = {}

// Turn the products into a string, with their tags if applicable
function productsToString(description, tags) {
  let result = ''
  description.forEach(product => {
    result += product
    if (tags[product]) result += tags[product]
    result += ', '
  })
  return result
}
        </code>
      </pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // Specialize it now
          function productsToStringSpecialized(description, tags) {
            // We know that `tags` is likely to be empty, so we check
            // once ahead of time, and then we can remove the `if` check
            // from the inner loop
            if (isEmpty(tags)) {
              let result = ''
              description.forEach(product => {
                result += product + ', '
              })
              return result
            } else {
              let result = ''
              description.forEach(product => {
                result += product
                if (tags[product]) result += tags[product]
                result += ', '
              })
              return result
            }
          }
          function isEmpty(o) { for (let _ in o) { return false } return true }
        </code>
      </pre>
      <footer>
        <p>
          Этот тип оптимизации может дать вам умеренные улучшения, но они будут накапливаться. Они являются хорошим
          дополнением к более важным оптимизациям, таким как формы и ввод-вывод памяти. Но учтите, что специализация
          может обернуться против вас, если ваши условия изменятся, поэтому будьте осторожны, применяя ее.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Структуры данных</h2>
      <footer>
        <p>
          Я не буду вдаваться в подробности о структурах данных, так как они требуют отдельного поста. Но имейте в виду,
          что использование некорректных структур данных для вашего варианта использования может иметь большее влияние,
          чем любая из оптимизаций выше.
        </p>
      </footer>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
          // setup:
const userIds = Array.from({ length: 1_000 }).map((_, i) => i)
const adminIdsArray = userIds.slice(0, 10)
const adminIdsSet = new Set(adminIdsArray)
// 1. Array
let _ = 0
for (let i = 0; i < userIds.length; i++) {
  if (adminIdsArray.includes(userIds[i])) { _ += 1 }
}
// 2. Set
let _ = 0
for (let i = 0; i < userIds.length; i++) {
  if (adminIdsSet.has(userIds[i])) { _ += 1 }
}
        </code>
      </pre>
      <footer>
        <p>
          Но для быстрого примера давайте сравним, как Array.includes работает функция against Set.has для небольшого
          списка
        </p>
        <p>
          Я оставил этот раздел напоследок по одной причине: мне нужно было завоевать доверие с помощью забавных
          разделов выше. Теперь, когда у меня (надеюсь) это есть, позвольте мне сказать вам, что бенчмаркинг — самая
          важная часть оптимизации. Он не только самый важный, но и сложный . Даже после 20 лет опыта я все еще иногда
          создаю бенчмарки, которые несовершенны, или неправильно использую инструменты профилирования. Поэтому, что бы
          вы ни делали, пожалуйста, приложите максимум усилий для правильного бенчмаркинга . 11.0 Начните с самого верха
          Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют большую часть
          времени выполнения. Если вы тратите время на оптимизацию чего-либо еще, кроме верхней части, вы тратите время
          впустую. 11.1 Избегайте микро-бенчмарков Запустите свой код в режиме производства и основывайте свои
          оптимизации на этих наблюдениях. Движки JS очень сложны и часто ведут себя по-разному в микро-бенчмарках, чем
          в реальных сценариях. Например, возьмем этот микро-бенчмарк:
        </p>
        <p>https://darksi.de/d.sea-of-nodes/</p>
      </footer>
    </section>

    <section class="slide">
      <h2>Результаты</h2>
      <div>
        <custom-scale name="array" percentage="32"></custom-scale>
        <custom-scale name="set" percentage="100"></custom-scale>
      </div>
    </section>

    <section class="slide relative">
      <h2 class="shout">Benchmarking</h2>
      <p class="next absolute">Самый важный, но и сложный</p>
      <p class="next absolute">Начало кода</p>
      <p class="next absolute">Сомневаетесь в своих результатах</p>
      <footer>
        <p>
          Вашим приоритетом всегда должна быть оптимизация функции/раздела кода, которые составляют большую часть
          времени выполнения. Если вы тратите время на оптимизацию чего-либо еще, кроме верхней части, вы тратите время
          впустую.
        </p>
        <p>
          Если вы только что оптимизировали функцию, и теперь она работает в 100 раз быстрее, усомнитесь в ней.
          Попробуйте опровергнуть свои результаты, попробуйте ее в режиме производства, забросайте ее всякой всячиной.
          Аналогично, усомнитесь и в своих инструментах. Сам факт наблюдения за бенчмарком с помощью devtools может
          изменить ее поведение.
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2>Third Party Scripts</h2>
    </section>

    <section class="slide">
      <h2>Чтобы пользователи не уходили</h2>
      <footer>
        <p>Мем с онлайн конвертером</p>
      </footer>
    </section>

    <section class="slide">
      <h2>Правильно и не правильно</h2>
    </section>

    <section class="slide">
      <h2>Синоптики</h2>
    </section>

    <section class="slide">
      <h2>без привязки к кейсам, а к возможностям</h2>
    </section>

    <!-- <section class="slide">
      <h2 class="shout">Профилирование и инструменты</h2>
      <footer>
        <p>
          Если вы профилируете в браузере, убедитесь, что вы используете чистый + пустой профиль браузера. Я даже
          использую для этого отдельный браузер. Если вы профилируете и у вас включены расширения браузера, они могут
          испортить измерения. React devtools в частности существенно повлияют на результаты, код рендеринга может
          выглядеть медленнее, чем он есть на самом деле для ваших пользователей.
        </p>
      </footer>
    </section> -->

    <section class="slide">
      <pre>
<code class="language-typescript">
По умолчанию TypeScript автоматически включает каждый @typesпакет, который он находит в вашей node_modulesпапке, независимо от того, импортируете ли вы его. Это сделано для того, чтобы определенные вещи "просто работали" при использовании Node.js, Jasmine, Mocha, Chai и т. д., поскольку эти инструменты/пакеты не импортируются — они просто загружаются в глобальную среду.

Иногда эта логика может замедлить время построения программы как в сценариях компиляции, так и в сценариях редактирования, и это может даже вызвать проблемы с несколькими глобальными пакетами с конфликтующими объявлениями, вызывая такие ошибки, как

Duplicate identifier 'IteratorResult'.
Duplicate identifier 'it'.
Duplicate identifier 'define'.
Duplicate identifier 'require'.
В случаях, когда глобальный пакет не требуется, исправление так же просто, как указание пустого поля для параметра"types" в tsconfig.json/jsconfig.json

// src/tsconfig.json
{
   "compilerOptions": {
       // ...

       // Don't automatically include anything.
       // Only include `@types` packages that we need to import.
       "types" : []
   },
   "files": ["foo.ts"]
}
Если вам все еще нужны несколько глобальных пакетов, добавьте их в types поле.

// tests/tsconfig.json
{
   "compilerOptions": {
       // ...

       // Only include `@types/node` and `@types/mocha`.
       "types" : ["node", "mocha"]
   },
   "files": ["foo.test.ts"]
}
</code>
</pre>
    </section>

    <section class="slide">
      <pre>
        <code class="language-typescript">
Добавление аннотаций типов, особенно возвращаемых типов, может сэкономить компилятору много работы. Отчасти это связано с тем, что именованные типы, как правило, более компактны, чем анонимные типы (которые компилятор может вывести), что сокращает время, затрачиваемое на чтение и запись файлов объявлений (например, для инкрементных сборок). Вывод типов очень удобен, поэтому нет необходимости делать это повсеместно — однако, это может быть полезно, если вы определили медленный раздел своего кода.

- import { otherFunc } from "other";
+ import { otherFunc, OtherType } from "other";

- export function func() {
+ export function func(): OtherType {
      return otherFunc();
  }
</code>
      </pre>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2 class="">Code Run</h2>
        <img class="next ml-4" src="./themes/tw/images/theory/yandex.png" alt="Логотип Яндекс" width="56" height="56" />
      </div>
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/practice/code-run/format.jpg"
        alt="Формат ввода"
        width="1002"
        height="438"
      />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/practice/code-run/code-no-optimized.svg" alt="" width="" height="" />
    </section>

    <section class="slide">
      <img
        class="cover"
        src="./themes/tw/images/practice/code-run/restrictions.jpg"
        alt="Ограничения"
        width="1039"
        height="202"
      />
    </section>

    <section class="slide">
      <h2>Всё познается в сравнеии</h2>
      <img class="cover" src="./themes/tw/images/memes/statham.jpg" alt="Ограничения" width="640" height="760" />
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/practice/code-run/code-optimized.svg" alt="" width="" height="" />
    </section>

    <section class="slide with-title">
      <h2 class="cover text-left"><span class="text-gray">Акт 3.</span><br />Выводы</h2>
    </section>

    <section class="slide">
      <figure class="place">
        <blockquote>
          <p>Самая опасная фраза: «Мы всегда так делали»</p>
        </blockquote>
        <figcaption>Мэтью А. Титмус - из некой книги серии O'Reilly <span class="next">Грейс Хоппер</span></figcaption>
      </figure>
      <footer>
        <p>
          Эта фраза обычно указывает на то, что приверженность статус-кво или продолжение действий без изменений может
          привести к проблемам или неэффективности. В мире программирования это может относиться к анти паттернам или
          устаревшим подходам, которые могут привести к ошибкам или сложностям в будущем
        </p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">20% усилий <span class="next">= 80% результата</span></h2>
    </section>

    <section class="slide">
      <h2 class="shout">заметно <span class="next">!== значимо</span></h2>
    </section>

    <section class="slide">
      <h2 class="cover">Что хотим/хотят от нашего кода?</h2>
    </section>

    <section class="slide">
      <div class="shout">
        <h2>Долголетие</h2>
      </div>
      <footer>
        <p>Прежде чем перейдем к практике</p>
        <p>Хотим чтобы код долгоиграющим</p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Эффективность</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/images/emoji/battery.webp" type="image/webp" />
          <img src="./themes/tw/images/emoji/battery.gif" alt="🔋" width="56" height="56" />
        </picture>
      </div>
      <footer>
        <p>Хотим чтобы код был эффективным</p>
      </footer>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Чтобы не прилетали баги</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/images/emoji/air.webp" type="image/webp" />
          <img src="https://fonts.gstatic.com/s/e/notoemoji/latest/1f6eb/512.gif" alt="🛫" width="56" height="56" />
        </picture>
      </div>
    </section>

    <section class="slide">
      <h2>Когда?</h2>
      <ul>
        <li>прилетит задача</li>
        <li>при код ревью</li>
        <li>https://github.com/facebook/react/pull/28569</li>
      </ul>
      <footer>
        <p>
          Мы большие поклонники TypeScript и используем его уже много лет в наших собственных проектах, а также создали
          глубокую интеграцию с TypeScript для Wallaby и Quokka. В нашей предыдущей записи в блоге мы рассмотрели
          важность оптимизации ваших тестов для более быстрого выполнения . В этой записи в блоге мы немного углубимся и
          выясним, как TypeScript иногда может быть серьезным виновником замедления цикла обратной связи по
          тестированию, и предоставим несколько вариантов того, что вы можете с этим сделать.
        </p>
        <p>
          Одной из лучших особенностей TypeScript является то, что это строго типизированный язык, что означает, что он
          может помочь вам обнаружить ошибки на ранней стадии и предотвратить случайное использование неправильных
          типов. В контексте запуска ваших тестов это не обязательно плохо. В контексте запуска ваших тестов, когда вы
          находитесь в редакторе и можете сразу увидеть ошибки типов, это пустая трата времени обработки; ваш редактор
          выполняет работу по предоставлению ошибок типов, а теперь то же самое делает и ваш тестовый исполнитель. Кроме
          того, обратная связь от проверки типов редактора намного быстрее (поскольку он не запускает ваши тесты) и
          намного более эргономична (прямо рядом с вашим кодом и в представлениях проблем, а не сообщается как ошибки
          теста). К сожалению, время обработки, необходимое для выполнения этой проверки типов, иногда очень дорого, что
          означает, что при использовании Wallaby вы действительно можете выиграть от оптимизации того, как TypeScript
          компилируется при запуске ваших тестов.
        </p>
        <p>
          Прежде чем начать, давайте углубимся в архитектуру Wallaby, чтобы понять, когда происходит компиляция
          TypeScript. Wallaby использует несколько рабочих процессов для параллельного запуска ваших тестов, тогда как
          компиляция TypeScript ограничена одним процессом. Для большинства фреймворков тестирования, которые
          поддерживает Wallaby, компиляция из TypeScript в JavaScript происходит в одном процессе, до того, как
          какие-либо из ваших тестов будут запущены параллельно. Для Jest поведение немного отличается; Wallaby создает
          несколько рабочих процессов, а в каждом рабочем процессе Jest создает отдельный экземпляр компилятора
          TypeScript и снова компилирует весь ваш проект. Это досадное ограничение Jest, которое означает, что одна и та
          же работа выполняется несколько раз, что может привести к большому объему обработки.
        </p>
        <p>
          А теперь самое интересное... не все так мрачно и безнадежно. Есть несколько простых вещей, которые вы можете
          сделать, чтобы оптимизировать TypeScript при запуске тестов. Для начала давайте получим базовый показатель
          того, сколько времени требуется TypeScript для запуска в проекте среднего размера.
        </p>
        <p>
          У нас есть внутренний проект TypeScript с примерно 22 000 строк кода, распределенных по 135 файлам. Используя
          встроенный компилятор TypeScript ( tsc13.37 seconds ), для компиляции проекта в среднем требуется .
        </p>
        <p>
          Первое, что мы можем рассмотреть для повышения производительности, — это пропустить проверку типов между
          другими файлами, установив isolatedModulesпараметр компилятора на true. Это снижает среднее время компиляции
          до 9.09 seconds, 32%сокращение времени (неплохо для быстрого изменения настроек). Есть некоторые функции
          TypeScript, которые не работают с этой настройкой, о которых вам, возможно, будет интересно почитать . По
          нашему опыту, большинство проектов не используют эти функции, но ваш может быть другим. Мы решили не
          использовать эти функции, чтобы получить выгоду от более быстрого цикла обратной связи.
        </p>
        <p>
          Существуют и другие способы компиляции файлов TypeScript, аналогичные тем, что делает встроенный компилятор
          TypeScript с isolatedModulesопцией компилятора, установленной на true. Babel — популярный инструмент для
          компиляции TypeScript в JavaScript. Он намного быстрее компилятора TypeScript, поскольку он фактически просто
          отбрасывает информацию о типе TypeScript. Среднее время компиляции нашего проекта с помощью babel составляет
          2.26 seconds. Это 83%сокращение времени по сравнению с TypeScript 13.37 seconds. В зависимости от используемых
          вами функций TypeScript вам может потребоваться настроить babel для использования нескольких дополнительных
          плагинов. Возможно, вам захочется узнать больше о настройке Babel для компиляции TypeScript в документации по
          TypeScript .
        </p>
        <p>
          Мы уже добились значительного улучшения времени, необходимого для компиляции наших тестов, но мы еще не
          закончили. Есть еще один метод, который мы можем использовать для компиляции TypeScript, swc . Среднее время
          компиляции нашего проекта swc составляет 0.461 seconds. Это 96%сокращение времени, которое изначально
          требовалось нам для компиляции с TypeScript. У нас были некоторые проблемы с использованием swc, и хотя сейчас
          он работает с нашими проектами, изначально у нас были проблемы при использовании более ранних версий node. На
          сайте https://swc.rs утверждается, что: « он в 20 раз быстрее, чем babel на одном потоке, и в 70 раз быстрее
          на 4-ядерном бенчмарке ». Это определенно стоит проверить.
        </p>
        <p>
          Итак, что мы делаем для наших проектов? Мы настраиваем наши собственные проекты для использования swcтам, где
          это возможно, а когда это невозможно, мы используем babel при запуске наших тестов как из Wallaby, так и из
          командной строки / служб непрерывной интеграции (CI). Наши npm script sи CI задачи включают шаг для первой
          компиляции с использованием, tsc чтобы мы не упустили ошибки типов. Исходный код для наших производственных
          сборок tsc также использует.
        </p>
        <p>
          Также стоит упомянуть, что для небольших проектов (или проектов, которые вы не ожидаете сильного роста)
          встроенный компилятор TypeScript будет вполне хорош. Для более крупных проектов (например, больших
          моно-репозиториев, которые разделяют типы между проектами) вы увидите гораздо больший прирост
          производительности, чем мы получили при использовании babelили swc.
        </p>
      </footer>
    </section>

    <!-- <section class="slide">
      <figure class="cover">
        <blockquote>
          <p>
            V8 — это высокопроизводительный движок JS и WebAssembly от Google с открытым исходным кодом, написанный на
            C++. Он используется в Chrome и Node.js. Он реализует ECMAScript и WebAssembly и работает в системах
            Windows, macOS и Linux, использующих процессоры x64, IA-32 или ARM. V8 можно встроить в любое приложение
            C++.
          </p>
        </blockquote>
        <figcaption>Документация</figcaption>
      </figure>
      <a class="copyright" href="https://v8.dev/" target="_blank" rel="noopener noreferrer">v8</a>
    </section> -->

    <!-- <section class="slide">
      <h2 class="!my-[20px]">Числа</h2>
      <img class="cover" src="./themes/tw/images/theory/enum/3.svg" width="1000" height="500" alt="" />
    </section> -->

    <!--
    <section class="slide">
      <h2 class="!my-[20px]">Результаты</h2>
      <div class="speed">
        <div></div>
        <div></div>
      </div>
      <style>
        .speed {
          display: flex;
          flex-direction: column;
          gap: 15px 0;

          div {
            background-color: #b3441e;
            border-radius: 15px;
            height: 50px;
            padding-left: 15px;
            color: #18404a;
            font-weight: bold;
            box-shadow: 2px 2px 2px #222;
          }

          div:first-child {
            width: 50%;

            &::before {
              content: 'Числа';
            }
          }

          div:last-child {
            width: 100%;

            &::before {
              content: 'Строки';
            }
          }
        }
      </style>
    </section> -->

    <!-- <section class="slide">
      <h2>Чертовски хорошо</h2>
    </section> -->

    <section class="slide">
      <h2>Выводы</h2>
      <ol>
        <li class="next"></li>
      </ol>
      <footer>
        <p>поесть пиццы</p>
        <p></p>
        <p>
          0.1 секунда — это тот gap, который позволяет пользователю осознать, что именно его клик мышки, удар по
          клавиатуре побудил эти изменения в приложении\интерфейсе.
        </p>
        <p>
          Кажется, у всех было то неловкое чувство, когда ты сочиняешь письмо\код\любой другой текст, а интерфейс "за
          тобой не успевает". Ты уже пишешь второе слово, а на экране всё еще песочные часы (если мы про windows) и
          еле-еле набирается первое. Аналогично и с кликами на кнопки. Я хочу, чтобы интерфейс мне подсказывал, мол,
          "окей, я тебя услышал, ща все будет".
        </p>
      </footer>
    </section>

    <section class="slide">
      <img class="cover" src="./themes/tw/images/memes/klitschko.jpg" alt="" width="525" height="340" />
    </section>

    <section class="slide">
      <h2 class="shout">Простота и предсказуемость</h2>
      <footer>
        <p>Раньше веб был таким</p>
      </footer>
    </section>

    <section class="slide">
      <h2 class="shout">Производительность – это восприятие</h2>
    </section>

    <section class="slide">
      <div class="shout flex items-center justify-center">
        <h2>Спасибо за внимание!</h2>
        <picture class="ml-4">
          <source srcset="./themes/tw/images/emoji/finish.webp" type="image/webp" />
          <img src="./themes/tw/images/emoji/finish.gif" alt="🏁" width="72" height="72" />
        </picture>
      </div>
    </section>

    <section class="slide relative">
      <div class="shout flex flex-col items-center">
        <div class="dots"></div>
        <h2>Вопросы</h2>
      </div>
    </section>

    <div class="progress before:bg-orange"></div>

    <!-- <section class="slide">
      <p>Используйте оценку</p>
    </section> -->

    <!-- <section class="slide">
      <h2 class="shout">Работа со строками</h2>

      мутация - 37 конкатенция - 100
      <footer></footer>
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/images/theory/strings/1.svg" width="1" height="1" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/images/theory/strings/2.svg" width="1" height="1" alt="" />
    </section> -->

    <!-- <section class="slide">
      <h2>Работа со строками</h2>
      <img src="./themes/tw/images/theory/strings/3.svg" width="1" height="1" alt="" />
    </section> -->

    <!-- <section class="slide">
  Если вы только что оптимизировали функцию, и теперь она работает в 100 раз быстрее, усомнитесь в ней. Попробуйте
  опровергнуть свои результаты, попробуйте ее в режиме производства, забросайте ее всякой всячиной. Аналогично,
  усомнитесь и в своих инструментах. Сам факт наблюдения за бенчмарком с помощью devtools может изменить ее
  поведение.
</section> -->

    <!-- <section class="slide">
      <ul>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?app=desktop&v=d6zk_BwBgXo"
            >https://www.youtube.com/watch?app=desktop&v=d6zk_BwBgXo</a
          >
        </li>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?app=desktop&v=Ybz6P-l9YHc"
            >https://www.youtube.com/watch?app=desktop&v=Ybz6P-l9YHc</a
          >
        </li>
        <li>https://youtu.be/g6gC3NYP6yo?si=v8xCAZLrGncVbhBM</li>
        <li>
          Хочу реакт!<a target="_blank" rel="noopener noreferrer" href="">
            https://www.youtube.com/watch?app=desktop&v=6FsmxjCAgeE</a
          >
        </li>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=KiWEWLwQ3oI&t=1055s"
            >https://www.youtube.com/watch?v=KiWEWLwQ3oI&t=1055s</a
          >
        </li>
        <li>
          <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=SNs61SwZbTI&t=288s"
            >https://www.youtube.com/watch?v=SNs61SwZbTI&t=288s</a
          >
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a>
        </li>
        <li>
          <a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">https://www.youtube.com/watch?v=cCOL7MC4Pl0</a>
        </li>
      </ul>
    </section> -->

    <!--<section class="slide">
     <pre>
const markerNameA = "example-marker-a"
const markerNameB = "example-marker-b"

// Run some nested timeouts, and create a PerformanceMark for each.
performance.mark(markerNameA);
setTimeout(function() {
 performance.mark(markerNameB);
 setTimeout(function() {

   // Create a variety of measurements.
   performance.measure("measure a to b", markerNameA, markerNameB);
   performance.measure("measure a to now", markerNameA);
   performance.measure("measure from navigation start to b", undefined, markerNameB);
   performance.measure("measure from the start of navigation to now");

   // Pull out all of the measurements.
   console.log(performance.getEntriesByType("measure"));

   // Finally, clean up the entries.
   performance.clearMarks();
   performance.clearMeasures();
 }, 1000);
}, 1000);

       console.time("answer time");
alert("Click to continue");
console.timeLog("answer time");
alert("Do a bunch of other stuff...");
console.timeEnd("answer time");

       https://www.telerik.com/blogs/measuring-performance-javascript-performance-api

       https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure

       https://docs.sentry.io/platforms/javascript/tracing/instrumentation/performance-metrics/

https://support.speedcurve.com/docs/javascript-performance

https://betterstack.com/community/guides/scaling-nodejs/performance-apis/
     </pre>
   </section> -->

    <!-- <section class="slide">
      <h2>Бонус</h2>
      <p>Что быстрее типы или интерфейсы</p>
    </section>

    <section class="slide">
      <h2>по данным синоптикам</h2>
      <footer>
        <p>тема производительности большая</p>
      </footer>
    </section> -->

  <!--
    <section class="slide">
      <h2>метафора</h2>    
      <p>«Если вы не можете что-то измерить, значит, вы не можете это исправить» — цитата Уильяма Томсона.</p>
    </section>
 -->

    <!-- <section class="slide">
      Деоптимизиация код сгенерированный оптимизирующим компилятором, не всегода оказывается быстрее
    </section>
    <section class="slide">
      <h2>Восприятие времени</h2>
      <ul>
        <li>< 100 мс. мгновеннл</li>
        <li>< 1 с. ок</li>

        <li>> 2 c оке</li>

        <li>Больше - теряет фокус внимнаия</li>
      </ul>
    </section>

    <section class="slide">
      <h2>работает - не трогай</h2>
      <h2>не работает - трогай</h2>
      <h2>плохо работает - трогай</h2>
    </section> -->
    <!--
    <section>
      <h2>Walmart</h2>
      1 с. увелчиения - конверися + 2% (от 400 млрд)
    </section>

    <section class="slide relative">
      <img class="cover" src="./themes/tw/images/codeium-v8.png" width="700" height="350" alt="Codeium V8" />
      <img
        class="next translate-x-[600px] translate-y-[340px]"
        src="./themes/tw/images/memes/Ilon.jpg"
        width="300"
        height="150"
        alt="Мем Ilon"
      />
      <a class="copyright" href="https://codeium.com/live/general" target="_blank" rel="noopener noreferrer">codeium</a>
      <footer>
        Процентные результаты представляют собой количество операций, выполненных в течение 1 с, деленное на количество
        операций в случае с наивысшей оценкой. Чем выше, тем лучше.
      </footer>
      <footer>
        Как видите, разница может быть существенной. Разница не обязательно связана со стоимостью, strcmp поскольку
        движки иногда могут использовать пул строк и сравнивать по ссылке, но она также связана с тем, что целые числа
        обычно передаются по значению в движках JS, тогда как строки всегда передаются как указатели, а доступ к памяти
        является дорогостоящим (см. раздел 5). В коде с большим количеством строк это может иметь огромное влияние. В
        качестве примера из реальной жизни, мне удалось заставить этот парсер JSON5 javascript работать в 2 раза быстрее
        *, просто заменив строковые константы числами.
      </footer>
      <footer>
        0. Избегать работы Это может показаться очевидным, но это должно быть здесь, потому что не может быть другого
        первого шага к оптимизации: если вы пытаетесь оптимизировать, вы должны сначала рассмотреть возможность
        избегания работы. Это включает в себя такие концепции, как мемоизация, лень и инкрементальные вычисления. Это
        будет применяться по-разному в зависимости от контекста. В React, например, это будет означать применение
        memo()и useMemo()других применимых примитивов.
      </footer>
      <footer>
        21 марта 2024 г. Оптимизация Javascript для развлечения и прибыли Я часто чувствую, что код javascript в целом
        работает гораздо медленнее, чем мог бы, просто потому, что он не оптимизирован должным образом. Вот сводка
        распространенных методов оптимизации, которые я нашел полезными. Обратите внимание, что компромиссом для
        производительности часто является читаемость, поэтому вопрос о том, когда выбирать между производительностью и
        читаемостью, остается на усмотрение читателя. Я также отмечу, что разговор об оптимизации обязательно требует
        разговора о бенчмаркинге. Микрооптимизация функции в течение нескольких часов, чтобы она работала в 100 раз
        быстрее, бессмысленна, если функция изначально представляла лишь часть фактического общего времени выполнения.
        Если вы оптимизируете, первым и самым важным шагом является бенчмаркинг. Я рассмотрю эту тему в последующих
        пунктах. Также имейте в виду, что микробенчмарки часто имеют недостатки, и это может включать те, что
        представлены здесь. Я сделал все возможное, чтобы избежать этих ловушек, но не применяйте слепо ни один из
        пунктов, представленных здесь, без бенчмаркинга. Я включил примеры запуска для всех случаев, где это возможно.
        По умолчанию они показывают результаты, которые я получил на своей машине (brave 122 на archlinux), но вы можете
        запустить их самостоятельно. Как бы мне ни было неприятно это говорить, Firefox немного отстал в плане
        оптимизации и на данный момент представляет собой очень малую часть трафика , поэтому я не рекомендую
        использовать результаты, которые вы получите на Firefox, в качестве полезных индикаторов.
      </footer>
    </section> -->

    <!-- <section class="slide">
      <pre>
        const t0 = performance.now();
for (let i = 0; i < array.length; i++)
{
  // какой-то код
}
const t1 = performance.now();
console.log(t1 - t0, 'milliseconds');

  В Chrome после выполнения этого кода можно получить примерно такой результат:

0.6350000001020817 "milliseconds"

В Firefox — такой:

1 milliseconds

Метод console.time()

  Запускайте функции по много раз

Тестируйте производительность в разных браузерах

https://doka.guide/js/performance/

https://purpleschool.ru/knowledge-base/article/performance

кейс cell-trade
      </pre>
    </section> -->

    <!-- <section class="slide">
      <h2>А чем будем мерить?</h2>
      <ul>
        <li class="next">
          DevTools
выполняется во время простоя браузера - Perfomance API
        </li>
        <li class="next">
          сервисы (<a href="https://ui.perfetto.dev/" target="_blank" rel="noopener noreferrer">perfetto</a>)
        </li>
        <li class="next">
          расширения в IDE (<a
            target="_blank"
            rel="noopener noreferrer"
            href="https://marketplace.visualstudio.com/items?itemName=rbuckton.deoptexplorer-vscodeer-vscode"
            >deoptexplorer-vscode</a
          >)
        </li>
        <li class="next">
          пакеты (<a target="_blank" rel="noopener noreferrer" href="https://www.npmjs.com/package/perfume.js"
            >perfume</a
          >
          и т. д.)
        </li>
        <li class="next">https://github.com/facebook/memlab</li>
        <li>
          <a href="https://web.dev/articles/speed-v8?hl=ru" target="_blank" rel="noopener noreferrer"
            >https://web.dev/articles/speed-v8?hl=ru</a
          >
        </li>
        <li><a href="https://jsbenchmark.com/" target="_blank" rel="noopener noreferrer">jsbenchmark</a></li>
        <li>
          <a href="https://habr.com/ru/companies/oleg-bunin/articles/417459/" target="_blank" rel="noopener noreferrer"
            >Пост с хабра</a
          >
        </li>
      </ul>
    </section> -->

    <script src="./shower.min.js"></script>
    <script src="./custom-scale.js"></script>
    <script src="./libs/highlight/highlight.min.js"></script>
    <script src="./libs/highlight/init.js"></script>
  </body>
</html>
