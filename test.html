<section class="slide">
  Правило пика-конца: как впечатления становятся воспоминаниями Резюме: Когнитивные искажения меняют то, как мы
  вспоминаем прошлые события. Правило пика-конца фокусирует наши воспоминания вокруг самых интенсивных моментов опыта и
  того, как опыт заканчивается. Вспомните, когда вы последний раз были в отпуске. Что вы помните? Возможно, вы вспомнили
  особенно красивый вид с вершины горы после долгого похода. Возможно, вы подумали об интересной выставке, которую вы
  увидели в музее, или об идеальном утре на пляже с семьей. Вы также могли представить себе момент, когда ваша последняя
  поездка приняла худший оборот: возможно, вы подумали о потере паспорта или о том, что заболели вдали от дома.
  Независимо от того, были ли воспоминания счастливыми или грустными, ваше общее впечатление от последнего отпуска,
  вероятно, включало несколько особенно сильных моментов. Мы помним события в нашей жизни как серию снимков, а не как
  полный каталог событий. Наш разум быстро усредняет моменты, которые наиболее выделяются в наших воспоминаниях, чтобы
  сформировать наше мнение о прошлом. Наиболее эмоционально интенсивные моменты опыта и его завершение оказывают большое
  влияние на то, как мы помним событие. Правило пика-конца: когнитивное искажение, которое влияет на то, как люди помнят
  прошлые события. Интенсивные позитивные или негативные моменты («пики») и финальные моменты опыта («конец») имеют
  большой вес в наших ментальных расчетах.
</section>

<section class="slide">
  производительность - это не математика
  <a href="https://rutube.ru/video/fe2a7cef6191e4a8790d2d8b8fa804d7/" target="_blank" rel="noopener noreferrer"
    >Видео с Rutube</a
  >
  <a href="https://v8.dev/blog/react-cliff" target="_blank" rel="noopener noreferrer"
    >https://v8.dev/blog/react-cliff</a
  >
  <a href="https://almanac.httparchive.org/en/2022/page-weight" target="_blank" rel="noopener noreferrer"
    >https://almanac.httparchive.org/en/2022/page-weight</a
  >
</section>

<section class="slide">
  <img
    class="cover"
    src="./themes/tw/images/theory/unused-js.jpg"
    alt="TНеиспользованный JS"
    width="1921"
    height="1080"
  />
  <a>https://almanac.httparchive.org/ru/2022/</a>
</section>

<section class="slide">
  <pre>
    const t0 = performance.now();
for (let i = 0; i < array.length; i++)
{
// какой-то код
}
const t1 = performance.now();
console.log(t1 - t0, 'milliseconds');

В Chrome после выполнения этого кода можно получить примерно такой результат:

0.6350000001020817 "milliseconds"

В Firefox — такой:

1 milliseconds

Метод console.time()
  </pre>
</section>

<section class="slide">
  <h2>Алгоритмы</h2>
  <ul>
    <li>выбрать метрики, которыми можно можно охарактериозовать "степень оптимальности" нашего сайта или приложения</li>
    <li>найти код сильене всего ухудшающий метрики</li>
    <li>внести изменния в код</li>
    <li>измерить новые значения</li>
    <li>повторить</li>
  </ul>
</section>

<section class="slide">
  <div class="section-content">
    <p>
      Когда дело доходит до производительности веб-сайта, вы можете подумать о таких методах, как сжатие, оптимизация
      ресурсов или даже кэширование HTTP. Они действительно важны, и существует множество существующих ресурсов,
      охватывающих способы их исправления или внедрения. Однако некоторые менее обсуждаемые узкие места
      производительности могут серьезно повлиять на скорость веб-сайта. В этой статье мы обсудим три проблемы, которые
      часто возникают из-за неэффективных шаблонов JavaScript:
    </p>
    <ul>
      <li>
        <strong
          ><font style="vertical-align: inherit"
            ><font style="vertical-align: inherit">Длительные задачи:</font></font
          ></strong
        ><font style="vertical-align: inherit"
          ><font style="vertical-align: inherit">
            операции JavaScript, которые монополизируют основной поток, что приводит к неотзывчивости пользовательских
            интерфейсов.</font
          ></font
        >
      </li>
      <li>
        <strong
          ><font style="vertical-align: inherit"
            ><font style="vertical-align: inherit">Большие размеры пакетов:</font></font
          ></strong
        ><font style="vertical-align: inherit"
          ><font style="vertical-align: inherit">
            код JavaScript слишком велик для быстрой загрузки, анализа и выполнения.</font
          ></font
        >
      </li>
      <li>
        <strong
          ><font style="vertical-align: inherit"
            ><font style="vertical-align: inherit">Проблемы гидратации:</font></font
          ></strong
        ><font style="vertical-align: inherit"
          ><font style="vertical-align: inherit">
            процесс присоединения функциональности JavaScript к HTML, отображаемому сервером.</font
          ></font
        >
      </li>
    </ul>
    <p>
      <font style="vertical-align: inherit"
        ><font style="vertical-align: inherit"
          >Хотя эти проблемы не новы, современные веб-практики и веб-фреймворки могут усугубить эти проблемы, снова
          выставив их в центр внимания.</font
        ></font
      >
    </p>
    <div class="notecard note" id="sect1">
      <p>
        <strong
          ><font style="vertical-align: inherit"><font style="vertical-align: inherit">Примечание:</font></font></strong
        ><font style="vertical-align: inherit"
          ><font style="vertical-align: inherit">
            Эти проблемы могут также возникать из других источников, таких как CSS. Например,
          </font></font
        ><a href="/en-US/docs/Glossary/Long_task"
          ><font style="vertical-align: inherit"><font style="vertical-align: inherit">долгая задача</font></font></a
        >может быть вызвана сложным селектором CSS, которому требуется много времени для сопоставления элементов. Однако
        в этой статье основное внимание уделяется JavaScript.
      </p>
    </div>
    <p>
      Ниже приведена более подробная информация о каждом узком месте, а также общие комментарии по решению таких проблем
      производительности.
    </p>
  </div>
</section>

<section class="slide">
  <pre>
      https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure
const markerNameA = "example-marker-a"
const markerNameB = "example-marker-b"

// Run some nested timeouts, and create a PerformanceMark for each.
performance.mark(markerNameA);
setTimeout(function() {
performance.mark(markerNameB);
setTimeout(function() {

  // Create a variety of measurements.
  performance.measure("measure a to b", markerNameA, markerNameB);
  performance.measure("measure a to now", markerNameA);
  performance.measure("measure from navigation start to b", undefined, markerNameB);
  performance.measure("measure from the start of navigation to now");

  // Pull out all of the measurements.
  console.log(performance.getEntriesByType("measure"));

  // Finally, clean up the entries.
  performance.Marks();
  performance.Measures();
}, 1000);
}, 1000);

      console.time("answer time");
alert("Click to continue");
console.timeLog("answer time");
alert("Do a bunch of other stuff...");
console.timeEnd("answer time");
    </pre
  >
</section>

<section class="slide">
  Высота дерева особенно важна, когда мы имеем дело с определенными типами деревьев, такими как двоичные деревья поиска
  (BST) . Вот почему существует так много различных структур данных, которые реализуют самобалансирующиеся BST — так,
  чтобы мы могли поддерживать высоту дерева на минимальном уровне по мере его роста и выполнять такие операции, как
  поиск, как можно быстрее. Если вы только что оптимизировали функцию, и теперь она работает в 100 раз быстрее,
  усомнитесь в ней. Попробуйте опровергнуть свои результаты, попробуйте ее в режиме производства, забросайте ее всякой
  всячиной. Аналогично, усомнитесь и в своих инструментах. Сам факт наблюдения за бенчмарком с помощью devtools может
  изменить ее поведение.
</section>

<p>
  Избегайте ненужных утверждений типов Утверждения типов следует использовать осторожно. Чрезмерное их использование
  может привести к ненужным проверкам типов, что может снизить производительность. Вместо этого позвольте TypeScript
  выводить типы, когда это возможно. let value: any = "Hello, TypeScript!"; let strLength: number = (value as
  string).length; // Avoid using 'as string' if TypeScript can infer the type
</p>

<section class="slide test">
  <style>
    .test > div {
      display: flex;
      justify-content: center;
    }

    .test h2 {
      text-align: left !important;
      text-transform: lowercase;
      font-size: 38px !important;
    }

    .test h2 span {
      text-transform: uppercase;
    }
  </style>
  <div class="shout">
    <h2 class="text-left">Что такое<br /><span class="text-[82px]">производительность?</span></h2>
  </div>
  <footer>
    <p>
      Ощущаемая пользователем "производительность" - это единственная производительность, которая имеет значение.
      Пользователи взаимодействуют с системой с помощью ввода каких-то данных: прикосновений, движения и речи. В ответ,
      они получают реакцию, основанную на зрительном, тактильном или слуховом аппаратах. Производительность - это
      качество того, как система реагирует на действия пользователя.
    </p>
    <p>
      При прочих равных, код, оптимизированный для каких-то иных целей, кроме ощущаемой пользователем производительности
      (здесь и дальше UPP, user-perceived performance) всегда проигрывает коду, который оптимизирован для UPP. Упрощённо
      говоря, пользователи предпочитают отзывчивое и плавное приложение, которое обрабатывает 1,000 транзакций к базе
      данных в секунду грубому неотзывчивому приложению, которое обрабатывает 100,000,000 запросов в секунду. Конечно,
      это не означает, что другие метрики становятся ненужным, но первой вашей целью должна быть UPP.
    </p>
    <p>Следующие разделы укажут и объяснят некоторые метрики производительности:</p>
  </footer>

  <!-- <section class="slide ">
      Причина этому - в мобильных устройствах срабатывает задержка в несколько сотен миллисекунд между касанием экрана и
      запуском обработчика click. Из-за этого приложение может ощущаться медленным. Если вы будете тестировать ваше
      приложение на предмет работы с касаниями, вы не пожертвуете доступностью. Кроме того, существуют библиотеки,
      которые ускорят разработку. Например, Financial Times использует библиотеку Секрет быстрой загрузки требует двух
      вещей: UPP (ощущаемая пользователем скорость) - это единственное, что имеет значение; эта скорость зависит от
      критического пути рендеринга (Critical Rendering Path). Критический путь - это единственный и необходимый код,
      который должен запускать перечисленные выше события.
      <p>Загрузка приложения может быть поделена на три этапа, которые влияют на UPP:</p>
      <ul>
        <li>
          Первая отрисовка. Момент, когда приложение загрузило достаточно данных и ресурсов, чтобы отрисовать первый -
          начальный - кадр
        </li>
        <li>
          Начало интерактивности - например, когда пользователю становится доступна возможность нажать кнопку, а
          приложение может ему ответить
        </li>
        <li>Полная загрузка - например, когда все пользовательские альбомы перечислены в музыкальном плеере</li>
      </ul>
      Использование памяти - это отдельная ключевая метрика. В отличии от отзывчивости и частоты кадров, пользователи не
      могут напрямую почувствовать использование памяти, но её использование влияет на "состояние пользователя".
      <p>
        Последний показатель, который нужно упомянуть - это потребление энергии. Подобно использованию памяти,
        пользователь чувствует потребление энергии опосредованно, отмечая время, через которое устройство начинает
        изменять воспринимаемую пользователем производительность (UPP). Для минимизации отрицательных эффектов
        использования энергии, мы должны делать систему экономной.
      </p>
      <p>
        Для примера, вспомните, как работают мобильные устройства: вы можете включить режим энергосбережения, когда
        отключаются другие системы. Но есть и более жёсткий режим, который включается автоматически, когда заряд
        уменьшается до 5% - система включает троттлинг процессора, замедляя выполнение всех инструкций.
      </p>
      <p>Всю оставшуюся часть статьи мы будем обсуждать производительность в свете этих показателей.</p>
    </section> -->
  <!--

        <img class="relative z-20" src="./themes/tw/pictures/arrows/1.svg" alt="Стрелка" width="56" height="56" />

           <section class="slide">
      <h2 class="shout">How I Created a 3.78MB Docker Image for a JavaScript Service</h2>
      <a class="copyright" href=""
        >https://shenzilong.cn/record/How%20I%20Created%20a%203.78MB%20Docker%20Image%20for%20a%20JavaScript%20Service</a
      >
    </section>




    <section class="slide">
      <h2>Чертовски хорошо</h2>
    </section>

    <section class="slide">
      <h2>время важно</h2>
      <p>
        Каждый раз, когда пользователь посещает вашу веб-страницу, он&nbsp;начинает гонку за&nbsp;получение контента как
        можно быстрее. Производительность является критическим фактором , который влияет на&nbsp;то, как посетители
        взаимодействуют с&nbsp;вашим сайтом. Некоторые могут подумать, что перемещение контента по&nbsp;всему миру
        приводит к&nbsp;значительной задержке, но&nbsp;на&nbsp;некоторое время скорость передачи данных в&nbsp;сети
        приблизилась к&nbsp;своим теоретическим пределам . Для сравнения, данные на&nbsp;Cloudflare могут преодолеть 11
        000-километровое расстояние между Нью-Йорком и&nbsp;Лондоном примерно за&nbsp;76&nbsp;миллисекунд&nbsp;&mdash;
        быстрее, чем моргнуть глазом . Однако задержки в&nbsp;загрузке веб-страниц сохраняются из-за сложностей
        обработки запросов, ответов и&nbsp;конфигураций. В&nbsp;дополнение к&nbsp;продвижению достижений в установлении
        соединения , сжатии , оборудовании и&nbsp;программном обеспечении , мы&nbsp;создали новый способ сокращения
        задержки загрузки страницы, предвидя, как посетители будут взаимодействовать с&nbsp;данной веб-страницей.
      </p>
      <footer>
        <p>Я&nbsp;не&nbsp;буду говорить про оптимизацию сайта в&nbsp;целом, т.к. очень много</p>
        <p>
          Если вы&nbsp;ориентируетесь на&nbsp;современные браузеры, вы&nbsp;можете выбрать &quot;ES2018&laquo;или
          &laquo;ES2019&raquo;, что может привести к более эффективному выводу, чем старые версии, такие как
          &laquo;ES5&raquo;.
        </p>
        <pre>
          {
            "compilerOptions": {
              "target": "ES2019",
              ...
            },
            ...
          }
          </pre
        >
        <p>
          Один из способов повысить производительность — включить strict режим в вашем tsconfig.json. Это заставляет
          TypeScript перехватывать больше ошибок во время компиляции, что, хотя это может показаться нелогичным, на
          самом деле может повысить производительность. Строго типизированный код может быть легче оптимизирован
          движками JavaScript, а раннее обнаружение ошибок также означает меньше времени, затрачиваемого на отладку. Это
          может быть полезно как для разработки, так и для производительности во время выполнения.
        </p>

        <pre>
                      <code class="language-typescript">
                      {
            "compilerOptions": {
              "strict": true,
              ...
            },
            ...
          }
          </code>
          </pre>
        <pre>
          <code class="language-typescript">
          Цели транспиляции и полифиллы
          Совместимость между браузерами имеет решающее значение для успеха любого веб-приложения. Различные браузеры имеют разный уровень поддержки функций ECMAScript, и TypeScript не обрабатывает эти несоответствия автоматически за вас. Если вы ориентируетесь на широкий спектр браузеров, включая старые версии, вам может потребоваться установить target более старую версию ECMAScript и использовать полифиллы, чтобы вручную добавить недостающие функции.

          {
            "compilerOptions": {
              "target": "ES5",
              ...
            },
            ...
          }
          </code>
          </pre>
        <pre>
          <code class="language-typescript">
          Использование lib опции компилятора
          Опция компилятора lib в вашем tsconfig.json позволяет вам указать файлы библиотек, которые будут включены в компиляцию. Это особенно полезно для обеспечения совместимости, поскольку вы можете включить только те библиотеки, которые поддерживаются вашими целевыми браузерами. Например, если вашему приложению не требуется ES2019.Array, нет смысла включать его, так как это может привести к проблемам совместимости.

          {
            "compilerOptions": {
              "lib": ["ES2015", "DOM"],
              ...
            },
            ...
          }
          </code>
          </pre>
      </footer>
    </section>

    <section class="slide">
      <h2>Мотивация</h2>
      <footer>
        <p>парсинг Лексический анализ Синтаксический анализ</p>
        <p>
          Сердцем движка V8&nbsp;являются Ignition и&nbsp;TurboFan. Ignition&nbsp;&mdash; это компонент, который
          помогает интерпретировать ваш байт-код. Как только движок получает AST, он&nbsp;отправляет это дерево
          в&nbsp;Ignition, который преобразует его в байт-код. Затем этот байт-код интерпретируется
          высокопроизводительным интерпретатором.
        </p>

        <p>
          Ignition имеет быстрое время запуска, а&nbsp;байт-код, который он&nbsp;производит, очень мал, поэтому
          V8&nbsp;использует его для выполнения кода при загрузке страницы. Ignition используется для редкого кода,
          потому что производительность имеет свою цену, а&nbsp;V8&nbsp;не хочет потреблять много памяти.
        </p>

        <p>
          TurboFan&nbsp;&mdash; это оптимизирующий компилятор, который компилирует ваш код в&nbsp;оптимизированный
          машинный язык. Он генерирует чрезвычайно быстрый машинный код. Он&nbsp;делает это с&nbsp;помощью предположений
          (мы&nbsp;вернемся к&nbsp;этому позже). Поскольку TurboFan генерирует оптимизированный машинный код,
          V8&nbsp;использует TurboFan для создания оптимизированной версии часто используемого кода.
        </p>
        <p>https://v8.github.io/tools/head/system-analyzer/index.html</p>
        <p>https://v8.github.io/tools/head/turbolizer/index.html</p>
        <p>https://v8.dev/docs/ignition</p>
        <p>https://v8.github.io/tools/head/heap-stats/index.html</p>
        <p>https://v8.github.io/tools/head/parse-processor.html</p>
        <p>https://v8.github.io/tools/head/heap-layout/index.html</p>
        <p>https://v8.github.io/tools/head/profview/index.html</p>
        <p>https://github.com/tinylibs/tinybench</p>
      </footer>
    </section>


    <section class="slide">
      <h2>без привязки к&nbsp;кейсам, а&nbsp;к&nbsp;возможностям</h2>
    </section>

    <!-- <section class="slide ">
                  <h2 class="shout">Профилирование и инструменты</h2>
                  <footer>
                    <p>
                      Если вы профилируете в браузере, убедитесь, что вы используете чистый + пустой профиль браузера. Я даже
                      использую для этого отдельный браузер. Если вы профилируете и у вас включены расширения браузера, они могут
                      испортить измерения. React devtools в частности существенно повлияют на результаты, код рендеринга может
                      выглядеть медленнее, чем он есть на самом деле для ваших пользователей.
                    </p>
                  </footer>
                </section> -->

  <section class="slide">
    <pre>
            <code class="language-typescript">
            По умолчанию TypeScript автоматически включает каждый @typesпакет, который он находит в вашей node_modulesпапке, независимо от того, импортируете ли вы его. Это сделано для того, чтобы определенные вещи "просто работали" при использовании Node.js, Jasmine, Mocha, Chai и т. д., поскольку эти инструменты/пакеты не импортируются — они просто загружаются в глобальную среду.

            Иногда эта логика может замедлить время построения программы как в сценариях компиляции, так и в сценариях редактирования, и это может даже вызвать проблемы с несколькими глобальными пакетами с конфликтующими объявлениями, вызывая такие ошибки, как

            Duplicate identifier 'IteratorResult'.
            Duplicate identifier 'it'.
            Duplicate identifier 'define'.
            Duplicate identifier 'require'.
            В случаях, когда глобальный пакет не требуется, исправление так же просто, как указание пустого поля для параметра"types" в tsconfig.json/jsconfig.json

            // src/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Don't automatically include anything.
                   // Only include `@types` packages that we need to import.
                   "types" : []
               },
               "files": ["foo.ts"]
            }
            Если вам все еще нужны несколько глобальных пакетов, добавьте их в types поле.

            // tests/tsconfig.json
            {
               "compilerOptions": {
                   // ...

                   // Only include `@types/node` and `@types/mocha`.
                   "types" : ["node", "mocha"]
               },
               "files": ["foo.test.ts"]
            }
            </code>
            </pre>
  </section>

  <section class="slide">
    <pre>
                    <code class="language-typescript">
            Добавление аннотаций типов, особенно возвращаемых типов, может сэкономить компилятору много работы. Отчасти это связано с тем, что именованные типы, как правило, более компактны, чем анонимные типы (которые компилятор может вывести), что сокращает время, затрачиваемое на чтение и запись файлов объявлений (например, для инкрементных сборок). Вывод типов очень удобен, поэтому нет необходимости делать это повсеместно — однако, это может быть полезно, если вы определили медленный раздел своего кода.

            - import { otherFunc } from "other";
            + import { otherFunc, OtherType } from "other";

            - export function func() {
            + export function func(): OtherType {
                  return otherFunc();
              }
            </code>
                  </pre>
  </section>

  <section class="slide">
    <div class="shout flex items-center justify-center">
      <h2>Code Run</h2>
      <img
        class="next ml-4"
        src="./themes/tw/images/practice/companies/yandex.svg"
        alt="Логотип Яндекс"
        width="56"
        height="56"
      />
    </div>
  </section>

  <section class="slide">
    <h2 class="shout">Lessons learned from 222,557 font file subsets?</h2>
    <a href="https://www.phpied.com/lessons-learned-from-222557-font-file-subsets/">
      https://www.phpied.com/lessons-learned-from-222557-font-file-subsets/
    </a>
  </section>

  <section class="slide">
    <h2 class="shout">How Bun supports V8 APIs without using V8 (part 1)</h2>
    https://bun.sh/blog/how-bun-supports-v8-apis-without-using-v8-part-1
  </section>

  <section class="slide">
    <img
      class="cover"
      src="./themes/tw/images/practice/code-run/restrictions.jpg"
      alt="Ограничения"
      width="1039"
      height="202"
    />
  </section>

  <section class="slide">
    <h2>Всё познается в&nbsp;сравнении</h2>
    <img class="cover" src="./themes/tw/pictures/memes/statham.jpg" alt="Ограничения" width="640" height="760" />
  </section>

  <section class="slide">
    <video></video>
    <style>
      video::cue {
        font-size: 1rem;
      }
    </style>
  </section>

  <section class="slide">
    <ul>
      <li>node --inspect-brk</li>
      <li>chrome://inspect</li>
      <li><a href="https://perf.link">perf.link</a></li>
      <li>https://npmgraph.js.org/</li>
      <li>eslint-plugin-depend</li>
    </ul>
  </section>

  <section class="slide">
    <figure class="place">
      <blockquote>
        <p>Самая опасная фраза: &laquo;Мы&nbsp;всегда так делали&raquo;</p>
      </blockquote>
      <figcaption>
        Мэтью А. Титмус&nbsp;&mdash; из&nbsp;некой книги серии O&rsquo;Reilly <span class="next">Грейс Хоппер</span>
      </figcaption>
    </figure>
    <footer>
      <p>
        Эта фраза обычно указывает на&nbsp;то, что приверженность статус-кво или продолжение действий без изменений
        может привести к&nbsp;проблемам или неэффективности. В&nbsp;мире программирования это может относиться
        к&nbsp;анти паттернам или устаревшим подходам, которые могут привести к&nbsp;ошибкам или сложностям
        в&nbsp;будущем
      </p>
    </footer>
  </section>

  Один полезный вывод заключается в том, что в настоящее время blocking=renderэто может вызвать одно из следующих
  событий:

  <script src async></script>
  <script src defer></script>
  <script src type="module"></script>
  <script type="module">
    ...
  </script>
  …вести себя так:

  <link rel="stylesheet" href />

  Техника проста: поскольку изображения обычно являются более тяжелыми и медленными ресурсами, и они не блокируют
  рендеринг, мы должны попытаться дать пользователям что-то, на что они могут смотреть, пока они ждут получения
  изображения. Решение? Покажите им низкокачественный заполнитель изображения, или LQIP .

  <section class="slide">
    <div class="shout flex items-center justify-center">
      <h2>The Release Radar</h2>
      📡
    </div>
  </section>

  <section class="slide">
    <img src="./themes/tw/pictures/memes/the-twilight-zone/1.jpg" alt="The twilight zone 1" width="500" height="500" />
  </section>

  <section class="slide">
    <img src="./themes/tw/pictures/memes/the-twilight-zone/2.jpg" alt="The twilight zone 2" width="500" height="500" />
  </section>

  <section class="slide">
    <img src="./themes/tw/pictures/memes/the-twilight-zone/3.jpg" alt="The twilight zone 3" width="500" height="500" />
  </section>

  <section class="slide">
    <img src="./themes/tw/pictures/memes/oop/encapsulation.jpg" alt="Инкапсуляция" width="500" height="500" />
    <img src="./themes/tw/pictures/memes/oop/polymorphism.jpg" alt="Полиморфизм" width="500" height="500" />
    <img src="./themes/tw/pictures/memes/oop/inheritance.jpg" alt="Наследование" width="500" height="500" />
  </section>

  <section class="slide">
    <h2>Когда?</h2>
    <ul>
      <li>прилетит задача</li>
      <li>при код ревью</li>
      <li>https://github.com/facebook/react/pull/28569</li>
    </ul>
    <footer>
      <p>
        Мы&nbsp;большие поклонники TypeScript и&nbsp;используем его уже много лет в&nbsp;наших собственных проектах,
        а&nbsp;также создали глубокую интеграцию с&nbsp;TypeScript для Wallaby и&nbsp;Quokka. В&nbsp;нашей предыдущей
        записи в&nbsp;блоге мы&nbsp;рассмотрели важность оптимизации ваших тестов для более быстрого выполнения .
        В&nbsp;этой записи в&nbsp;блоге мы&nbsp;немного углубимся и выясним, как TypeScript иногда может быть серьезным
        виновником замедления цикла обратной связи по тестированию, и&nbsp;предоставим несколько вариантов того, что
        вы&nbsp;можете с&nbsp;этим сделать.
      </p>
      <p>
        Одной из&nbsp;лучших особенностей TypeScript является&nbsp;то, что это строго типизированный язык, что означает,
        что он может помочь вам обнаружить ошибки на&nbsp;ранней стадии и&nbsp;предотвратить случайное использование
        неправильных типов. В&nbsp;контексте запуска ваших тестов это не&nbsp;обязательно плохо. В&nbsp;контексте
        запуска ваших тестов, когда вы находитесь в&nbsp;редакторе и&nbsp;можете сразу увидеть ошибки типов, это пустая
        трата времени обработки; ваш редактор выполняет работу по&nbsp;предоставлению ошибок типов, а&nbsp;теперь
        то&nbsp;же самое делает и&nbsp;ваш тестовый исполнитель. Кроме того, обратная связь от&nbsp;проверки типов
        редактора намного быстрее (поскольку он&nbsp;не&nbsp;запускает ваши тесты) и намного более эргономична (прямо
        рядом с&nbsp;вашим кодом и&nbsp;в&nbsp;представлениях проблем, а&nbsp;не&nbsp;сообщается как ошибки теста).
        К&nbsp;сожалению, время обработки, необходимое для выполнения этой проверки типов, иногда очень дорого, что
        означает, что при использовании Wallaby вы&nbsp;действительно можете выиграть от&nbsp;оптимизации того, как
        TypeScript компилируется при запуске ваших тестов.
      </p>
      <p>
        Прежде чем начать, давайте углубимся в&nbsp;архитектуру Wallaby, чтобы понять, когда происходит компиляция
        TypeScript. Wallaby использует несколько рабочих процессов для параллельного запуска ваших тестов, тогда как
        компиляция TypeScript ограничена одним процессом. Для большинства фреймворков тестирования, которые поддерживает
        Wallaby, компиляция из&nbsp;TypeScript в&nbsp;JavaScript происходит в&nbsp;одном процессе, до&nbsp;того, как
        какие-либо из&nbsp;ваших тестов будут запущены параллельно. Для Jest поведение немного отличается; Wallaby
        создает несколько рабочих процессов, а&nbsp;в&nbsp;каждом рабочем процессе Jest создает отдельный экземпляр
        компилятора TypeScript и&nbsp;снова компилирует весь ваш проект. Это досадное ограничение Jest, которое
        означает, что одна и&nbsp;та же&nbsp;работа выполняется несколько раз, что может привести к&nbsp;большому объему
        обработки.
      </p>
      <p>
        А&nbsp;теперь самое интересное... не&nbsp;все так мрачно и&nbsp;безнадежно. Есть несколько простых вещей,
        которые вы&nbsp;можете сделать, чтобы оптимизировать TypeScript при запуске тестов. Для начала давайте получим
        базовый показатель того, сколько времени требуется TypeScript для запуска в&nbsp;проекте среднего размера.
      </p>
      <p>
        У&nbsp;нас есть внутренний проект TypeScript с&nbsp;примерно 22&nbsp;000 строк кода, распределенных
        по&nbsp;135&nbsp;файлам. Используя встроенный компилятор TypeScript ( tsc13.37 seconds ), для компиляции проекта
        в&nbsp;среднем требуется .
      </p>
      <p>
        Первое, что мы&nbsp;можем рассмотреть для повышения производительности,&nbsp;&mdash; это пропустить проверку
        типов между другими файлами, установив isolatedModulesпараметр компилятора на&nbsp;true. Это снижает среднее
        время компиляции до&nbsp;9.09&nbsp;seconds, 32%сокращение времени (неплохо для быстрого изменения настроек).
        Есть некоторые функции TypeScript, которые не&nbsp;работают с&nbsp;этой настройкой, о&nbsp;которых вам,
        возможно, будет интересно почитать . По нашему опыту, большинство проектов не&nbsp;используют эти функции,
        но&nbsp;ваш может быть другим. Мы&nbsp;решили не использовать эти функции, чтобы получить выгоду от&nbsp;более
        быстрого цикла обратной связи.
      </p>
      <p>
        Существуют и&nbsp;другие способы компиляции файлов TypeScript, аналогичные тем, что делает встроенный компилятор
        TypeScript с&nbsp;isolatedModulesопцией компилятора, установленной на&nbsp;true. Babel&nbsp;&mdash; популярный
        инструмент для компиляции TypeScript в&nbsp;JavaScript. Он&nbsp;намного быстрее компилятора TypeScript,
        поскольку он&nbsp;фактически просто отбрасывает информацию о&nbsp;типе TypeScript. Среднее время компиляции
        нашего проекта с&nbsp;помощью babel составляет 2.26&nbsp;seconds. Это&nbsp;83%сокращение времени
        по&nbsp;сравнению с&nbsp;TypeScript 13.37&nbsp;seconds. В&nbsp;зависимости от&nbsp;используемых вами функций
        TypeScript вам может потребоваться настроить babel для использования нескольких дополнительных плагинов.
        Возможно, вам захочется узнать больше о&nbsp;настройке Babel для компиляции TypeScript в&nbsp;документации по
        TypeScript .
      </p>
      <p>
        Мы&nbsp;уже добились значительного улучшения времени, необходимого для компиляции наших тестов,
        но&nbsp;мы&nbsp;еще не закончили. Есть еще один метод, который мы&nbsp;можем использовать для компиляции
        TypeScript, swc . Среднее время компиляции нашего проекта swc составляет 0.461&nbsp;seconds.
        Это&nbsp;96%сокращение времени, которое изначально требовалось нам для компиляции с&nbsp;TypeScript. У&nbsp;нас
        были некоторые проблемы с&nbsp;использованием swc, и&nbsp;хотя сейчас он&nbsp;работает с&nbsp;нашими проектами,
        изначально у&nbsp;нас были проблемы при использовании более ранних версий node. На сайте https://swc.rs
        утверждается, что: &quot; он&nbsp;в&nbsp;20&nbsp;раз быстрее, чем babel на&nbsp;одном потоке,
        и&nbsp;в&nbsp;70&nbsp;раз быстрее на&nbsp;4-ядерном бенчмарке &laquo;. Это определенно стоит проверить.
      </p>
      <p>
        Итак, что мы&nbsp;делаем для наших проектов? Мы&nbsp;настраиваем наши собственные проекты для использования
        swcтам, где это возможно, а&nbsp;когда это невозможно, мы&nbsp;используем babel при запуске наших тестов как
        из&nbsp;Wallaby, так и&nbsp;из командной строки&nbsp;/ служб непрерывной интеграции (CI). Наши npm script
        sи&nbsp;CI задачи включают шаг для первой компиляции с&nbsp;использованием, tsc чтобы мы&nbsp;не&nbsp;упустили
        ошибки типов. Исходный код для наших производственных сборок tsc также использует.
      </p>
      <p>
        Также стоит упомянуть, что для небольших проектов (или проектов, которые вы&nbsp;не&nbsp;ожидаете сильного
        роста) встроенный компилятор TypeScript будет вполне хорош. Для более крупных проектов (например, больших
        моно-репозиториев, которые разделяют типы между проектами) вы&nbsp;увидите гораздо больший прирост
        производительности, чем мы&nbsp;получили при использовании babelили swc.
      </p>
    </footer>
  </section>

  <section class="slide">
    <h2>Выводы</h2>
    <ol>
      <li class="next"></li>
    </ol>
    <footer>
      <p>поесть пиццы</p>
      <p></p>
      <p>
        0.1 секунда&nbsp;&mdash; это тот gap, который позволяет пользователю осознать, что именно его клик мышки, удар
        по клавиатуре побудил эти изменения в&nbsp;приложении\интерфейсе.
      </p>
      <p>
        Кажется, у&nbsp;всех было то&nbsp;неловкое чувство, когда ты&nbsp;сочиняешь письмо\код\любой другой текст,
        а&nbsp;интерфейс &laquo;за тобой не&nbsp;успевает&raquo;. Ты&nbsp;уже пишешь второе слово, а&nbsp;на&nbsp;экране
        всё еще песочные часы (если мы&nbsp;про windows) и еле-еле набирается первое. Аналогично и&nbsp;с&nbsp;кликами
        на&nbsp;кнопки. Я&nbsp;хочу, чтобы интерфейс мне подсказывал, мол, &laquo;окей, я&nbsp;тебя услышал, ща&nbsp;все
        будет&raquo;.
      </p>
    </footer>
  </section>

  <section class="slide">
    <img class="cover" src="./themes/tw/images/theory/v8-js-wasm.jpg" alt="" width="525" height="340" />
  </section>

  Движок – это ядро любого браузера. Он представлен в виде скрипта и отвечает за преобразование кода Web-продукта в
  динамическое изображение, которое отображается на экране устройства пользователя. Различия в движках базируются на
  том, что они имеют разные алгоритмы обработки кода. А ещё в них использованы отличные друг от друга принципы
  реализации стандартов web’а. Сейчас актуальны движки Blink, WebKit и Quantum (Gecko), а такие как Trident, EdgeHTML и
  Presto уже ушли в прошлое. Ниже мы рассмотрим основные движки и разберём, как их особенности влияют на тестирование.
  слово производительеость мгновение бескрайних просторов вселенной помнится мгновенной красотой // Что, черт возьми,
  мне с этим делать page tsx pretty_git_log() { git log --graph --pretty="tformat:$FORMAT" $* | column -t -s '{' | less
  -XRS --quit-if-one-screen } rendererSettings: { preserveAspectRatio: "xMidYMid slice" } фром литерал оптимизация
  архитектуры люблю когда быстро грузится тренд как быстро отвечает бекенд запросы к БД Lab vs RUM Real User Monitoring
  Chrome Ux report git config --global pack.usePathWalk true Оптимизация архитектуры поогнозирование inp ask question ai
  typescript anwer

  <section class="slide">
    <img class="place" width="500" height="500" src="./themes/tw/images/theory/tools/eslint.jpg" alt="ESLint" />
  </section>

  xases horosict doubleb cls memory leak yandex 2pdf 10mb preview латест для бороды подставка брюки кросы повысить
  скилскопе инобо git diff pretty0

  <pre>
        <code class="language-typescript">
          Объединение через push
for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {
const result = [];
for (let i = 0; i < arr1.length; i++) {
result.push(arr1[i]);
}
for (let i = 0; i < arr2.length; i++) {
result.push(arr2[i]);
}
}
Объединение через индексы
for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {
const result = Array(ARRAY_SIZE_SMALL * 2);
for (let i = 0; i < arr1.length; i++) {
result[i] = arr1[i];
}
for (let i = 0; i < arr2.length; i++) {
result[i + ARRAY_SIZE_SMALL] = arr2[i];
}
}
        </code>
      </pre>
</section>
