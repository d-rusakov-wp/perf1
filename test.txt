
    <!--    <footer>-->
    <!--      Анализ JavaScript Итак, первым делом мы&nbsp;обрабатываем наш код JavaScript, чтобы разобрать его. Давайте-->
    <!--      обсудим, что такое парсинг. Анализ состоит из&nbsp;двух этапов: Eager (полный анализ)&nbsp;&mdash; анализирует-->
    <!--      каждую строку сразу Ленивый (предварительный анализ)&nbsp;&mdash; делаем минимум, анализируем&nbsp;то, что нам-->
    <!--      нужно, и&nbsp;оставляем остальное на потом. Что лучше? Все зависит от&nbsp;обстоятельств. Давайте посмотрим-->
    <!--      на&nbsp;код.-->
    <!--      <pre>-->
    <!--        <code>-->
    <!--          // eager parse declarations right away-->
    <!--const a = 1;-->
    <!--const b = 2;-->

    <!--// lazily parse this as we don't need it right away-->
    <!--function add(a, b) {-->
    <!--  return a + b;-->
    <!--}-->

    <!--// oh looks like we do need add so lets go back and parse it-->
    <!--add(a, b);-->
    <!--        </code>-->
    <!--      </pre>-->

    <!--      <pre>-->
    <!--          <code>-->
    <!--            // eager parse declarations right away-->
    <!--const a = 1;-->
    <!--const b = 2;-->

    <!--// eager parse this too-->
    <!--var add = (function(a, b) {-->
    <!--  return a + b;-->
    <!--})();-->

    <!--// we can use this right away as we have eager parsed-->
    <!--// already-->
    <!--add(a, b);-->
    <!--          </code>-->
    <!--        </pre>-->
    <!--      <pre>-->
    <!--            Скрытые классы — это то, как V8 идентифицирует наши объекты.-->

    <!--Давайте разберем это на этапы.-->

    <!--Мы объявляем объект:-->

    <!--const obj = { name: 'John'}-->
    <!--Затем V8 объявит classId для этого объекта.-->

    <!--const objClassId = ['name', 1]-->
    <!--Тогда наш объект создается следующим образом:-->

    <!--const obj = {...objClassId, 'John'}-->
    <!--Затем, когда мы получаем доступ к name свойству нашего объекта следующим образом:-->

    <!--obj.name-->
    <!--V8 выполняет следующий поиск:-->

    <!--obj[getProp(obj[0], name)]-->
    <!--Это процесс, который V8 выполняет при создании наших объектов. Теперь давайте посмотрим, как мы можем оптимизировать наши объекты и использовать их повторно classIds.-->

    <!--            Советы по созданию объектов-->
    <!--Если вы можете, вы должны объявить свои свойства в конструкторе . Это гарантирует, что структура объекта останется прежней, чтобы V8 мог оптимизировать ваши объекты.-->

    <!--class Point {-->
    <!--  constructor(x,y) {-->
    <!--    this.x = x-->
    <!--    this.y = y-->
    <!--  }-->
    <!--}-->

    <!--const p1 = new Point(11, 22) // hidden classId created-->
    <!--const p2 = new Point(33, 44)-->
    <!--Вам следует поддерживать постоянный порядок свойств , возьмем следующий пример:-->

    <!--const obj = { a: 1 } // hidden class created-->
    <!--obj.b = 3-->

    <!--const obj2 = { b: 3 } // another hidden class created-->
    <!--obj2.a = 1-->

    <!--// this would be better-->
    <!--const obj = { a: 1 } // hidden class created-->
    <!--obj.b = 3-->

    <!--const obj2 = { a: 1 } // hidden class is reused-->
    <!--obj2.b = 3-->
    <!--Общие советы по оптимизации-->
    <!--Теперь давайте рассмотрим несколько общих советов, которые помогут лучше оптимизировать ваш код JavaScript.-->

    <!--Исправлены типы аргументов функции-->
    <!--Когда аргументы передаются в функцию, важно, чтобы они были одного типа. Turbofan прекратит попытки оптимизировать ваш JavaScript после 4 попыток, если типы аргументов различаются.-->

    <!--Возьмем следующий пример:-->

    <!--function add(x,y) {-->
    <!--  return x + y-->
    <!--}-->

    <!--add(1,2) // monomorphic-->
    <!--add('a', 'b') // polymorphic-->
    <!--add(true, false)-->
    <!--add({},{})-->
    <!--add([],[]) // megamorphic - at this stage, 4+ tries, no optimization will happen-->
    <!--Еще один совет — обязательно объявляйте классы в глобальной области видимости :-->
    <!--        <p>-->
    <!--          Если в&nbsp;течение 10-15 секунд пользователь не&nbsp;покинул ваш сайт, то&nbsp;это почти успех. Главная-->
    <!--          страница&nbsp;&mdash; лицо вашей фирмы в&nbsp;интернете. Захватите внимание пользователя, удержите его-->
    <!--          и&nbsp;перенаправьте на&nbsp;нужные ему разделы. Эффективно работающая главная страница сайта является-->
    <!--          четвертой татуировкой для вашего ресурса.-->
    <!--        </p>-->
    <!--        <p>-->
    <!--          Постоянные улучшения Чтобы сайт не&nbsp;лежал мертвым грузом в&nbsp;сети интернет, а&nbsp;работал как один-->
    <!--          из&nbsp;ваших лучших сотрудников, необходимо время от&nbsp;времени производить анализ поведения пользователей-->
    <!--          и&nbsp;делать выводы, основываясь на&nbsp;этих данных, повышать конверсию (превращение обычного пользователя-->
    <!--          в&nbsp;лояльного клиента). Постоянные улучшения&nbsp;&mdash; 15&nbsp;татуировка для вашего сайта.-->
    <!--        </p>-->
    <!--        <p>-->
    <!--          Акцент на&nbsp;качество и&nbsp;доверие Доверие к&nbsp;вашей компании будет стимулировать посетителя вашего-->
    <!--          сайта к&nbsp;покупке. Поэтому очень важно заполучить его расположение. В&nbsp;этом поможет размещенная-->
    <!--          на&nbsp;сайте следующая информация: официальная отчетность о&nbsp;деятельности вашей организации, информация-->
    <!--          о&nbsp;партнерах, ссылки на&nbsp;приложения вашего ресурса, данные по&nbsp;количеству просмотров каждой-->
    <!--          из&nbsp;статей на&nbsp;сайте, возможность оставлять комментарии и&nbsp;отзывы на&nbsp;вашем сайте, удобное-->
    <!--          портфолио с&nbsp;вашими реальными работами, фото ваших сотрудников, ссылки на&nbsp;социальные сети и&nbsp;т.д.-->
    <!--          Также предоставьте клиентам все необходимые гарантии: продемонстрируйте свои награды, сертификаты качества-->
    <!--          продукции, грамоты и&nbsp;лицензии.-->
    <!--        </p>-->
    <!--        <code>-->
    <!--// don't do this-->
    <!--function createPoint(x, y) {-->
    <!--  class Point {-->
    <!--    constructor(x,y) {-->
    <!--      this.x = x-->
    <!--      this.y = y-->
    <!--    }-->
    <!--  }-->

    <!--  // new point object created every time-->
    <!--  return new Point(x,y)-->
    <!--}-->

    <!--function length(point) {-->
    <!--  //...-->
    <!--}-->
    <!--Заключение-->
    <!--Надеюсь, вы узнали кое-что новое о том, как работает V8 «под капотом» и как писать более оптимизированный код JavaScript.-->
    <!--        </code>-->
    <!--        </pre>-->
    <!--    </footer>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <pre>-->
    <!--<code>-->
    <!--  const markerNameA = "example-marker-a"-->
    <!--const markerNameB = "example-marker-b"-->

    <!--// Run some nested timeouts, and create a PerformanceMark for each.-->
    <!--performance.mark(markerNameA);-->
    <!--setTimeout(function() {-->
    <!--performance.mark(markerNameB);-->
    <!--setTimeout(function() {-->

    <!--  // Create a variety of measurements.-->
    <!--  performance.measure("measure a to b", markerNameA, markerNameB);-->
    <!--  performance.measure("measure a to now", markerNameA);-->
    <!--  performance.measure("measure from navigation start to b", undefined, markerNameB);-->
    <!--  performance.measure("measure from the start of navigation to now");-->

    <!--  // Pull out all of the measurements.-->
    <!--  console.log(performance.getEntriesByType("measure"));-->

    <!--  // Finally, clean up the entries.-->
    <!--  performance.Marks();-->
    <!--  performance.Measures();-->
    <!--}, 1000);-->
    <!--}, 1000);-->

    <!--      console.time("answer time");-->
    <!--alert("Click to continue");-->
    <!--console.timeLog("answer time");-->
    <!--alert("Do a bunch of other stuff...");-->
    <!--console.timeEnd("answer time");-->
    <!--</code>-->
    <!--    </pre>-->
    <!--      <footer>-->
    <!--        <p>-->
    <!--          Высота дерева особенно важна, когда мы&nbsp;имеем дело с&nbsp;определенными типами деревьев, такими как-->
    <!--          двоичные деревья поиска (BST) . Вот почему существует так много различных структур данных, которые реализуют-->
    <!--          самобалансирующиеся BST&nbsp;&mdash; так, чтобы мы&nbsp;могли поддерживать высоту дерева на&nbsp;минимальном-->
    <!--          уровне по&nbsp;мере его роста и&nbsp;выполнять такие операции, как поиск, как можно быстрее. Если-->
    <!--          вы&nbsp;только что оптимизировали функцию, и теперь она работает в&nbsp;100 раз быстрее, усомнитесь-->
    <!--          в&nbsp;ней. Попробуйте опровергнуть свои результаты, попробуйте ее&nbsp;в&nbsp;режиме производства, забросайте-->
    <!--          ее&nbsp;всякой всячиной. Аналогично, усомнитесь и&nbsp;в&nbsp;своих инструментах. Сам факт наблюдения-->
    <!--          за&nbsp;бенчмарком с&nbsp;помощью devtools может изменить ее&nbsp;поведение.-->
    <!--        </p>-->
    <!--        <p>-->
    <!--          Избегайте ненужных утверждений типов Утверждения типов следует использовать осторожно. Чрезмерное их-->
    <!--          использование может привести к&nbsp;ненужным проверкам типов, что может снизить производительность. Вместо-->
    <!--          этого позвольте TypeScript выводить типы, когда это возможно. let value: any = &laquo;Hello,-->
    <!--          TypeScript!&raquo;; let strLength: number = (value as&nbsp;string).length; // Avoid using &rsquo;as-->
    <!--          string&rsquo; if&nbsp;TypeScript can infer the type-->
    <!--        </p>-->
    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2>📡 Подключение</h2>-->
    <!--      <footer>-->

    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <pre>-->
    <!--        <code class="language-typescript">-->
    <!--          {-->
    <!--            "compilerOptions": {-->
    <!--              "target": "ES2019",-->
    <!--              ...-->
    <!--            },-->
    <!--            ...-->
    <!--          }-->
    <!--        </code>-->
    <!--      </pre>-->
    <!--      <footer>-->

    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2>node &#45;&#45;cpu-prof $(which npm) run script</h2>-->
    <!--      <footer>-->
    <!--        <p>-->
    <!--          Большая часть времени тратится на загрузку всех модулей, составляющих npm cli. Время скрипта, который мы-->
    <!--          запускаем, меркнет в сравнении. Мы видим кучу файлов, которые кажутся необходимыми только при выполнении-->
    <!--          определенных условий. Примером этого может служить код для форматирования сообщений об ошибках, который-->
    <!--          требуется только при возникновении ошибки.-->
    <!--        </p>-->
    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <p>-->
    <!--        So if you work on a project which uses barrel files extensively, there is a free optimization you can apply that-->
    <!--        makes many tasks 60-80% faster: Get rid of all barrel files.-->
    <!--      </p>-->
    <!--      <p>-->
    <!--        Процентные результаты представляют собой количество операций, выполненных в&nbsp;течение 1&nbsp;с, деленное на-->
    <!--        количество операций в&nbsp;случае с&nbsp;наивысшей оценкой. Чем выше, тем лучше.-->
    <!--      </p>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="shout">-->
    <!--        &rsquo;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&laquo;&rsquo;-->
    <!--      </h2>-->
    <!--      <footer>-->
    <!--        <p>-->
    <!--          мобильные браузеры будут ждать около 300&nbsp;мс с&nbsp;момента нажатия кнопки, чтобы запустить событие click.-->
    <!--          Причина этого в&nbsp;том, что браузер ждет, чтобы увидеть, действительно&nbsp;ли вы&nbsp;выполняете двойное-->
    <!--          нажатие-->
    <!--        </p>-->
    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <pre>-->
    <!--        <code class="language-typescript">-->
    <!--          // Input: add.ts-->
    <!--const SOME_NUMBER = 10;-->
    <!--export function quickMath(a: number, b: number) {-->
    <!--	return a + b + SOME_NUMBER;-->
    <!--}-->

    <!--// Output: add.d.ts, contains only the bits needed for type checking-->
    <!--export function quickMath(a: number, b: number): number;-->
    <!--        </code>-->
    <!--      </pre>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <pre>-->
    <!--        <code class="language-typescript">-->
    <!--          Объединение через push-->
    <!--for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {-->
    <!--const result = [];-->
    <!--for (let i = 0; i < arr1.length; i++) {-->
    <!--result.push(arr1[i]);-->
    <!--}-->
    <!--for (let i = 0; i < arr2.length; i++) {-->
    <!--result.push(arr2[i]);-->
    <!--}-->
    <!--}-->
    <!--Объединение через индексы-->
    <!--for (let j = 0; j < ARRAY_SIZE_SMALL; j++) {-->
    <!--const result = Array(ARRAY_SIZE_SMALL * 2);-->
    <!--for (let i = 0; i < arr1.length; i++) {-->
    <!--result[i] = arr1[i];-->
    <!--}-->
    <!--for (let i = 0; i < arr2.length; i++) {-->
    <!--result[i + ARRAY_SIZE_SMALL] = arr2[i];-->
    <!--}-->
    <!--}-->
    <!--        </code>-->
    <!--      </pre>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2>https://github.com/danielroe/beasties (Critters)</h2>-->
    <!--      <footer>-->
    <!--        <p>-->
    <!--          Браузерный движок (англ. layout engine) — представляет собой программу (движок), преобразующую содержимое-->
    <!--          веб-страниц (файлы HTML, XML, цифровые изображения и т. д.) и информацию о форматировании (в форматах CSS, XSL-->
    <!--          и т. д.) в интерактивное изображение форматированного содержимого на экране. Браузерный движок обычно-->
    <!--          используется в веб-браузерах (отсюда название), почтовых клиентах и других программах, нуждающихся в-->
    <!--          отображении и редактировании содержимого веб-страниц.-->
    <!--        </p>-->
    <!--      </footer>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2 class="sr-only">Test</h2>-->
    <!--      <ul>-->
    <!--        <li>node &mdash;inspect-brk</li>-->
    <!--        <li>chrome://inspect</li>-->
    <!--        <li><a href="https://perf.link">perf.link</a></li>-->
    <!--        <li>https://npmgraph.js.org/</li>-->
    <!--        <li>eslint-plugin-depend https://github.com/es-tooling/eslint-plugin-depend</li>-->
    <!--        <li>https://github.com/thepassle/eslint-plugin-barrel-files</li>-->
    <!--      </ul>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2>Влияние</h2>-->
    <!--      <ul>-->
    <!--        <li class="next">-->
    <!--          Для-->
    <!--          <a-->
    <!--            href="https://www.gigaspaces.com/blog/amazon-found-every-100ms-of-latency-cost-them-1-in-sales"-->
    <!--            target="_blank"-->
    <!--            rel="noopener noreferrer"-->
    <!--          >Amazon</a-->
    <!--          >-->
    <!--          каждые 100мс задержки обходятся в&nbsp;1% продаж.-->
    <!--        </li>-->
    <!--        <li class="next">-->
    <!--          <a href="https://www.walmart.com/" target="_blank" rel="noopener noreferrer"-->
    <!--          >walmart: 1&nbsp;секунда ускорения + 2%&nbsp;конверсии от&nbsp;400 млрд</a-->
    <!--          >-->
    <!--        </li>-->
    <!--        <li class="next">-->
    <!--          AliExpress сократил время загрузки на&nbsp;36%, увеличил количество заказов на&nbsp;10,5% и&nbsp;увеличил-->
    <!--          конверсию для новых клиентов на&nbsp;27%.-->
    <!--        </li>-->
    <!--      </ul>-->
    <!--    </section>-->
    <!--    <section class="slide">-->
    <!--      <h2 class="shout !text-[42px]">производительность <span class="bold text-orange">===</span> продуктивность</h2>-->
    <!--    </section>-->

    <!--    <section class="slide">-->
    <!--      <h2>Алгоритмы</h2>-->
    <!--      <ul>-->
    <!--        <li>-->
    <!--          выбрать метрики, которыми можно можно охарактериозовать &laquo;степень оптимальности&raquo; нашего сайта или-->
    <!--          приложения-->
    <!--        </li>-->
    <!--        <li>найти код сильене всего ухудшающий метрики</li>-->
    <!--        <li>внести изменния в&nbsp;код</li>-->
    <!--        <li>измерить новые значения</li>-->
    <!--        <li>повторить</li>-->
    <!--      </ul>-->
    <!--    </section>-->
